-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An experimental proof assistant for synthetic ∞-categories
--   
--   Please see the README on GitHub at
--   <a>https://github.com/rzk-lang/rzk#readme</a>
@package rzk
@version 0.7.3

module Free.Scoped
data Inc var
Z :: Inc var
S :: var -> Inc var
type Scope term var = term (Inc var)
instantiate :: Monad f => f a -> f (Inc a) -> f a
abstract :: (Eq a, Functor f) => a -> f a -> f (Inc a)
data FS t a
Pure :: a -> FS t a
Free :: t (Scope (FS t) a) (FS t a) -> FS t a
data Sum f g scope term
InL :: f scope term -> Sum f g scope term
InR :: g scope term -> Sum f g scope term
type (:+:) = Sum
data Empty scope term
data AnnF ann term scope typedTerm
AnnF :: ann typedTerm -> term scope typedTerm -> AnnF ann term scope typedTerm
[annF] :: AnnF ann term scope typedTerm -> ann typedTerm
[termF] :: AnnF ann term scope typedTerm -> term scope typedTerm
transFS :: Bifunctor term => (forall s t. term s t -> term' s t) -> FS term a -> FS term' a
untyped :: (Functor ann, Bifunctor term) => FS (AnnF ann term) a -> FS term a
pattern ExtE :: ext (Scope (FS (t :+: ext)) a) (FS (t :+: ext) a) -> FS (t :+: ext) a
substitute :: Bifunctor t => FS t a -> Scope (FS t) a -> FS t a
instance (GHC.Base.Functor ann, GHC.Base.Functor (term scope)) => GHC.Base.Functor (Free.Scoped.AnnF ann term scope)
instance (GHC.Show.Show (ann typedTerm), GHC.Show.Show (term scope typedTerm)) => GHC.Show.Show (Free.Scoped.AnnF ann term scope typedTerm)
instance GHC.Classes.Eq (term scope typedTerm) => GHC.Classes.Eq (Free.Scoped.AnnF ann term scope typedTerm)
instance (GHC.Base.Functor ann, Data.Bifunctor.Bifunctor term) => Data.Bifunctor.Bifunctor (Free.Scoped.AnnF ann term)
instance Data.Bifoldable.Bifoldable term => Data.Bifoldable.Bifoldable (Free.Scoped.AnnF ann term)
instance (Data.Traversable.Traversable ann, Data.Bitraversable.Bitraversable term) => Data.Bitraversable.Bitraversable (Free.Scoped.AnnF ann term)
instance Data.Bitraversable.Bitraversable Free.Scoped.Empty
instance Data.Bifoldable.Bifoldable Free.Scoped.Empty
instance Data.Bifunctor.Bifunctor Free.Scoped.Empty
instance Data.Traversable.Traversable (Free.Scoped.Empty scope)
instance Data.Foldable.Foldable (Free.Scoped.Empty scope)
instance GHC.Base.Functor (Free.Scoped.Empty scope)
instance (Data.Bitraversable.Bitraversable f, Data.Bitraversable.Bitraversable g) => Data.Bitraversable.Bitraversable (Free.Scoped.Sum f g)
instance (Data.Bifoldable.Bifoldable f, Data.Bifoldable.Bifoldable g) => Data.Bifoldable.Bifoldable (Free.Scoped.Sum f g)
instance (Data.Bifunctor.Bifunctor f, Data.Bifunctor.Bifunctor g) => Data.Bifunctor.Bifunctor (Free.Scoped.Sum f g)
instance Data.Traversable.Traversable Free.Scoped.Inc
instance Data.Foldable.Foldable Free.Scoped.Inc
instance GHC.Base.Functor Free.Scoped.Inc
instance GHC.Show.Show var => GHC.Show.Show (Free.Scoped.Inc var)
instance GHC.Classes.Eq var => GHC.Classes.Eq (Free.Scoped.Inc var)
instance GHC.Generics.Generic (Free.Scoped.Sum f g scope term)
instance (Data.Traversable.Traversable (f scope), Data.Traversable.Traversable (g scope)) => Data.Traversable.Traversable (Free.Scoped.Sum f g scope)
instance (Data.Foldable.Foldable (f scope), Data.Foldable.Foldable (g scope)) => Data.Foldable.Foldable (Free.Scoped.Sum f g scope)
instance (GHC.Base.Functor (f scope), GHC.Base.Functor (g scope)) => GHC.Base.Functor (Free.Scoped.Sum f g scope)
instance (GHC.Classes.Eq a, forall x y. (GHC.Classes.Eq x, GHC.Classes.Eq y) => GHC.Classes.Eq (t x y)) => GHC.Classes.Eq (Free.Scoped.FS t a)
instance Data.Bifunctor.Bifunctor t => GHC.Base.Functor (Free.Scoped.FS t)
instance Data.Bifoldable.Bifoldable t => Data.Foldable.Foldable (Free.Scoped.FS t)
instance Data.Bitraversable.Bitraversable t => Data.Traversable.Traversable (Free.Scoped.FS t)
instance Data.Bifunctor.Bifunctor t => GHC.Base.Applicative (Free.Scoped.FS t)
instance Data.Bifunctor.Bifunctor t => GHC.Base.Monad (Free.Scoped.FS t)

module Free.Scoped.TH
mkConP :: Name -> [Pat] -> Pat
makePatternsAll :: Name -> Q [Dec]
makeCompletePragma :: [Con] -> Q [Dec]
makeCompletePragmaE :: [Con] -> Q [Dec]
makeCompletePragmaT :: [Con] -> Q [Dec]
makeCompletePragmaTE :: [Con] -> Q [Dec]
makePatternFor :: Con -> Q [Dec]
makePatternEFor :: Con -> Q [Dec]
makePatternTFor :: Con -> Q [Dec]
makePatternTEFor :: Con -> Q [Dec]


-- | The abstract syntax of language Syntax.
module Language.Rzk.Syntax.Abs
type Module = Module' BNFC'Position
data Module' a
Module :: a -> LanguageDecl' a -> [Command' a] -> Module' a
type HoleIdent = HoleIdent' BNFC'Position
data HoleIdent' a
HoleIdent :: a -> HoleIdentToken -> HoleIdent' a
type VarIdent = VarIdent' BNFC'Position
data VarIdent' a
VarIdent :: a -> VarIdentToken -> VarIdent' a
type LanguageDecl = LanguageDecl' BNFC'Position
data LanguageDecl' a
LanguageDecl :: a -> Language' a -> LanguageDecl' a
type Language = Language' BNFC'Position
data Language' a
Rzk1 :: a -> Language' a
type Command = Command' BNFC'Position
data Command' a
CommandSetOption :: a -> String -> String -> Command' a
CommandUnsetOption :: a -> String -> Command' a
CommandCheck :: a -> Term' a -> Term' a -> Command' a
CommandCompute :: a -> Term' a -> Command' a
CommandComputeWHNF :: a -> Term' a -> Command' a
CommandComputeNF :: a -> Term' a -> Command' a
CommandPostulate :: a -> VarIdent' a -> DeclUsedVars' a -> [Param' a] -> Term' a -> Command' a
CommandAssume :: a -> [VarIdent' a] -> Term' a -> Command' a
CommandSection :: a -> SectionName' a -> Command' a
CommandSectionEnd :: a -> SectionName' a -> Command' a
CommandDefine :: a -> VarIdent' a -> DeclUsedVars' a -> [Param' a] -> Term' a -> Term' a -> Command' a
type DeclUsedVars = DeclUsedVars' BNFC'Position
data DeclUsedVars' a
DeclUsedVars :: a -> [VarIdent' a] -> DeclUsedVars' a
type SectionName = SectionName' BNFC'Position
data SectionName' a
NoSectionName :: a -> SectionName' a
SomeSectionName :: a -> VarIdent' a -> SectionName' a
type Pattern = Pattern' BNFC'Position
data Pattern' a
PatternUnit :: a -> Pattern' a
PatternVar :: a -> VarIdent' a -> Pattern' a
PatternPair :: a -> Pattern' a -> Pattern' a -> Pattern' a
type Param = Param' BNFC'Position
data Param' a
ParamPattern :: a -> Pattern' a -> Param' a
ParamPatternType :: a -> [Pattern' a] -> Term' a -> Param' a
ParamPatternShape :: a -> [Pattern' a] -> Term' a -> Term' a -> Param' a
ParamPatternShapeDeprecated :: a -> Pattern' a -> Term' a -> Term' a -> Param' a
type ParamDecl = ParamDecl' BNFC'Position
data ParamDecl' a
ParamType :: a -> Term' a -> ParamDecl' a
ParamTermType :: a -> Term' a -> Term' a -> ParamDecl' a
ParamTermShape :: a -> Term' a -> Term' a -> Term' a -> ParamDecl' a
ParamTermTypeDeprecated :: a -> Pattern' a -> Term' a -> ParamDecl' a
ParamVarShapeDeprecated :: a -> Pattern' a -> Term' a -> Term' a -> ParamDecl' a
type Restriction = Restriction' BNFC'Position
data Restriction' a
Restriction :: a -> Term' a -> Term' a -> Restriction' a
ASCII_Restriction :: a -> Term' a -> Term' a -> Restriction' a
type Term = Term' BNFC'Position
data Term' a
Universe :: a -> Term' a
UniverseCube :: a -> Term' a
UniverseTope :: a -> Term' a
CubeUnit :: a -> Term' a
CubeUnitStar :: a -> Term' a
Cube2 :: a -> Term' a
Cube2_0 :: a -> Term' a
Cube2_1 :: a -> Term' a
CubeProduct :: a -> Term' a -> Term' a -> Term' a
TopeTop :: a -> Term' a
TopeBottom :: a -> Term' a
TopeEQ :: a -> Term' a -> Term' a -> Term' a
TopeLEQ :: a -> Term' a -> Term' a -> Term' a
TopeAnd :: a -> Term' a -> Term' a -> Term' a
TopeOr :: a -> Term' a -> Term' a -> Term' a
RecBottom :: a -> Term' a
RecOr :: a -> [Restriction' a] -> Term' a
RecOrDeprecated :: a -> Term' a -> Term' a -> Term' a -> Term' a -> Term' a
TypeFun :: a -> ParamDecl' a -> Term' a -> Term' a
TypeSigma :: a -> Pattern' a -> Term' a -> Term' a -> Term' a
TypeUnit :: a -> Term' a
TypeId :: a -> Term' a -> Term' a -> Term' a -> Term' a
TypeIdSimple :: a -> Term' a -> Term' a -> Term' a
TypeRestricted :: a -> Term' a -> [Restriction' a] -> Term' a
TypeExtensionDeprecated :: a -> ParamDecl' a -> Term' a -> Term' a
App :: a -> Term' a -> Term' a -> Term' a
Lambda :: a -> [Param' a] -> Term' a -> Term' a
Pair :: a -> Term' a -> Term' a -> Term' a
First :: a -> Term' a -> Term' a
Second :: a -> Term' a -> Term' a
Unit :: a -> Term' a
Refl :: a -> Term' a
ReflTerm :: a -> Term' a -> Term' a
ReflTermType :: a -> Term' a -> Term' a -> Term' a
IdJ :: a -> Term' a -> Term' a -> Term' a -> Term' a -> Term' a -> Term' a -> Term' a
Hole :: a -> HoleIdent' a -> Term' a
Var :: a -> VarIdent' a -> Term' a
TypeAsc :: a -> Term' a -> Term' a -> Term' a
ASCII_CubeUnitStar :: a -> Term' a
ASCII_Cube2_0 :: a -> Term' a
ASCII_Cube2_1 :: a -> Term' a
ASCII_TopeTop :: a -> Term' a
ASCII_TopeBottom :: a -> Term' a
ASCII_TopeEQ :: a -> Term' a -> Term' a -> Term' a
ASCII_TopeLEQ :: a -> Term' a -> Term' a -> Term' a
ASCII_TopeAnd :: a -> Term' a -> Term' a -> Term' a
ASCII_TopeOr :: a -> Term' a -> Term' a -> Term' a
ASCII_TypeFun :: a -> ParamDecl' a -> Term' a -> Term' a
ASCII_TypeSigma :: a -> Pattern' a -> Term' a -> Term' a -> Term' a
ASCII_Lambda :: a -> [Param' a] -> Term' a -> Term' a
ASCII_TypeExtensionDeprecated :: a -> ParamDecl' a -> Term' a -> Term' a
ASCII_First :: a -> Term' a -> Term' a
ASCII_Second :: a -> Term' a -> Term' a
commandPostulateNoParams :: a -> VarIdent' a -> DeclUsedVars' a -> Term' a -> Command' a
commandVariable :: a -> VarIdent' a -> Term' a -> Command' a
commandVariables :: a -> [VarIdent' a] -> Term' a -> Command' a
commandDefineNoParams :: a -> VarIdent' a -> DeclUsedVars' a -> Term' a -> Term' a -> Command' a
commandDef :: a -> VarIdent' a -> DeclUsedVars' a -> [Param' a] -> Term' a -> Term' a -> Command' a
commandDefNoParams :: a -> VarIdent' a -> DeclUsedVars' a -> Term' a -> Term' a -> Command' a
noDeclUsedVars :: a -> DeclUsedVars' a
paramVarShapeDeprecated :: a -> Pattern' a -> Term' a -> Term' a -> ParamDecl' a
ascii_CubeProduct :: a -> Term' a -> Term' a -> Term' a
unicode_TypeSigmaAlt :: a -> Pattern' a -> Term' a -> Term' a -> Term' a
newtype VarIdentToken
VarIdentToken :: String -> VarIdentToken
newtype HoleIdentToken
HoleIdentToken :: String -> HoleIdentToken

-- | Start position (line, column) of something.
type BNFC'Position = Maybe (Int, Int)
pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'Position :: Int -> Int -> BNFC'Position

-- | Get the start position of something.
class HasPosition a
hasPosition :: HasPosition a => a -> BNFC'Position
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.Language' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.Language' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.Language'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.Language'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.Language'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.Language' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.Language' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.Language' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.Language' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.LanguageDecl' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.LanguageDecl' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.LanguageDecl'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.LanguageDecl'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.LanguageDecl'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.LanguageDecl' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.LanguageDecl' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.LanguageDecl' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.LanguageDecl' a)
instance Data.String.IsString Language.Rzk.Syntax.Abs.VarIdentToken
instance GHC.Generics.Generic Language.Rzk.Syntax.Abs.VarIdentToken
instance Data.Data.Data Language.Rzk.Syntax.Abs.VarIdentToken
instance GHC.Read.Read Language.Rzk.Syntax.Abs.VarIdentToken
instance GHC.Show.Show Language.Rzk.Syntax.Abs.VarIdentToken
instance GHC.Classes.Ord Language.Rzk.Syntax.Abs.VarIdentToken
instance GHC.Classes.Eq Language.Rzk.Syntax.Abs.VarIdentToken
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.VarIdent' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.VarIdent' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.VarIdent'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.VarIdent'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.VarIdent'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.VarIdent' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.VarIdent' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.VarIdent' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.VarIdent' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.Pattern' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.Pattern' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.Pattern'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.Pattern'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.Pattern'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.Pattern' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.Pattern' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.Pattern' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.Pattern' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.SectionName' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.SectionName' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.SectionName'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.SectionName'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.SectionName'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.SectionName' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.SectionName' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.SectionName' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.SectionName' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.DeclUsedVars' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.DeclUsedVars' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.DeclUsedVars'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.DeclUsedVars'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.DeclUsedVars'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.DeclUsedVars' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.DeclUsedVars' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.DeclUsedVars' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.DeclUsedVars' a)
instance Data.String.IsString Language.Rzk.Syntax.Abs.HoleIdentToken
instance GHC.Generics.Generic Language.Rzk.Syntax.Abs.HoleIdentToken
instance Data.Data.Data Language.Rzk.Syntax.Abs.HoleIdentToken
instance GHC.Read.Read Language.Rzk.Syntax.Abs.HoleIdentToken
instance GHC.Show.Show Language.Rzk.Syntax.Abs.HoleIdentToken
instance GHC.Classes.Ord Language.Rzk.Syntax.Abs.HoleIdentToken
instance GHC.Classes.Eq Language.Rzk.Syntax.Abs.HoleIdentToken
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.HoleIdent' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.HoleIdent' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.HoleIdent'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.HoleIdent'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.HoleIdent'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.HoleIdent' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.HoleIdent' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.HoleIdent' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.HoleIdent' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.Param' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.Param' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.Param'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.Param'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.Param'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.Param' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.Param' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.Param' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.Param' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.ParamDecl' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.ParamDecl' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.ParamDecl'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.ParamDecl'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.ParamDecl'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.ParamDecl' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.ParamDecl' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.ParamDecl' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.ParamDecl' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.Restriction' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.Restriction' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.Restriction'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.Restriction'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.Restriction'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.Restriction' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.Restriction' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.Restriction' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.Restriction' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.Term' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.Term' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.Term'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.Term'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.Term'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.Term' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.Term' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.Term' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.Term' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.Command' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.Command' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.Command'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.Command'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.Command'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.Command' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.Command' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.Command' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.Command' a)
instance GHC.Generics.Generic (Language.Rzk.Syntax.Abs.Module' a)
instance Data.Data.Data a => Data.Data.Data (Language.Rzk.Syntax.Abs.Module' a)
instance Data.Traversable.Traversable Language.Rzk.Syntax.Abs.Module'
instance Data.Foldable.Foldable Language.Rzk.Syntax.Abs.Module'
instance GHC.Base.Functor Language.Rzk.Syntax.Abs.Module'
instance GHC.Read.Read a => GHC.Read.Read (Language.Rzk.Syntax.Abs.Module' a)
instance GHC.Show.Show a => GHC.Show.Show (Language.Rzk.Syntax.Abs.Module' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Language.Rzk.Syntax.Abs.Module' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Language.Rzk.Syntax.Abs.Module' a)
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.Module
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.HoleIdent
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.VarIdent
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.LanguageDecl
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.Language
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.Command
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.DeclUsedVars
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.SectionName
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.Pattern
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.Param
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.ParamDecl
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.Restriction
instance Language.Rzk.Syntax.Abs.HasPosition Language.Rzk.Syntax.Abs.Term

module Language.Rzk.Syntax.Lex
alex_tab_size :: Int
alex_base :: AlexAddr
alex_table :: AlexAddr
alex_check :: AlexAddr
alex_deflt :: AlexAddr
alex_accept :: Array Int (AlexAcc user)
alex_actions :: Array Int (Posn -> String -> Token)
alex_action_3 :: Posn -> String -> Token
alex_action_4 :: Posn -> String -> Token
alex_action_5 :: Posn -> String -> Token
alex_action_6 :: Posn -> String -> Token
alex_action_7 :: Posn -> String -> Token
data AlexAddr
AlexA# :: Addr# -> AlexAddr
alexIndexInt16OffAddr :: AlexAddr -> Int# -> Int#
alexIndexInt32OffAddr :: AlexAddr -> Int# -> Int#
quickIndex :: Array Int (AlexAcc (Any :: Type)) -> Int -> AlexAcc (Any :: Type)
data AlexReturn a
AlexEOF :: AlexReturn a
AlexError :: !AlexInput -> AlexReturn a
AlexSkip :: !AlexInput -> !Int -> AlexReturn a
AlexToken :: !AlexInput -> !Int -> a -> AlexReturn a
alexScan :: (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alexScanUser :: t -> (Posn, Char, [Byte], String) -> Int -> AlexReturn (Posn -> String -> Token)
alex_scan_tkn :: t -> t -> Int# -> AlexInput -> Int# -> AlexLastAcc -> (AlexLastAcc, (Posn, Char, [Byte], String))
data AlexLastAcc
AlexNone :: AlexLastAcc
AlexLastAcc :: !Int -> !AlexInput -> !Int -> AlexLastAcc
AlexLastSkip :: !AlexInput -> !Int -> AlexLastAcc
data AlexAcc user
AlexAccNone :: AlexAcc user
AlexAcc :: Int -> AlexAcc user
AlexAccSkip :: AlexAcc user

-- | Create a token with position.
tok :: (String -> Tok) -> Posn -> String -> Token

-- | Token without position.
data Tok

-- | Reserved word or symbol.
TK :: {-# UNPACK #-} !TokSymbol -> Tok

-- | String literal.
TL :: !String -> Tok

-- | Integer literal.
TI :: !String -> Tok

-- | Identifier.
TV :: !String -> Tok

-- | Float literal.
TD :: !String -> Tok

-- | Character literal.
TC :: !String -> Tok
T_VarIdentToken :: !String -> Tok
T_HoleIdentToken :: !String -> Tok

-- | Smart constructor for <a>Tok</a> for the sake of backwards
--   compatibility.
pattern TS :: String -> Int -> Tok

-- | Keyword or symbol tokens have a unique ID.
data TokSymbol
TokSymbol :: String -> !Int -> TokSymbol

-- | Keyword or symbol text.
[tsText] :: TokSymbol -> String

-- | Unique ID.
[tsID] :: TokSymbol -> !Int

-- | Token with position.
data Token
PT :: Posn -> Tok -> Token
Err :: Posn -> Token

-- | Pretty print a position.
printPosn :: Posn -> String

-- | Pretty print the position of the first token in the list.
tokenPos :: [Token] -> String

-- | Get the position of a token.
tokenPosn :: Token -> Posn

-- | Get line and column of a token.
tokenLineCol :: Token -> (Int, Int)

-- | Get line and column of a position.
posLineCol :: Posn -> (Int, Int)

-- | Convert a token into "position token" form.
mkPosToken :: Token -> ((Int, Int), String)

-- | Convert a token to its text.
tokenText :: Token -> String

-- | Convert a token to a string.
prToken :: Token -> String

-- | Finite map from text to token organized as binary search tree.
data BTree

-- | Nil (leaf).
N :: BTree

-- | Binary node.
B :: String -> Tok -> BTree -> BTree -> BTree

-- | Convert potential keyword into token or use fallback conversion.
eitherResIdent :: (String -> Tok) -> String -> Tok

-- | The keywords and symbols of the language organized as binary search
--   tree.
resWords :: BTree

-- | Unquote string literal.
unescapeInitTail :: String -> String
data Posn
Pn :: !Int -> !Int -> !Int -> Posn
alexStartPos :: Posn
alexMove :: Posn -> Char -> Posn
type Byte = Word8
type AlexInput = (Posn, Char, [Byte], String)
tokens :: String -> [Token]
alexGetByte :: AlexInput -> Maybe (Byte, AlexInput)
alexInputPrevChar :: AlexInput -> Char

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
utf8Encode :: Char -> [Word8]
instance GHC.Show.Show Language.Rzk.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord Language.Rzk.Syntax.Lex.Tok
instance GHC.Show.Show Language.Rzk.Syntax.Lex.Tok
instance GHC.Classes.Eq Language.Rzk.Syntax.Lex.Tok
instance GHC.Show.Show Language.Rzk.Syntax.Lex.BTree
instance GHC.Classes.Ord Language.Rzk.Syntax.Lex.Posn
instance GHC.Show.Show Language.Rzk.Syntax.Lex.Posn
instance GHC.Classes.Eq Language.Rzk.Syntax.Lex.Posn
instance GHC.Classes.Ord Language.Rzk.Syntax.Lex.Token
instance GHC.Show.Show Language.Rzk.Syntax.Lex.Token
instance GHC.Classes.Eq Language.Rzk.Syntax.Lex.Token
instance GHC.Classes.Eq Language.Rzk.Syntax.Lex.TokSymbol
instance GHC.Classes.Ord Language.Rzk.Syntax.Lex.TokSymbol

module Language.Rzk.Syntax.Layout
data LayoutDelimiters
LayoutDelimiters :: TokSymbol -> Maybe TokSymbol -> Maybe TokSymbol -> LayoutDelimiters
[delimSep] :: LayoutDelimiters -> TokSymbol

-- | Nothing for toplevel layout.
[delimOpen] :: LayoutDelimiters -> Maybe TokSymbol

-- | Nothing for toplevel layout.
[delimClose] :: LayoutDelimiters -> Maybe TokSymbol
layoutWords :: [(TokSymbol, LayoutDelimiters)]
layoutStopWords :: [TokSymbol]
layoutOpen :: [TokSymbol]
layoutClose :: [TokSymbol]
layoutSep :: [TokSymbol]
parenOpen :: [TokSymbol]
parenClose :: [TokSymbol]

-- | Report an error during layout resolution.
layoutError :: [Token] -> String -> a

-- | Replace layout syntax with explicit layout tokens.
resolveLayout :: Bool -> [Token] -> [Token]
type Position = Posn
type Line = Int
type Column = Int

-- | Entry of the layout stack.
data Block

-- | An implicit layout block with its start column.
Implicit :: LayoutDelimiters -> Status -> Column -> Block
Explicit :: Block

-- | Get current indentation. 0 if we are in an explicit block.
indentation :: Block -> Column

-- | Check if s block is implicit.
isImplicit :: Block -> Bool
data Status

-- | A layout column that has not been confirmed by a line break
Tentative :: Status

-- | A layout column that has been confirmed by a line break.
Definitive :: Status

-- | Add a new implicit layout block.
addImplicit :: LayoutDelimiters -> Position -> Position -> [Block] -> [Block]

-- | Confirm tentative blocks that are not more indented than <tt>col</tt>.
confirm :: Column -> [Block] -> [Block]

-- | Get the position immediately to the right of the given token. If no
--   token is given, gets the first position in the file.
afterPrev :: Maybe Token -> Position

-- | Get the position immediately to the right of the given token.
nextPos :: Token -> Position

-- | Get the number of characters in the token.
tokenLength :: Token -> Int

-- | Create a position symbol token.
sToken :: Position -> TokSymbol -> Token

-- | Get the line number of a token.
line :: Token -> Line

-- | Get the column number of a token.
column :: Token -> Column

-- | Is the following token on a new line?
newLine :: Maybe Token -> Token -> Bool

-- | Check if a word is a layout start token.
isLayout :: Token -> Maybe LayoutDelimiters

-- | Check if a token is one of the given symbols.
isTokenIn :: [TokSymbol] -> Token -> Bool

-- | Check if a token is a layout stop token.
isStop :: Token -> Bool

-- | Check if a token is the layout open token.
isLayoutOpen :: Token -> Bool

-- | Check if a token is the layout separator token.
isLayoutSep :: Token -> Bool

-- | Check if a token is the layout close token.
isLayoutClose :: Token -> Bool

-- | Check if a token is an opening parenthesis.
isParenOpen :: Token -> Bool

-- | Check if a token is a closing parenthesis.
isParenClose :: Token -> Bool

module Language.Rzk.Syntax.Par
happyError :: [Token] -> Err a
myLexer :: String -> [Token]
pModule :: [Token] -> Err Module
pHoleIdent :: [Token] -> Err HoleIdent
pVarIdent :: [Token] -> Err VarIdent
pListVarIdent :: [Token] -> Err [VarIdent]
pLanguageDecl :: [Token] -> Err LanguageDecl
pLanguage :: [Token] -> Err Language
pCommand :: [Token] -> Err Command
pListCommand :: [Token] -> Err [Command]
pDeclUsedVars :: [Token] -> Err DeclUsedVars
pSectionName :: [Token] -> Err SectionName
pPattern :: [Token] -> Err Pattern
pListPattern :: [Token] -> Err [Pattern]
pParam :: [Token] -> Err Param
pListParam :: [Token] -> Err [Param]
pParamDecl :: [Token] -> Err ParamDecl
pRestriction :: [Token] -> Err Restriction
pListRestriction :: [Token] -> Err [Restriction]
pTerm7 :: [Token] -> Err Term
pTerm5 :: [Token] -> Err Term
pTerm4 :: [Token] -> Err Term
pTerm3 :: [Token] -> Err Term
pTerm2 :: [Token] -> Err Term
pTerm1 :: [Token] -> Err Term
pTerm6 :: [Token] -> Err Term
pTerm :: [Token] -> Err Term
pListTerm :: [Token] -> Err [Term]


-- | Pretty-printer for Language.
module Language.Rzk.Syntax.Print

-- | The top-level printing method.
printTree :: Print a => a -> String
type Doc = [ShowS] -> [ShowS]
doc :: ShowS -> Doc
render :: Doc -> String
parenth :: Doc -> Doc
concatS :: [ShowS] -> ShowS
concatD :: [Doc] -> Doc
replicateS :: Int -> ShowS -> ShowS

-- | The printer class does the job.
class Print a
prt :: Print a => Int -> a -> Doc
printString :: String -> Doc
mkEsc :: Char -> Char -> ShowS
prPrec :: Int -> Int -> Doc -> Doc
instance Language.Rzk.Syntax.Print.Print a => Language.Rzk.Syntax.Print.Print [a]
instance Language.Rzk.Syntax.Print.Print GHC.Types.Char
instance Language.Rzk.Syntax.Print.Print GHC.Base.String
instance Language.Rzk.Syntax.Print.Print GHC.Num.Integer.Integer
instance Language.Rzk.Syntax.Print.Print GHC.Types.Double
instance Language.Rzk.Syntax.Print.Print Language.Rzk.Syntax.Abs.VarIdentToken
instance Language.Rzk.Syntax.Print.Print Language.Rzk.Syntax.Abs.HoleIdentToken
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.Module' a)
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.HoleIdent' a)
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.VarIdent' a)
instance Language.Rzk.Syntax.Print.Print [Language.Rzk.Syntax.Abs.VarIdent' a]
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.LanguageDecl' a)
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.Language' a)
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.Command' a)
instance Language.Rzk.Syntax.Print.Print [Language.Rzk.Syntax.Abs.Command' a]
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.DeclUsedVars' a)
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.SectionName' a)
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.Pattern' a)
instance Language.Rzk.Syntax.Print.Print [Language.Rzk.Syntax.Abs.Pattern' a]
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.Param' a)
instance Language.Rzk.Syntax.Print.Print [Language.Rzk.Syntax.Abs.Param' a]
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.ParamDecl' a)
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.Restriction' a)
instance Language.Rzk.Syntax.Print.Print [Language.Rzk.Syntax.Abs.Restriction' a]
instance Language.Rzk.Syntax.Print.Print (Language.Rzk.Syntax.Abs.Term' a)
instance Language.Rzk.Syntax.Print.Print [Language.Rzk.Syntax.Abs.Term' a]

module Language.Rzk.Syntax
parseModuleSafe :: String -> IO (Either String Module)
parseModule :: String -> Either String Module
parseModuleRzk :: String -> Either String Module
parseModuleFile :: FilePath -> IO (Either String Module)
parseTerm :: String -> Either String Term

-- | Replace layout syntax with explicit layout tokens.
resolveLayout :: Bool -> [Token] -> Either String [Token]

-- | The printer class does the job.
class Print a
prt :: Print a => Int -> a -> Doc

-- | Like <a>printTree</a>, but does not insert newlines for curly braces.
printTree :: Print a => a -> String
tryExtractMarkdownCodeBlocks :: String -> String -> String

-- | Extract code for a given alias (e.g. "rzk" or "haskell") from a
--   Markdown file by replacing any lines that do not belong to the code in
--   that language with blank lines. This way the line numbers are
--   preserved correctly from the original file.
--   
--   All of the following notations are supported to start a code block:
--   
--   <ul>
--   <li><pre>```rzk</pre></li>
--   <li><pre>```{.rzk title="Example"}</pre></li>
--   <li><pre>``` { .rzk title="Example" }</pre></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; example = "Example:\n```rzk\n#lang rzk-1\n```\nasd asd\n```rzk\n#def x : U\n  := U\n``` \nasda"
--   
--   &gt;&gt;&gt; putStrLn example
--   Example:
--   ```rzk
--   #lang rzk-1
--   ```
--   asd asd
--   ```rzk
--   #def x : U
--     := U
--   ```
--   asda
--   
--   &gt;&gt;&gt; putStrLn $ extractMarkdownCodeBlocks "rzk" example
--   
--   
--   #lang rzk-1
--   
--   
--   
--   #def x : U
--     := U
--   </pre>
extractMarkdownCodeBlocks :: String -> String -> String
tryOrDisplayException :: Either String a -> IO (Either String a)
tryOrDisplayExceptionIO :: IO (Either String a) -> IO (Either String a)

module Language.Rzk.Free.Syntax
data RzkPosition
RzkPosition :: Maybe FilePath -> BNFC'Position -> RzkPosition
[rzkFilePath] :: RzkPosition -> Maybe FilePath
[rzkLineCol] :: RzkPosition -> BNFC'Position
ppRzkPosition :: RzkPosition -> String
newtype VarIdent
VarIdent :: VarIdent' RzkPosition -> VarIdent
[getVarIdent] :: VarIdent -> VarIdent' RzkPosition
ppVarIdentWithLocation :: VarIdent -> String
varIdent :: VarIdent -> VarIdent
varIdentAt :: Maybe FilePath -> VarIdent -> VarIdent
fromVarIdent :: VarIdent -> VarIdent
data TermF scope term
UniverseF :: TermF scope term
UniverseCubeF :: TermF scope term
UniverseTopeF :: TermF scope term
CubeUnitF :: TermF scope term
CubeUnitStarF :: TermF scope term
Cube2F :: TermF scope term
Cube2_0F :: TermF scope term
Cube2_1F :: TermF scope term
CubeProductF :: term -> term -> TermF scope term
TopeTopF :: TermF scope term
TopeBottomF :: TermF scope term
TopeEQF :: term -> term -> TermF scope term
TopeLEQF :: term -> term -> TermF scope term
TopeAndF :: term -> term -> TermF scope term
TopeOrF :: term -> term -> TermF scope term
RecBottomF :: TermF scope term
RecOrF :: [(term, term)] -> TermF scope term
TypeFunF :: Maybe VarIdent -> term -> Maybe scope -> scope -> TermF scope term
TypeSigmaF :: Maybe VarIdent -> term -> scope -> TermF scope term
TypeIdF :: term -> Maybe term -> term -> TermF scope term
AppF :: term -> term -> TermF scope term
LambdaF :: Maybe VarIdent -> Maybe (term, Maybe scope) -> scope -> TermF scope term
PairF :: term -> term -> TermF scope term
FirstF :: term -> TermF scope term
SecondF :: term -> TermF scope term
ReflF :: Maybe (term, Maybe term) -> TermF scope term
IdJF :: term -> term -> term -> term -> term -> term -> TermF scope term
UnitF :: TermF scope term
TypeUnitF :: TermF scope term
TypeAscF :: term -> term -> TermF scope term
TypeRestrictedF :: term -> [(term, term)] -> TermF scope term
pattern TypeRestrictedTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> [(FS (Sum (AnnF ann TermF) g) a, FS (Sum (AnnF ann TermF) g) a)] -> FS (Sum (AnnF ann TermF) g) a
pattern TypeAscTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern TypeUnitTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern UnitTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern IdJTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern ReflTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> Maybe (FS (Sum (AnnF ann TermF) g) a, Maybe (FS (Sum (AnnF ann TermF) g) a)) -> FS (Sum (AnnF ann TermF) g) a
pattern SecondTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern FirstTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern PairTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern LambdaTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> Maybe VarIdent -> Maybe (FS (Sum (AnnF ann TermF) g) a, Maybe (Scope (FS (Sum (AnnF ann TermF) g)) a)) -> Scope (FS (Sum (AnnF ann TermF) g)) a -> FS (Sum (AnnF ann TermF) g) a
pattern AppTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern TypeIdTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> Maybe (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern TypeSigmaTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> Maybe VarIdent -> FS (Sum (AnnF ann TermF) g) a -> Scope (FS (Sum (AnnF ann TermF) g)) a -> FS (Sum (AnnF ann TermF) g) a
pattern TypeFunTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> Maybe VarIdent -> FS (Sum (AnnF ann TermF) g) a -> Maybe (Scope (FS (Sum (AnnF ann TermF) g)) a) -> Scope (FS (Sum (AnnF ann TermF) g)) a -> FS (Sum (AnnF ann TermF) g) a
pattern RecOrTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> [(FS (Sum (AnnF ann TermF) g) a, FS (Sum (AnnF ann TermF) g) a)] -> FS (Sum (AnnF ann TermF) g) a
pattern RecBottomTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern TopeOrTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern TopeAndTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern TopeLEQTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern TopeEQTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern TopeBottomTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern TopeTopTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern CubeProductTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a -> FS (Sum (AnnF ann TermF) g) a
pattern Cube2_1TE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern Cube2_0TE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern Cube2TE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern CubeUnitStarTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern CubeUnitTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern UniverseTopeTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern UniverseCubeTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern UniverseTE :: forall {ann} {g :: Type -> Type -> Type} {a}. ann (FS (Sum (AnnF ann TermF) g) a) -> FS (Sum (AnnF ann TermF) g) a
pattern TypeRestrictedT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> [(FS (AnnF ann TermF) a, FS (AnnF ann TermF) a)] -> FS (AnnF ann TermF) a
pattern TypeAscT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern TypeUnitT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern UnitT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern IdJT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern ReflT :: ann (FS (AnnF ann TermF) a) -> Maybe (FS (AnnF ann TermF) a, Maybe (FS (AnnF ann TermF) a)) -> FS (AnnF ann TermF) a
pattern SecondT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern FirstT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern PairT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern LambdaT :: ann (FS (AnnF ann TermF) a) -> Maybe VarIdent -> Maybe (FS (AnnF ann TermF) a, Maybe (Scope (FS (AnnF ann TermF)) a)) -> Scope (FS (AnnF ann TermF)) a -> FS (AnnF ann TermF) a
pattern AppT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern TypeIdT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> Maybe (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern TypeSigmaT :: ann (FS (AnnF ann TermF) a) -> Maybe VarIdent -> FS (AnnF ann TermF) a -> Scope (FS (AnnF ann TermF)) a -> FS (AnnF ann TermF) a
pattern TypeFunT :: ann (FS (AnnF ann TermF) a) -> Maybe VarIdent -> FS (AnnF ann TermF) a -> Maybe (Scope (FS (AnnF ann TermF)) a) -> Scope (FS (AnnF ann TermF)) a -> FS (AnnF ann TermF) a
pattern RecOrT :: ann (FS (AnnF ann TermF) a) -> [(FS (AnnF ann TermF) a, FS (AnnF ann TermF) a)] -> FS (AnnF ann TermF) a
pattern RecBottomT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern TopeOrT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern TopeAndT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern TopeLEQT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern TopeEQT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern TopeBottomT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern TopeTopT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern CubeProductT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a -> FS (AnnF ann TermF) a
pattern Cube2_1T :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern Cube2_0T :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern Cube2T :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern CubeUnitStarT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern CubeUnitT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern UniverseTopeT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern UniverseCubeT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern UniverseT :: ann (FS (AnnF ann TermF) a) -> FS (AnnF ann TermF) a
pattern TypeRestrictedE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> [(FS (Sum TermF g) a, FS (Sum TermF g) a)] -> FS (Sum TermF g) a
pattern TypeAscE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern TypeUnitE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern UnitE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern IdJE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern ReflE :: forall {g :: Type -> Type -> Type} {a}. Maybe (FS (Sum TermF g) a, Maybe (FS (Sum TermF g) a)) -> FS (Sum TermF g) a
pattern SecondE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern FirstE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern PairE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern LambdaE :: forall {g :: Type -> Type -> Type} {a}. Maybe VarIdent -> Maybe (FS (Sum TermF g) a, Maybe (Scope (FS (Sum TermF g)) a)) -> Scope (FS (Sum TermF g)) a -> FS (Sum TermF g) a
pattern AppE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern TypeIdE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> Maybe (FS (Sum TermF g) a) -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern TypeSigmaE :: forall {g :: Type -> Type -> Type} {a}. Maybe VarIdent -> FS (Sum TermF g) a -> Scope (FS (Sum TermF g)) a -> FS (Sum TermF g) a
pattern TypeFunE :: forall {g :: Type -> Type -> Type} {a}. Maybe VarIdent -> FS (Sum TermF g) a -> Maybe (Scope (FS (Sum TermF g)) a) -> Scope (FS (Sum TermF g)) a -> FS (Sum TermF g) a
pattern RecOrE :: forall {g :: Type -> Type -> Type} {a}. [(FS (Sum TermF g) a, FS (Sum TermF g) a)] -> FS (Sum TermF g) a
pattern RecBottomE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern TopeOrE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern TopeAndE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern TopeLEQE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern TopeEQE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern TopeBottomE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern TopeTopE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern CubeProductE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a -> FS (Sum TermF g) a -> FS (Sum TermF g) a
pattern Cube2_1E :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern Cube2_0E :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern Cube2E :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern CubeUnitStarE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern CubeUnitE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern UniverseTopeE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern UniverseCubeE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern UniverseE :: forall {g :: Type -> Type -> Type} {a}. FS (Sum TermF g) a
pattern TypeRestricted :: FS TermF a -> [(FS TermF a, FS TermF a)] -> FS TermF a
pattern TypeAsc :: FS TermF a -> FS TermF a -> FS TermF a
pattern TypeUnit :: FS TermF a
pattern Unit :: FS TermF a
pattern IdJ :: FS TermF a -> FS TermF a -> FS TermF a -> FS TermF a -> FS TermF a -> FS TermF a -> FS TermF a
pattern Refl :: Maybe (FS TermF a, Maybe (FS TermF a)) -> FS TermF a
pattern Second :: FS TermF a -> FS TermF a
pattern First :: FS TermF a -> FS TermF a
pattern Pair :: FS TermF a -> FS TermF a -> FS TermF a
pattern Lambda :: Maybe VarIdent -> Maybe (FS TermF a, Maybe (Scope (FS TermF) a)) -> Scope (FS TermF) a -> FS TermF a
pattern App :: FS TermF a -> FS TermF a -> FS TermF a
pattern TypeId :: FS TermF a -> Maybe (FS TermF a) -> FS TermF a -> FS TermF a
pattern TypeSigma :: Maybe VarIdent -> FS TermF a -> Scope (FS TermF) a -> FS TermF a
pattern TypeFun :: Maybe VarIdent -> FS TermF a -> Maybe (Scope (FS TermF) a) -> Scope (FS TermF) a -> FS TermF a
pattern RecOr :: [(FS TermF a, FS TermF a)] -> FS TermF a
pattern RecBottom :: FS TermF a
pattern TopeOr :: FS TermF a -> FS TermF a -> FS TermF a
pattern TopeAnd :: FS TermF a -> FS TermF a -> FS TermF a
pattern TopeLEQ :: FS TermF a -> FS TermF a -> FS TermF a
pattern TopeEQ :: FS TermF a -> FS TermF a -> FS TermF a
pattern TopeBottom :: FS TermF a
pattern TopeTop :: FS TermF a
pattern CubeProduct :: FS TermF a -> FS TermF a -> FS TermF a
pattern Cube2_1 :: FS TermF a
pattern Cube2_0 :: FS TermF a
pattern Cube2 :: FS TermF a
pattern CubeUnitStar :: FS TermF a
pattern CubeUnit :: FS TermF a
pattern UniverseTope :: FS TermF a
pattern UniverseCube :: FS TermF a
pattern Universe :: FS TermF a
newtype Type term
Type :: term -> Type term
[getType] :: Type term -> term
data TypeInfo term
TypeInfo :: term -> Maybe term -> Maybe term -> TypeInfo term
[infoType] :: TypeInfo term -> term
[infoWHNF] :: TypeInfo term -> Maybe term
[infoNF] :: TypeInfo term -> Maybe term
type Term = FS TermF
type TermT = FS (AnnF TypeInfo TermF)
termIsWHNF :: TermT var -> TermT var
termIsNF :: TermT var -> TermT var
invalidateWHNF :: TermT var -> TermT var
substituteT :: TermT var -> Scope TermT var -> TermT var
type Term' = Term VarIdent
type TermT' = TermT VarIdent
freeVars :: Term a -> [a]
partialFreeVarsT :: TermT a -> [a]
freeVarsT :: Eq a => (a -> TermT a) -> TermT a -> [a]
toTerm' :: Term -> Term'
toScope :: VarIdent -> (VarIdent -> Term a) -> Term -> Scope Term a
toScopePattern :: Pattern -> (VarIdent -> Term a) -> Term -> Scope Term a
toTerm :: (VarIdent -> Term a) -> Term -> Term a
patternToTerm :: Pattern -> Term
unsafeTermToPattern :: Term -> Pattern
fromTerm' :: Term' -> Term
fromScope' :: VarIdent -> [VarIdent] -> [VarIdent] -> Scope Term VarIdent -> Term
fromTermWith' :: [VarIdent] -> [VarIdent] -> Term' -> Term
defaultVarIdents :: [VarIdent]

-- | Given a list of used variable names in the current context, generate a
--   unique fresh name based on a given one.
--   
--   <pre>
--   &gt;&gt;&gt; print $ refreshVar ["x", "y", "x₁", "z"] "x"
--   x₂
--   </pre>
refreshVar :: [VarIdent] -> VarIdent -> VarIdent
incVarIdentIndex :: VarIdent -> VarIdent

-- | Increment the subscript number at the end of the indentifier.
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ incIndex "x"
--   x₁
--   
--   &gt;&gt;&gt; putStrLn $ incIndex "x₁₉"
--   x₂₀
--   </pre>
incIndex :: String -> String
instance Data.Traversable.Traversable Language.Rzk.Free.Syntax.Type
instance Data.Foldable.Foldable Language.Rzk.Free.Syntax.Type
instance GHC.Base.Functor Language.Rzk.Free.Syntax.Type
instance GHC.Classes.Eq term => GHC.Classes.Eq (Language.Rzk.Free.Syntax.Type term)
instance Data.Traversable.Traversable Language.Rzk.Free.Syntax.TypeInfo
instance Data.Foldable.Foldable Language.Rzk.Free.Syntax.TypeInfo
instance GHC.Base.Functor Language.Rzk.Free.Syntax.TypeInfo
instance GHC.Classes.Eq term => GHC.Classes.Eq (Language.Rzk.Free.Syntax.TypeInfo term)
instance GHC.Show.Show Language.Rzk.Free.Syntax.TermT'
instance GHC.Show.Show Language.Rzk.Free.Syntax.Term'
instance Data.String.IsString Language.Rzk.Free.Syntax.Term'
instance Data.Bitraversable.Bitraversable Language.Rzk.Free.Syntax.TermF
instance Data.Bifoldable.Bifoldable Language.Rzk.Free.Syntax.TermF
instance Data.Bifunctor.Bifunctor Language.Rzk.Free.Syntax.TermF
instance Data.Traversable.Traversable (Language.Rzk.Free.Syntax.TermF scope)
instance Data.Foldable.Foldable (Language.Rzk.Free.Syntax.TermF scope)
instance GHC.Base.Functor (Language.Rzk.Free.Syntax.TermF scope)
instance (GHC.Classes.Eq scope, GHC.Classes.Eq term) => GHC.Classes.Eq (Language.Rzk.Free.Syntax.TermF scope term)
instance GHC.Show.Show Language.Rzk.Free.Syntax.VarIdent
instance GHC.Classes.Eq Language.Rzk.Free.Syntax.VarIdent
instance Data.String.IsString Language.Rzk.Free.Syntax.VarIdent

module Language.Rzk.VSCode.Config
data ServerConfig
ServerConfig :: Bool -> ServerConfig
[formatEnabled] :: ServerConfig -> Bool
instance GHC.Show.Show Language.Rzk.VSCode.Config.ServerConfig
instance Data.Default.Class.Default Language.Rzk.VSCode.Config.ServerConfig
instance Data.Aeson.Types.FromJSON.FromJSON Language.Rzk.VSCode.Config.ServerConfig
instance Data.Aeson.Types.ToJSON.ToJSON Language.Rzk.VSCode.Config.ServerConfig

module Language.Rzk.VSCode.Logging
logDebug :: MonadLsp c m => String -> m ()
logInfo :: MonadLsp c m => String -> m ()
logWarning :: MonadLsp c m => String -> m ()

-- | Error logs will also be shown to the user via `window/showMessage`
logError :: MonadLsp c m => String -> m ()

module Language.Rzk.VSCode.Tokenize
tokenizeModule :: Module -> [SemanticTokenAbsolute]
tokenizeLanguageDecl :: LanguageDecl -> [SemanticTokenAbsolute]
tokenizeCommand :: Command -> [SemanticTokenAbsolute]
tokenizeParam :: Param -> [SemanticTokenAbsolute]
tokenizePattern :: Pattern -> [SemanticTokenAbsolute]
tokenizeTope :: Term -> [SemanticTokenAbsolute]
tokenizeTerm :: Term -> [SemanticTokenAbsolute]
tokenizeTerm' :: Maybe SemanticTokenTypes -> Term -> [SemanticTokenAbsolute]
tokenizeRestriction :: Restriction -> [SemanticTokenAbsolute]
tokenizeParamDecl :: ParamDecl -> [SemanticTokenAbsolute]
mkToken :: (HasPosition a, Print a) => a -> SemanticTokenTypes -> [SemanticTokenModifiers] -> [SemanticTokenAbsolute]

module Rzk


-- | The formatter is designed in a way that can be consumed both by the
--   CLI and the LSP server.
module Rzk.Format

-- | All indices are 1-based (as received from the lexer) Note: LSP uses
--   0-based indices
data FormattingEdit
FormattingEdit :: Int -> Int -> Int -> Int -> String -> FormattingEdit
formatTextEdits :: String -> [FormattingEdit]

-- | Format Rzk code, returning the formatted version.
format :: String -> String

-- | Format Rzk code from a file
formatFile :: FilePath -> IO String

-- | Format the file and write the result back to the file.
formatFileWrite :: FilePath -> IO ()

-- | Check if the given Rzk source code is well formatted. This is useful
--   for automation tasks.
isWellFormatted :: String -> Bool

-- | Same as <a>isWellFormatted</a>, but reads the source code from a file.
isWellFormattedFile :: FilePath -> IO Bool
instance GHC.Show.Show Rzk.Format.FormattingEdit
instance GHC.Classes.Ord Rzk.Format.FormattingEdit
instance GHC.Classes.Eq Rzk.Format.FormattingEdit

module Rzk.Project.Config
data ProjectConfig
ProjectConfig :: [FilePath] -> [FilePath] -> ProjectConfig
[include] :: ProjectConfig -> [FilePath]
[exclude] :: ProjectConfig -> [FilePath]
instance GHC.Show.Show Rzk.Project.Config.ProjectConfig
instance GHC.Classes.Eq Rzk.Project.Config.ProjectConfig
instance Data.Aeson.Types.FromJSON.FromJSON Rzk.Project.Config.ProjectConfig

module Rzk.TypeCheck
defaultTypeCheck :: TypeCheck var a -> Either (TypeErrorInScopedContext var) a
data Decl var
Decl :: var -> TermT var -> Maybe (TermT var) -> Bool -> [var] -> Decl var
[declName] :: Decl var -> var
[declType] :: Decl var -> TermT var
[declValue] :: Decl var -> Maybe (TermT var)
[declIsAssumption] :: Decl var -> Bool
[declUsedVars] :: Decl var -> [var]
type Decl' = Decl VarIdent
typecheckModulesWithLocationIncremental :: [(FilePath, [Decl'])] -> [(FilePath, Module)] -> TypeCheck VarIdent ([(FilePath, [Decl'])], [TypeErrorInScopedContext VarIdent])
typecheckModulesWithLocation' :: [(FilePath, Module)] -> TypeCheck VarIdent ([(FilePath, [Decl'])], [TypeErrorInScopedContext VarIdent])
typecheckModulesWithLocation :: [(FilePath, Module)] -> TypeCheck VarIdent [(FilePath, [Decl'])]
typecheckModules :: [Module] -> TypeCheck VarIdent [Decl']
typecheckModuleWithLocation :: (FilePath, Module) -> TypeCheck VarIdent ([Decl'], [TypeErrorInScopedContext VarIdent])
countCommands :: Integral a => [Command] -> a
typecheckModule :: Maybe FilePath -> Module -> TypeCheck VarIdent ([Decl'], [TypeErrorInScopedContext VarIdent])
splitSectionCommands :: SectionName -> [Command] -> TypeCheck var ([Command], [Command])
setOption :: String -> String -> TypeCheck var a -> TypeCheck var a
unsetOption :: String -> TypeCheck var a -> TypeCheck var a
paramToParamDecl :: Param -> TypeCheck var [ParamDecl]
addParamDecls :: [ParamDecl] -> Term -> Term
addParams :: [Param] -> Term -> Term
data TypeError var
TypeErrorOther :: String -> TypeError var
TypeErrorUnify :: TermT var -> TermT var -> TermT var -> TypeError var
TypeErrorUnifyTerms :: TermT var -> TermT var -> TypeError var
TypeErrorNotPair :: TermT var -> TermT var -> TypeError var
TypeErrorNotFunction :: TermT var -> TermT var -> TypeError var
TypeErrorUnexpectedLambda :: Term var -> TermT var -> TypeError var
TypeErrorUnexpectedPair :: Term var -> TermT var -> TypeError var
TypeErrorUnexpectedRefl :: Term var -> TermT var -> TypeError var
TypeErrorCannotInferBareLambda :: Term var -> TypeError var
TypeErrorCannotInferBareRefl :: Term var -> TypeError var
TypeErrorUndefined :: var -> TypeError var
TypeErrorTopeNotSatisfied :: [TermT var] -> TermT var -> TypeError var
TypeErrorTopesNotEquivalent :: TermT var -> TermT var -> TypeError var
TypeErrorInvalidArgumentType :: Term var -> TermT var -> TypeError var
TypeErrorDuplicateTopLevel :: [VarIdent] -> VarIdent -> TypeError var
TypeErrorUnusedVariable :: var -> TermT var -> TypeError var
TypeErrorUnusedUsedVariables :: [var] -> var -> TypeError var
TypeErrorImplicitAssumption :: (var, TermT var) -> var -> TypeError var
data TypeErrorInContext var
TypeErrorInContext :: TypeError var -> Context var -> TypeErrorInContext var
[typeErrorError] :: TypeErrorInContext var -> TypeError var
[typeErrorContext] :: TypeErrorInContext var -> Context var
data TypeErrorInScopedContext var
PlainTypeError :: TypeErrorInContext var -> TypeErrorInScopedContext var
ScopedTypeError :: Maybe VarIdent -> TypeErrorInScopedContext (Inc var) -> TypeErrorInScopedContext var
type TypeError' = TypeError VarIdent
ppTypeError' :: TypeError' -> String
ppTypeErrorInContext :: OutputDirection -> TypeErrorInContext VarIdent -> String
ppTypeErrorInScopedContextWith' :: OutputDirection -> [VarIdent] -> [VarIdent] -> TypeErrorInScopedContext VarIdent -> String
ppTypeErrorInScopedContext' :: OutputDirection -> TypeErrorInScopedContext VarIdent -> String
issueWarning :: String -> TypeCheck var ()
issueTypeError :: TypeError var -> TypeCheck var a
panicImpossible :: String -> a
data Action var
ActionTypeCheck :: Term var -> TermT var -> Action var
ActionUnify :: TermT var -> TermT var -> TermT var -> Action var
ActionUnifyTerms :: TermT var -> TermT var -> Action var
ActionInfer :: Term var -> Action var
ActionContextEntailedBy :: [TermT var] -> TermT var -> Action var
ActionContextEntails :: [TermT var] -> TermT var -> Action var
ActionContextEquiv :: [TermT var] -> [TermT var] -> Action var
ActionWHNF :: TermT var -> Action var
ActionNF :: TermT var -> Action var
ActionCheckCoherence :: (TermT var, TermT var) -> (TermT var, TermT var) -> Action var
ActionCloseSection :: Maybe SectionName -> Action var
type Action' = Action VarIdent
ppTermInContext :: Eq var => TermT var -> TypeCheck var String
ppSomeAction :: Eq var => [(var, Maybe VarIdent)] -> Int -> Action var -> String
ppAction :: Int -> Action' -> String
traceAction' :: Int -> Action' -> a -> a
unsafeTraceAction' :: Int -> Action var -> a -> a
data LocationInfo
LocationInfo :: Maybe FilePath -> Maybe Int -> LocationInfo
[locationFilePath] :: LocationInfo -> Maybe FilePath
[locationLine] :: LocationInfo -> Maybe Int
data Verbosity
Debug :: Verbosity
Normal :: Verbosity
Silent :: Verbosity
trace' :: Verbosity -> Verbosity -> String -> a -> a
traceTypeCheck :: Verbosity -> String -> TypeCheck var a -> TypeCheck var a
localVerbosity :: Verbosity -> TypeCheck var a -> TypeCheck var a
localRenderBackend :: Maybe RenderBackend -> TypeCheck var a -> TypeCheck var a
data Covariance

-- | Positive position.
Covariant :: Covariance

-- | Negative position
Contravariant :: Covariance
data RenderBackend
RenderSVG :: RenderBackend
RenderLaTeX :: RenderBackend
data ScopeInfo var
ScopeInfo :: Maybe SectionName -> [(var, VarInfo var)] -> ScopeInfo var
[scopeName] :: ScopeInfo var -> Maybe SectionName
[scopeVars] :: ScopeInfo var -> [(var, VarInfo var)]
addVarToScope :: var -> VarInfo var -> ScopeInfo var -> ScopeInfo var
data VarInfo var
VarInfo :: TermT var -> Maybe (TermT var) -> Maybe VarIdent -> Bool -> [var] -> VarInfo var
[varType] :: VarInfo var -> TermT var
[varValue] :: VarInfo var -> Maybe (TermT var)
[varOrig] :: VarInfo var -> Maybe VarIdent
[varIsAssumption] :: VarInfo var -> Bool
[varDeclaredAssumptions] :: VarInfo var -> [var]
data Context var
Context :: [ScopeInfo var] -> [TermT var] -> [TermT var] -> [[TermT var]] -> Bool -> [Action var] -> Maybe Command -> Maybe LocationInfo -> Verbosity -> Covariance -> Maybe RenderBackend -> Context var
[localScopes] :: Context var -> [ScopeInfo var]
[localTopes] :: Context var -> [TermT var]
[localTopesNF] :: Context var -> [TermT var]
[localTopesNFUnion] :: Context var -> [[TermT var]]
[localTopesEntailBottom] :: Context var -> Bool
[actionStack] :: Context var -> [Action var]
[currentCommand] :: Context var -> Maybe Command
[location] :: Context var -> Maybe LocationInfo
[verbosity] :: Context var -> Verbosity
[covariance] :: Context var -> Covariance
[renderBackend] :: Context var -> Maybe RenderBackend
addVarInCurrentScope :: var -> VarInfo var -> Context var -> Context var
emptyContext :: Context var
askCurrentScope :: TypeCheck var (ScopeInfo var)
varInfos :: Context var -> [(var, VarInfo var)]
varTypes :: Context var -> [(var, TermT var)]
varValues :: Context var -> [(var, Maybe (TermT var))]
varOrigs :: Context var -> [(var, Maybe VarIdent)]
withPartialDecls :: TypeCheck VarIdent ([Decl'], [err]) -> TypeCheck VarIdent ([Decl'], [err]) -> TypeCheck VarIdent ([Decl'], [err])
withSection :: Maybe SectionName -> TypeCheck VarIdent ([Decl VarIdent], [TypeErrorInScopedContext VarIdent]) -> TypeCheck VarIdent ([Decl VarIdent], [TypeErrorInScopedContext VarIdent]) -> TypeCheck VarIdent ([Decl VarIdent], [TypeErrorInScopedContext VarIdent])
startSection :: Maybe SectionName -> TypeCheck VarIdent a -> TypeCheck VarIdent a
endSection :: [TypeErrorInScopedContext VarIdent] -> TypeCheck VarIdent [Decl']
scopeToDecls :: Eq var => [TypeErrorInScopedContext VarIdent] -> ScopeInfo var -> TypeCheck var [Decl var]
insertExplicitAssumptionFor :: Eq var => var -> (var, VarInfo var) -> TermT var -> TermT var
insertExplicitAssumptionFor' :: Eq var => var -> (var, VarInfo var) -> VarInfo var -> VarInfo var
makeAssumptionExplicit :: Eq var => (var, VarInfo var) -> [(var, VarInfo var)] -> TypeCheck var (Bool, [(var, VarInfo var)])
collectScopeDecls :: Eq var => [TypeErrorInScopedContext VarIdent] -> [(var, VarInfo var)] -> [(var, VarInfo var)] -> TypeCheck var [Decl var]
abstractAssumption :: Eq var => (var, VarInfo var) -> Decl var -> Decl var
data OutputDirection
TopDown :: OutputDirection
BottomUp :: OutputDirection
block :: OutputDirection -> [String] -> String
namedBlock :: OutputDirection -> String -> [String] -> String
ppContext' :: OutputDirection -> Context VarIdent -> String
doesShadowName :: VarIdent -> TypeCheck var [VarIdent]
checkTopLevelDuplicate :: VarIdent -> TypeCheck var ()
checkNameShadowing :: VarIdent -> TypeCheck var ()
withLocation :: LocationInfo -> TypeCheck var a -> TypeCheck var a
withCommand :: Command -> TypeCheck VarIdent ([Decl'], [TypeErrorInScopedContext VarIdent]) -> TypeCheck VarIdent ([Decl'], [TypeErrorInScopedContext VarIdent])
localDecls :: [Decl VarIdent] -> TypeCheck VarIdent a -> TypeCheck VarIdent a
localDeclsPrepared :: [Decl VarIdent] -> TypeCheck VarIdent a -> TypeCheck VarIdent a
localDecl :: Decl VarIdent -> TypeCheck VarIdent a -> TypeCheck VarIdent a
localDeclPrepared :: Decl VarIdent -> TypeCheck VarIdent a -> TypeCheck VarIdent a
type TypeCheck var = ReaderT (Context var) (Except (TypeErrorInScopedContext var))
freeVarsT_ :: Eq var => TermT var -> TypeCheck var [var]
traceStartAndFinish :: Show a => String -> a -> a
entail :: Eq var => [TermT var] -> TermT var -> Bool
entailM :: Eq var => [TermT var] -> TermT var -> TypeCheck var Bool
entailTraceM :: Eq var => [TermT var] -> TermT var -> TypeCheck var Bool
nubTermT :: Eq var => [TermT var] -> [TermT var]
saturateTopes :: Eq var => [TermT var] -> [TermT var] -> [TermT var]
saturateWith :: (a -> [a] -> Bool) -> ([a] -> [a] -> [a]) -> [a] -> [a]
generateTopes :: Eq var => [TermT var] -> [TermT var] -> [TermT var]
generateTopesForPoints :: Eq var => [TermT var] -> [TermT var]
generateTopesForPointsM :: Eq var => [TermT var] -> TypeCheck var [TermT var]
allTopePoints :: Eq var => TermT var -> [TermT var]
topePoints :: TermT var -> [TermT var]
subPoints :: TermT var -> [TermT var]

-- | Simplify the context, including disjunctions. See also
--   <a>simplifyLHS</a>.
simplifyLHSwithDisjunctions :: Eq var => [TermT var] -> [[TermT var]]

-- | Simplify the context, except disjunctions. See also
--   <a>simplifyLHSwithDisjunctions</a>.
simplifyLHS :: Eq var => [TermT var] -> [TermT var]
solveRHSM :: Eq var => [TermT var] -> TermT var -> TypeCheck var Bool
solveRHS :: Eq var => [TermT var] -> TermT var -> Bool
checkTope :: Eq var => TermT var -> TypeCheck var Bool
checkTopeEntails :: Eq var => TermT var -> TypeCheck var Bool
checkEntails :: Eq var => TermT var -> TermT var -> TypeCheck var Bool
contextEntailedBy :: Eq var => TermT var -> TypeCheck var ()
contextEntails :: Eq var => TermT var -> TypeCheck var ()
topesEquiv :: Eq var => TermT var -> TermT var -> TypeCheck var Bool
contextEquiv :: Eq var => [TermT var] -> TypeCheck var ()
switchVariance :: TypeCheck var a -> TypeCheck var a
enterScopeContext :: Maybe VarIdent -> TermT var -> Context var -> Context (Inc var)
enterScope :: Maybe VarIdent -> TermT var -> TypeCheck (Inc var) b -> TypeCheck var b
performing :: Eq var => Action var -> TypeCheck var a -> TypeCheck var a
stripTypeRestrictions :: TermT var -> TermT var

-- | Perform at most one &lt;math&gt;-expansion at the top-level to assist
--   unification.
etaMatch :: Eq var => Maybe (TermT var) -> TermT var -> TermT var -> TypeCheck var (TermT var, TermT var)
etaExpand :: Eq var => TermT var -> TypeCheck var (TermT var)
inCubeLayer :: Eq var => TermT var -> TypeCheck var Bool
inTopeLayer :: Eq var => TermT var -> TypeCheck var Bool
tryRestriction :: Eq var => TermT var -> TypeCheck var (Maybe (TermT var))

-- | Compute a typed term to its WHNF.
--   
--   <pre>
--   &gt;&gt;&gt; unsafeTypeCheck' $ whnfT "(\\ (x : Unit) -&gt; x) unit"
--   unit : Unit
--   </pre>
whnfT :: Eq var => TermT var -> TypeCheck var (TermT var)
nfTope :: Eq var => TermT var -> TypeCheck var (TermT var)

-- | Compute a typed term to its NF.
--   
--   <pre>
--   &gt;&gt;&gt; unsafeTypeCheck' $ nfT "(\\ (x : Unit) -&gt; x) unit"
--   unit : Unit
--   </pre>
nfT :: Eq var => TermT var -> TypeCheck var (TermT var)
checkDefinedVar :: Eq var => var -> TypeCheck var ()
valueOfVar :: Eq var => var -> TypeCheck var (Maybe (TermT var))
typeOfVar :: Eq var => var -> TypeCheck var (TermT var)
typeOfUncomputed :: Eq var => TermT var -> TypeCheck var (TermT var)
typeOf :: Eq var => TermT var -> TypeCheck var (TermT var)
unifyTopes :: Eq var => TermT var -> TermT var -> TypeCheck var ()
inAllSubContexts :: TypeCheck var () -> TypeCheck var () -> TypeCheck var ()
unify :: Eq var => Maybe (TermT var) -> TermT var -> TermT var -> TypeCheck var ()
unifyViaDecompose :: Eq var => TermT var -> TermT var -> TypeCheck var ()
unifyInCurrentContext :: Eq var => Maybe (TermT var) -> TermT var -> TermT var -> TypeCheck var ()
unifyTypes :: Eq var => TermT var -> TermT var -> TermT var -> TypeCheck var ()
unifyTerms :: Eq var => TermT var -> TermT var -> TypeCheck var ()
localTope :: Eq var => TermT var -> TypeCheck var a -> TypeCheck var a
universeT :: TermT var
cubeT :: TermT var
topeT :: TermT var
topeEQT :: TermT var -> TermT var -> TermT var
topeLEQT :: TermT var -> TermT var -> TermT var
topeOrT :: TermT var -> TermT var -> TermT var
topeAndT :: TermT var -> TermT var -> TermT var
cubeProductT :: TermT var -> TermT var -> TermT var
cubeUnitT :: TermT var
cubeUnitStarT :: TermT var
typeUnitT :: TermT var
unitT :: TermT var
cube2T :: TermT var
cube2_0T :: TermT var
cube2_1T :: TermT var
topeTopT :: TermT var
topeBottomT :: TermT var
recBottomT :: TermT var
typeRestrictedT :: TermT var -> [(TermT var, TermT var)] -> TermT var
lambdaT :: TermT var -> Maybe VarIdent -> Maybe (TermT var, Maybe (Scope TermT var)) -> Scope TermT var -> TermT var
appT :: TermT var -> TermT var -> TermT var -> TermT var
pairT :: TermT var -> TermT var -> TermT var -> TermT var
firstT :: TermT var -> TermT var -> TermT var
secondT :: TermT var -> TermT var -> TermT var
reflT :: TermT var -> Maybe (TermT var, Maybe (TermT var)) -> TermT var
typeFunT :: Maybe VarIdent -> TermT var -> Maybe (Scope TermT var) -> Scope TermT var -> TermT var
typeSigmaT :: Maybe VarIdent -> TermT var -> Scope TermT var -> TermT var
recOrT :: TermT var -> [(TermT var, TermT var)] -> TermT var
typeIdT :: TermT var -> Maybe (TermT var) -> TermT var -> TermT var
idJT :: TermT var -> TermT var -> TermT var -> TermT var -> TermT var -> TermT var -> TermT var -> TermT var
typeAscT :: TermT var -> TermT var -> TermT var
typecheck :: Eq var => Term var -> TermT var -> TypeCheck var (TermT var)
inferAs :: Eq var => TermT var -> Term var -> TypeCheck var (TermT var)
infer :: Eq var => Term var -> TypeCheck var (TermT var)
checkCoherence :: Eq var => (TermT var, TermT var) -> (TermT var, TermT var) -> TypeCheck var ()
inferStandalone :: Eq var => Term var -> Either (TypeErrorInScopedContext var) (TermT var)
unsafeInferStandalone' :: Term' -> TermT'
unsafeTypeCheck' :: TypeCheck VarIdent a -> a
type PointId = String
type ShapeId = [PointId]
cube2powerT :: Int -> TermT var
splits :: [a] -> [([a], [a])]
verticesFrom :: [TermT var] -> [(ShapeId, TermT var)]
subTopes2 :: Int -> TermT var -> [(ShapeId, TermT var)]
cubeSubTopes :: [(ShapeId, TermT (Inc var))]
limitLength :: Int -> String -> String
renderObjectsFor :: Eq var => String -> Int -> TermT var -> TermT var -> TypeCheck var [(ShapeId, RenderObjectData)]
componentWiseEQT :: Int -> TermT var -> TermT var -> TermT var
renderObjectsInSubShapeFor :: Eq var => String -> Int -> [var] -> var -> TermT var -> TermT var -> TermT var -> TypeCheck var [(ShapeId, RenderObjectData)]
renderForSubShapeSVG :: Eq var => String -> Int -> [var] -> var -> TermT var -> TermT var -> TermT var -> TypeCheck var String
renderForSVG :: Eq var => String -> Int -> TermT var -> TermT var -> TypeCheck var String
renderTermSVGFor :: Eq var => String -> Int -> (Maybe (TermT var, TermT var), [var]) -> TermT var -> TypeCheck var (Maybe String)
renderTermSVG :: Eq var => TermT var -> TypeCheck var (Maybe String)
renderTermSVG' :: Eq var => TermT var -> TypeCheck var (Maybe String)
type Point2D a = (a, a)
type Point3D a = (a, a, a)
type Edge3D a = (Point3D a, Point3D a)
type Face3D a = (Point3D a, Point3D a, Point3D a)
type Volume3D a = (Point3D a, Point3D a, Point3D a, Point3D a)
data CubeCoords2D a b
CubeCoords2D :: [(Point3D a, Point2D b)] -> [(Edge3D a, (Point2D b, Point2D b))] -> [(Face3D a, (Point2D b, Point2D b, Point2D b))] -> [(Volume3D a, (Point2D b, Point2D b, Point2D b, Point2D b))] -> CubeCoords2D a b
[vertices] :: CubeCoords2D a b -> [(Point3D a, Point2D b)]
[edges] :: CubeCoords2D a b -> [(Edge3D a, (Point2D b, Point2D b))]
[faces] :: CubeCoords2D a b -> [(Face3D a, (Point2D b, Point2D b, Point2D b))]
[volumes] :: CubeCoords2D a b -> [(Volume3D a, (Point2D b, Point2D b, Point2D b, Point2D b))]
data Matrix3D a
Matrix3D :: a -> a -> a -> a -> a -> a -> a -> a -> a -> Matrix3D a
data Matrix4D a
Matrix4D :: a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Matrix4D a
data Vector3D a
Vector3D :: a -> a -> a -> Vector3D a
data Vector4D a
Vector4D :: a -> a -> a -> a -> Vector4D a
rotateX :: Floating a => a -> Matrix3D a
rotateY :: Floating a => a -> Matrix3D a
rotateZ :: Floating a => a -> Matrix3D a
data Camera a
Camera :: Point3D a -> a -> a -> a -> a -> Camera a
[cameraPos] :: Camera a -> Point3D a
[cameraFoV] :: Camera a -> a
[cameraAspectRatio] :: Camera a -> a
[cameraAngleY] :: Camera a -> a
[cameraAngleX] :: Camera a -> a
viewRotateX :: Floating a => Camera a -> Matrix4D a
viewRotateY :: Floating a => Camera a -> Matrix4D a
viewTranslate :: Num a => Camera a -> Matrix4D a
project2D :: Floating a => Camera a -> Matrix4D a
matrixVectorMult4D :: Num a => Matrix4D a -> Vector4D a -> Vector4D a
matrix3Dto4D :: Num a => Matrix3D a -> Matrix4D a
fromAffine :: Fractional a => Vector4D a -> (Point2D a, a)
point3Dto2D :: Floating a => Camera a -> a -> Point3D a -> (Point2D a, a)
data RenderObjectData
RenderObjectData :: String -> String -> String -> RenderObjectData
[renderObjectDataLabel] :: RenderObjectData -> String
[renderObjectDataFullLabel] :: RenderObjectData -> String
[renderObjectDataColor] :: RenderObjectData -> String
renderCube :: (Floating a, Show a) => Camera a -> a -> (String -> Maybe RenderObjectData) -> String
defaultCamera :: Floating a => Camera a
instance GHC.Classes.Eq var => GHC.Classes.Eq (Rzk.TypeCheck.Decl var)
instance Data.Foldable.Foldable Rzk.TypeCheck.TypeError
instance GHC.Base.Functor Rzk.TypeCheck.TypeError
instance Data.Foldable.Foldable Rzk.TypeCheck.Action
instance GHC.Base.Functor Rzk.TypeCheck.Action
instance GHC.Classes.Ord Rzk.TypeCheck.Verbosity
instance GHC.Classes.Eq Rzk.TypeCheck.Verbosity
instance Data.Foldable.Foldable Rzk.TypeCheck.VarInfo
instance GHC.Base.Functor Rzk.TypeCheck.VarInfo
instance Data.Foldable.Foldable Rzk.TypeCheck.ScopeInfo
instance GHC.Base.Functor Rzk.TypeCheck.ScopeInfo
instance Data.Foldable.Foldable Rzk.TypeCheck.Context
instance GHC.Base.Functor Rzk.TypeCheck.Context
instance Data.Foldable.Foldable Rzk.TypeCheck.TypeErrorInContext
instance GHC.Base.Functor Rzk.TypeCheck.TypeErrorInContext
instance Data.Foldable.Foldable Rzk.TypeCheck.TypeErrorInScopedContext
instance GHC.Base.Functor Rzk.TypeCheck.TypeErrorInScopedContext
instance GHC.Classes.Eq Rzk.TypeCheck.OutputDirection
instance Data.String.IsString Language.Rzk.Free.Syntax.TermT'

module Rzk.Main
parseStdin :: IO Module

-- | Finds matches to the given pattern in the current working directory.
--   **NOTE:** throws exception when <a>glob</a> returns an empty list.
globNonEmpty :: FilePath -> IO [FilePath]
extractFilesFromRzkYaml :: FilePath -> IO [FilePath]

-- | Given a list of file paths (possibly including globs), expands the
--   globs (if any) or tries to read the list of files from the rzk.yaml
--   file (if no paths are given). Glob patterns in rzk.yaml are also
--   expanded.
expandRzkPathsOrYaml :: [FilePath] -> IO [FilePath]
parseRzkFilesOrStdin :: [FilePath] -> IO [(FilePath, Module)]
typecheckString :: String -> Either String String

module Language.Rzk.VSCode.Env
type RzkTypecheckCache = [(FilePath, [Decl'])]
data RzkEnv
RzkEnv :: TVar RzkTypecheckCache -> RzkEnv
[rzkEnvTypecheckCache] :: RzkEnv -> TVar RzkTypecheckCache
defaultRzkEnv :: IO RzkEnv
type LSP = LspT ServerConfig (ReaderT RzkEnv IO)

-- | Override the cache with given typechecked modules.
cacheTypecheckedModules :: RzkTypecheckCache -> LSP ()

-- | Completely invalidate the cache of typechecked files.
resetCacheForAllFiles :: LSP ()

-- | Invalidate the cache for a list of file paths.
resetCacheForFiles :: [FilePath] -> LSP ()

-- | Get the current state of the cache.
getCachedTypecheckedModules :: LSP RzkTypecheckCache

module Language.Rzk.VSCode.Handlers
typecheckFromConfigFile :: LSP ()
provideCompletions :: Handler LSP 'Method_TextDocumentCompletion
formatDocument :: Handler LSP 'Method_TextDocumentFormatting
provideSemanticTokens :: Handler LSP 'Method_TextDocumentSemanticTokensFull
handleFilesChanged :: Handler LSP 'Method_WorkspaceDidChangeWatchedFiles
instance Data.Default.Class.Default Data.Text.Internal.Text
instance Data.Default.Class.Default Language.LSP.Protocol.Internal.Types.CompletionItem.CompletionItem
instance Data.Default.Class.Default Language.LSP.Protocol.Internal.Types.CompletionItemLabelDetails.CompletionItemLabelDetails

module Language.Rzk.VSCode.Lsp

-- | The maximum number of diagnostic messages to send to the client
maxDiagnosticCount :: Int
handlers :: Handlers LSP
syncOptions :: TextDocumentSyncOptions
runLsp :: IO Int

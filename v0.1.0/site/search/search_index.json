{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"rzk \u2014 an experimental proof assistant for synthetic \u221e-categories rzk is an early prototype of a proof assistant for a family of type systems, including Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ). The assistant is polylingual, supporting several language modes. The language mode is specified in the first line of the source module code: #lang <mode> Currently the online assistant supports the following #lang modes: #lang rzk-1 ( try online ) \u2014 the early prototype of the proof assistant based on Riehl and Shulman's type theory for synthetic \u221e-categories. #lang sltc ( try online ) \u2014 a variant of simply typed lambda calculus (STLC) with computation available at the level of types; #lang pcf ( try online ) \u2014 programming with computable functions (PCF), an extension of simply typed lambda calculus with natural numbers and booleans; #lang mltt ( try online ) \u2014 Martin-L\u00f6f Type Theory, a dependent type theory with intensional identity types .","title":"About"},{"location":"#rzk-an-experimental-proof-assistant-for-synthetic-categories","text":"rzk is an early prototype of a proof assistant for a family of type systems, including Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ). The assistant is polylingual, supporting several language modes. The language mode is specified in the first line of the source module code: #lang <mode> Currently the online assistant supports the following #lang modes: #lang rzk-1 ( try online ) \u2014 the early prototype of the proof assistant based on Riehl and Shulman's type theory for synthetic \u221e-categories. #lang sltc ( try online ) \u2014 a variant of simply typed lambda calculus (STLC) with computation available at the level of types; #lang pcf ( try online ) \u2014 programming with computable functions (PCF), an extension of simply typed lambda calculus with natural numbers and booleans; #lang mltt ( try online ) \u2014 Martin-L\u00f6f Type Theory, a dependent type theory with intensional identity types .","title":"rzk \u2014 an experimental proof assistant for synthetic \u221e-categories"},{"location":"examples/hom/","text":"Hom-type hom : (A : U) -> (x : A) -> (y : A) -> U := \\A -> \\x -> \\y -> <{t : 2 | TOP} -> A [ t === 0_2 \\/ t === 1_2 |-> recOR(t === 0_2, t === 1_2, x, y) ]> RS17:Prop:3.5a : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A [BOT |-> recBOT]> := \\(A : U) -> \\(f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> \\{ts : 2 * 2 | TOP} -> recOR ((first ts) <= (second ts), (second ts) <= (first ts), f (second ts), f (first ts)) RS17:Prop:3.5b : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A [BOT |-> recBOT]> := \\(A : U) -> \\(f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> \\{ts : 2 * 2 | TOP} -> recOR ((first ts) <= (second ts), (second ts) <= (first ts), f (first ts), f (second ts)) isShapeRetraction : (I : CUBE) -> (A : U) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>) -> U := \\(I : CUBE) -> \\(A : U) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> \\(f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>) -> \u2211 (g : (k : <{t : I | phi t} -> A [BOT |-> recBOT]>) -> <{t : I | psi t} -> A [BOT |-> recBOT]>), (k : <{t : I | phi t} -> A [BOT |-> recBOT]>) -> f (g k) =_{<{t : I | phi t} -> A [BOT |-> recBOT]>} k shapeRetract : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> U := \\(I : CUBE) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> (A : U) -> \u2211 (f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>), isShapeRetraction I A phi psi f \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 \u0394\u00b2\u00d7\u0394\u00b9 : (t : 2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9 \u0394\u00b2-is-retract-of-\u0394\u00b9\u00d7\u0394\u00b9 : shapeRetract (2 * 2) \u0394\u00b2 \u0394\u00b9\u00d7\u0394\u00b9 := \\A -> (\\k -> \\ts -> k ts, (\\k -> \\(t, s) -> recOR(t <= s, s <= t, k (t, s), k (t, s)), \\k -> refl_{k})) \u0394\u00b3-is-retract-of-\u0394\u00b2\u00d7\u0394\u00b9 : shapeRetract (2 * 2 * 2) \u0394\u00b3 \u0394\u00b2\u00d7\u0394\u00b9 := \\A -> (\\k -> \\ts -> k ((first (first ts), second ts), second (first ts)), (\\k -> \\ts -> recOR((second ts) <= (second (first ts)), (second (first ts)) <= (second ts) /\\ (second ts) <= (first (first ts)) \\/ (first (first ts)) <= second ts, k ((first (first ts), second ts), second (first ts)), recOR((second (first ts)) <= (second ts) /\\ (second ts) <= (first (first ts)), (first (first ts)) <= second ts, k ((first (first ts), second ts), second (first ts)), k ((first (first ts), first (first ts)), second (first ts)))), \\k -> refl_{k}))","title":"Hom-type"},{"location":"examples/hom/#hom-type","text":"hom : (A : U) -> (x : A) -> (y : A) -> U := \\A -> \\x -> \\y -> <{t : 2 | TOP} -> A [ t === 0_2 \\/ t === 1_2 |-> recOR(t === 0_2, t === 1_2, x, y) ]> RS17:Prop:3.5a : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A [BOT |-> recBOT]> := \\(A : U) -> \\(f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> \\{ts : 2 * 2 | TOP} -> recOR ((first ts) <= (second ts), (second ts) <= (first ts), f (second ts), f (first ts)) RS17:Prop:3.5b : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A [BOT |-> recBOT]> := \\(A : U) -> \\(f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> \\{ts : 2 * 2 | TOP} -> recOR ((first ts) <= (second ts), (second ts) <= (first ts), f (first ts), f (second ts)) isShapeRetraction : (I : CUBE) -> (A : U) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>) -> U := \\(I : CUBE) -> \\(A : U) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> \\(f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>) -> \u2211 (g : (k : <{t : I | phi t} -> A [BOT |-> recBOT]>) -> <{t : I | psi t} -> A [BOT |-> recBOT]>), (k : <{t : I | phi t} -> A [BOT |-> recBOT]>) -> f (g k) =_{<{t : I | phi t} -> A [BOT |-> recBOT]>} k shapeRetract : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> U := \\(I : CUBE) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> (A : U) -> \u2211 (f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>), isShapeRetraction I A phi psi f \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 \u0394\u00b2\u00d7\u0394\u00b9 : (t : 2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9 \u0394\u00b2-is-retract-of-\u0394\u00b9\u00d7\u0394\u00b9 : shapeRetract (2 * 2) \u0394\u00b2 \u0394\u00b9\u00d7\u0394\u00b9 := \\A -> (\\k -> \\ts -> k ts, (\\k -> \\(t, s) -> recOR(t <= s, s <= t, k (t, s), k (t, s)), \\k -> refl_{k})) \u0394\u00b3-is-retract-of-\u0394\u00b2\u00d7\u0394\u00b9 : shapeRetract (2 * 2 * 2) \u0394\u00b3 \u0394\u00b2\u00d7\u0394\u00b9 := \\A -> (\\k -> \\ts -> k ((first (first ts), second ts), second (first ts)), (\\k -> \\ts -> recOR((second ts) <= (second (first ts)), (second (first ts)) <= (second ts) /\\ (second ts) <= (first (first ts)) \\/ (first (first ts)) <= second ts, k ((first (first ts), second ts), second (first ts)), recOR((second (first ts)) <= (second ts) /\\ (second ts) <= (first (first ts)), (first (first ts)) <= second ts, k ((first (first ts), second ts), second (first ts)), k ((first (first ts), first (first ts)), second (first ts)))), \\k -> refl_{k}))","title":"Hom-type"},{"location":"examples/section4/","text":"RS17, Section 4 prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f Theorem 4.1 RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>})))","title":"RS17, Section 4"},{"location":"examples/section4/#rs17-section-4","text":"prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f","title":"RS17, Section 4"},{"location":"examples/section4/#theorem-41","text":"RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>})))","title":"Theorem 4.1"},{"location":"examples/short/","text":"Short test (RS17, Theorem 4.1) prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <(t : I | psi t) -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <(t : I | phi t) -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <(t : I | psi t) -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <(t : I | phi t) -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>})))","title":"Short test (RS17, Theorem 4.1)"},{"location":"examples/short/#short-test-rs17-theorem-41","text":"prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <(t : I | psi t) -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <(t : I | phi t) -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <(t : I | psi t) -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <(t : I | phi t) -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>})))","title":"Short test (RS17, Theorem 4.1)"},{"location":"examples/test/","text":"Examples Here are some super basic examples of declarations embedded in Markdown file. Identity function: id : (A : U) -> (_ : A) -> A := \\(B : U) -> \\(x : B) -> x Church-encoded booleans with id used to make type look more complicated: false : (id U) ((A : U) -> (_x : A) -> (_y : A) -> A) := \\(F : U) -> \\(x : F) -> \\(_ : F) -> x true : (A : U) -> (_ : A) -> (_ : A) -> A := \\(C : U) -> \\(_ : C) -> \\(y : C) -> y Dependent sums: prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B pair : (A : U) -> U := \\(A : U) -> (prod A) A ex1 : pair ((A : U) -> U) := ( id U, (id ((B : U) -> U)) (id U) ) ex2 : (A : U) -> U := first ex1 ex3 : (A : U) -> U := second ex1 ex4 : U := \u2211 (A : U), pair A ex5 : ex4 := (U, (U, U)) ex6 : ex4 := ((B : U) -> (x : B) -> B, (id, id)) Identity types: iscontr : (A : U) -> U := \\(A : U) -> \u2211 (x : A), (y : A) -> x =_{A} y isaprop : (A : U) -> U := \\(A : U) -> (x : A) -> (y : A) -> x =_{A} y invpath : (A : U) -> (x : A) -> (y : A) -> (p : x =_{A} y) -> y =_{A} x := \\(A : U) -> \\(x : A) -> \\(y : A) -> \\(p : x =_{A} y) -> idJ(A, x, \\(z : A) -> \\(_ : x =_{A} z) -> z =_{A} x, refl_{x : A}, y, p) ex7 : (A : U) -> (x : A) -> refl_{x : A} =_{x =_{A} x} ((((invpath A) x) x) refl_{x : A}) := \\(A : U) -> \\(x : A) -> refl_{refl_{x : A} : x =_{A} x} Equivalence: isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f idweq : (A : U) -> (weq A) A := \\(A : U) -> ( id A , ( id A, ( \\(x : A) -> refl_{x : A}, \\(x : A) -> refl_{x : A} ) ) ) Cubes and topes: ex8 : CUBE := 1 ex9 : CUBE := 1 * 1 ex10 : (I : CUBE) -> (t : I * I) -> I * I := \\(I : CUBE) -> \\(t : I * I) -> (second t, first t) ex11 : (t : 1 * 1) -> TOPE := \\(t : 1 * 1) -> (second t) === (first t) Constraints: ex12 : (I : CUBE) -> <{t : I | BOT} -> U[BOT |-> recBOT]> := \\(I : CUBE) -> \\{t : I | BOT} -> recBOT ex13 : (I : CUBE) -> (A : U) -> <{t : I | BOT} -> A[BOT |-> recBOT]> := \\(I : CUBE) -> \\(A : U) -> \\{t : I | BOT} -> recBOT ex14 : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (A : U) -> (a : <{t : I | phi t \\/ psi t} -> A[BOT |-> recBOT]>) -> <{t : I | psi t \\/ phi t} -> A[BOT |-> recBOT]> := \\(I : CUBE) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> \\(A : U) -> \\(a : <{t : I | phi t \\/ psi t} -> A[BOT |-> recBOT]>) -> \\{t : I | phi t \\/ psi t} -> a t RS17, Section 4 Theorem 4.1 RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>}))) Here's a version that's a bit nicer to read, but is not supported at the moment: RS17:Thm:4_1 : (I : CUBE) -> (psi : I -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (Y : <{t : I | psi t} -> (x : X) -> U>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\ I psi phi Y f -> (g, (h, (\\_ -> refl, \\_ -> refl))) where g = \\k x t -> k t x h = \\k t x -> k x t Theorem 4.2 RS17:Thm:4_2a : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (chi : {s : J | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> (f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> weq (x : X) -> {t : I | psi t} -> phi : {t : I | psi t} -> TOPE t : I | psi |- phi <{t : I | psi t} -> A t [ phi t |-> a t ] > <{t : 2 | TOP} -> A [ t === 0 \\/ t === 1 |-> recOR (t === 0) (t === 1) a b ]> <{u : I | psi u} -> <{s : J | zeta s} -> X u s [chi s |-> f (u, s)]> [phi u |-> \\{s : J | zeta s} -> f (u, s)]> <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts) [ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts]> (f, (g, (fg, gf))) := \\(I : CUBE) -> \\(J : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(zeta : (s : J) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(chi : {s : J | zeta s} -> TOPE) -> \\(X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> \\(f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> ( \\(k : <{t : I | psi t} -> <{s : J | zeta s} -> (X t) s[ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) -> \\{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> k (first ts) (second ts) , (\\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> \\{t : I | psi t} -> \\{s : J | zeta s} -> k (t, s), (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>) -> refl_{k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>}, \\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> refl_{k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>}))) RS17:Thm:4_2a : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (chi : {s : J | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> (f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> weq <{t : I | psi t} -> <{s : J | zeta s} -> X t s [chi s |-> f (t, s)]> [phi t |-> \\{s : J | zeta s} -> f (t, s)]> <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts) [ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts]> := \\(I : CUBE) -> \\(J : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(zeta : (s : J) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(chi : {s : J | zeta s} -> TOPE) -> \\(X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> \\(f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> (X t) s[ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) -> \\{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> k (first ts) (second ts), (\\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> \\{t : I | psi t} -> \\{s : J | zeta s} -> k (t, s), (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>) -> refl_{k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>}, \\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> refl_{k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>}))) Theorem 4.3 RS17:Thm:4_3 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : <{t : I | psi t} -> U [BOT |-> recBOT]>) -> (Y : <{t : I | psi t} -> (x : X t) -> U [BOT |-> recBOT]>) -> (a : <{t : I | phi t} -> X t [BOT |-> recBOT]>) -> (b : <{t : I | phi t} -> Y t (a t) [BOT |-> recBOT]>) -> weq <{t : I | psi t} -> \u2211 (x : X t), Y t x [phi t |-> (a t, b t)]> (\u2211 (f : <{t : I | psi t} -> X t [phi t |-> a t]>), <{t : I | psi t} -> Y t (f t) [phi t |-> b t]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : <{t : I | psi t} -> U [BOT |-> recBOT]>) -> \\(Y : <{t : I | psi t} -> (x : X t) -> U [BOT |-> recBOT]>) -> \\(a : <{t : I | phi t} -> X t [BOT |-> recBOT]>) -> \\(b : <{t : I | phi t} -> Y t (a t) [BOT |-> recBOT]>) -> (\\(k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>) -> (\\{t : I | psi t} -> first (k t), \\{t : I | psi t} -> second (k t)), (\\(k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>) -> \\{t : I | psi t} -> ((first k) t, (second k) t), (\\(k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>) -> refl_{k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>}, \\(k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>) -> refl_{k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>}))) Theorem 4.4 Typechecking Markdown files You can typecheck this file directly: rzk typecheck examples/test.md The result should look something like this Everything is ok! Free variables and their known types: true : ( A : \ud835\udcb0 ) \u2192 ( _ : A ) \u2192 ( _\u2081 : A ) \u2192 A false : ( A : \ud835\udcb0 ) \u2192 ( _x : A ) \u2192 ( _y : A ) \u2192 A id : ( A : \ud835\udcb0 ) \u2192 ( _ : A ) \u2192 A Type holes and their instantiations: ?A\u2082 := _ ?(H)\u2083 := \ud835\udcb0 ?A\u2081 := _ ?(H)\u2082 := \ud835\udcb0 ?U\u2081 := \ud835\udcb0 ?(H)\u2081 := \ud835\udcb0","title":"Examples"},{"location":"examples/test/#examples","text":"Here are some super basic examples of declarations embedded in Markdown file. Identity function: id : (A : U) -> (_ : A) -> A := \\(B : U) -> \\(x : B) -> x Church-encoded booleans with id used to make type look more complicated: false : (id U) ((A : U) -> (_x : A) -> (_y : A) -> A) := \\(F : U) -> \\(x : F) -> \\(_ : F) -> x true : (A : U) -> (_ : A) -> (_ : A) -> A := \\(C : U) -> \\(_ : C) -> \\(y : C) -> y Dependent sums: prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B pair : (A : U) -> U := \\(A : U) -> (prod A) A ex1 : pair ((A : U) -> U) := ( id U, (id ((B : U) -> U)) (id U) ) ex2 : (A : U) -> U := first ex1 ex3 : (A : U) -> U := second ex1 ex4 : U := \u2211 (A : U), pair A ex5 : ex4 := (U, (U, U)) ex6 : ex4 := ((B : U) -> (x : B) -> B, (id, id)) Identity types: iscontr : (A : U) -> U := \\(A : U) -> \u2211 (x : A), (y : A) -> x =_{A} y isaprop : (A : U) -> U := \\(A : U) -> (x : A) -> (y : A) -> x =_{A} y invpath : (A : U) -> (x : A) -> (y : A) -> (p : x =_{A} y) -> y =_{A} x := \\(A : U) -> \\(x : A) -> \\(y : A) -> \\(p : x =_{A} y) -> idJ(A, x, \\(z : A) -> \\(_ : x =_{A} z) -> z =_{A} x, refl_{x : A}, y, p) ex7 : (A : U) -> (x : A) -> refl_{x : A} =_{x =_{A} x} ((((invpath A) x) x) refl_{x : A}) := \\(A : U) -> \\(x : A) -> refl_{refl_{x : A} : x =_{A} x} Equivalence: isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f idweq : (A : U) -> (weq A) A := \\(A : U) -> ( id A , ( id A, ( \\(x : A) -> refl_{x : A}, \\(x : A) -> refl_{x : A} ) ) ) Cubes and topes: ex8 : CUBE := 1 ex9 : CUBE := 1 * 1 ex10 : (I : CUBE) -> (t : I * I) -> I * I := \\(I : CUBE) -> \\(t : I * I) -> (second t, first t) ex11 : (t : 1 * 1) -> TOPE := \\(t : 1 * 1) -> (second t) === (first t) Constraints: ex12 : (I : CUBE) -> <{t : I | BOT} -> U[BOT |-> recBOT]> := \\(I : CUBE) -> \\{t : I | BOT} -> recBOT ex13 : (I : CUBE) -> (A : U) -> <{t : I | BOT} -> A[BOT |-> recBOT]> := \\(I : CUBE) -> \\(A : U) -> \\{t : I | BOT} -> recBOT ex14 : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (A : U) -> (a : <{t : I | phi t \\/ psi t} -> A[BOT |-> recBOT]>) -> <{t : I | psi t \\/ phi t} -> A[BOT |-> recBOT]> := \\(I : CUBE) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> \\(A : U) -> \\(a : <{t : I | phi t \\/ psi t} -> A[BOT |-> recBOT]>) -> \\{t : I | phi t \\/ psi t} -> a t","title":"Examples"},{"location":"examples/test/#rs17-section-4","text":"","title":"RS17, Section 4"},{"location":"examples/test/#theorem-41","text":"RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>}))) Here's a version that's a bit nicer to read, but is not supported at the moment: RS17:Thm:4_1 : (I : CUBE) -> (psi : I -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (Y : <{t : I | psi t} -> (x : X) -> U>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\ I psi phi Y f -> (g, (h, (\\_ -> refl, \\_ -> refl))) where g = \\k x t -> k t x h = \\k t x -> k x t","title":"Theorem 4.1"},{"location":"examples/test/#theorem-42","text":"RS17:Thm:4_2a : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (chi : {s : J | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> (f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> weq (x : X) -> {t : I | psi t} -> phi : {t : I | psi t} -> TOPE t : I | psi |- phi <{t : I | psi t} -> A t [ phi t |-> a t ] > <{t : 2 | TOP} -> A [ t === 0 \\/ t === 1 |-> recOR (t === 0) (t === 1) a b ]> <{u : I | psi u} -> <{s : J | zeta s} -> X u s [chi s |-> f (u, s)]> [phi u |-> \\{s : J | zeta s} -> f (u, s)]> <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts) [ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts]> (f, (g, (fg, gf))) := \\(I : CUBE) -> \\(J : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(zeta : (s : J) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(chi : {s : J | zeta s} -> TOPE) -> \\(X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> \\(f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> ( \\(k : <{t : I | psi t} -> <{s : J | zeta s} -> (X t) s[ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) -> \\{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> k (first ts) (second ts) , (\\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> \\{t : I | psi t} -> \\{s : J | zeta s} -> k (t, s), (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>) -> refl_{k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>}, \\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> refl_{k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>}))) RS17:Thm:4_2a : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (chi : {s : J | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> (f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> weq <{t : I | psi t} -> <{s : J | zeta s} -> X t s [chi s |-> f (t, s)]> [phi t |-> \\{s : J | zeta s} -> f (t, s)]> <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts) [ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts]> := \\(I : CUBE) -> \\(J : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(zeta : (s : J) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(chi : {s : J | zeta s} -> TOPE) -> \\(X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> \\(f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> (X t) s[ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) -> \\{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> k (first ts) (second ts), (\\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> \\{t : I | psi t} -> \\{s : J | zeta s} -> k (t, s), (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>) -> refl_{k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>}, \\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> refl_{k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>})))","title":"Theorem 4.2"},{"location":"examples/test/#theorem-43","text":"RS17:Thm:4_3 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : <{t : I | psi t} -> U [BOT |-> recBOT]>) -> (Y : <{t : I | psi t} -> (x : X t) -> U [BOT |-> recBOT]>) -> (a : <{t : I | phi t} -> X t [BOT |-> recBOT]>) -> (b : <{t : I | phi t} -> Y t (a t) [BOT |-> recBOT]>) -> weq <{t : I | psi t} -> \u2211 (x : X t), Y t x [phi t |-> (a t, b t)]> (\u2211 (f : <{t : I | psi t} -> X t [phi t |-> a t]>), <{t : I | psi t} -> Y t (f t) [phi t |-> b t]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : <{t : I | psi t} -> U [BOT |-> recBOT]>) -> \\(Y : <{t : I | psi t} -> (x : X t) -> U [BOT |-> recBOT]>) -> \\(a : <{t : I | phi t} -> X t [BOT |-> recBOT]>) -> \\(b : <{t : I | phi t} -> Y t (a t) [BOT |-> recBOT]>) -> (\\(k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>) -> (\\{t : I | psi t} -> first (k t), \\{t : I | psi t} -> second (k t)), (\\(k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>) -> \\{t : I | psi t} -> ((first k) t, (second k) t), (\\(k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>) -> refl_{k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>}, \\(k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>) -> refl_{k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>})))","title":"Theorem 4.3"},{"location":"examples/test/#theorem-44","text":"","title":"Theorem 4.4"},{"location":"examples/test/#typechecking-markdown-files","text":"You can typecheck this file directly: rzk typecheck examples/test.md The result should look something like this Everything is ok! Free variables and their known types: true : ( A : \ud835\udcb0 ) \u2192 ( _ : A ) \u2192 ( _\u2081 : A ) \u2192 A false : ( A : \ud835\udcb0 ) \u2192 ( _x : A ) \u2192 ( _y : A ) \u2192 A id : ( A : \ud835\udcb0 ) \u2192 ( _ : A ) \u2192 A Type holes and their instantiations: ?A\u2082 := _ ?(H)\u2083 := \ud835\udcb0 ?A\u2081 := _ ?(H)\u2082 := \ud835\udcb0 ?U\u2081 := \ud835\udcb0 ?(H)\u2081 := \ud835\udcb0","title":"Typechecking Markdown files"},{"location":"other/mltt/","text":"","title":"MLTT"},{"location":"other/pcf/","text":"","title":"PCF"},{"location":"other/stlc/","text":"","title":"STLC"},{"location":"tts/RS17/","text":"Formalizing proofs from 2017 paper by Riehl and Shulman Here we present and explain formalization of definitions, propositions, and proofs from Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ). Simplicial Type Theory This follows definitions and proofs from RS17, Section 3. Simplicies and their subshapes First, we define n-simplices for small n: #def \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP #def \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t #def \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Next, we define boundaries of n-simplices: #def \u2202\u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> 0_2 === t \\/ 1_2 === t #def \u2202\u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> (0_2 === s /\\ s <= t) \\/ (s === t) \\/ (s <= t /\\ t === 1_2) Connection Squares (Proposition 3.5) #def V : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A[BOT |-> recBOT]> := \\A -> \\f -> \\(t, s) -> recOR(t <= s, s <= t, f s, f t) #def \u039b : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A[BOT |-> recBOT]> := \\A -> \\f -> \\(t, s) -> recOR(t <= s, s <= t, f t, f s) Shape products For Propositions 3.6 and 3.7, we need to introduce product shapes. First, let's define product of two topes in general: #def shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s Now, we can define the shapes used in Propositions 3.6 and 3.7: #def \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 \u0394\u00b2\u00d7\u0394\u00b9 : (t : 2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9 RS17, Section 4 Prerequisites prod : (A : U) -> (B : U) -> U := \\A -> \\B -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\A -> \\B -> \\f -> \u2211 (g : (_ : B) -> A), prod ((x : A) -> g (f x) =_{A} x) ((y : B) -> f (g y) =_{B} y) weq : (A : U) -> (B : U) -> U := \\A -> \\B -> \u2211 (f : (_ : A) -> B), isweq A B f Theorem 4.1 (commutation of Pi and extension types) Theorem-4.1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U >) -> (f : <{t : I | phi t} -> (x : X) -> Y t x >) -> weq <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]> ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\I -> \\psi -> \\phi -> \\X -> \\Y -> \\f -> (\\k -> \\x -> \\t -> k t x, (\\k -> \\{t : I | psi t} -> \\x -> (k x) t, (\\k -> refl_{k}, \\k -> refl_{k}))) Theorem 4.2 (currying and commutation of arguments for extension types) uncurry_ext : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U> >) -> (chi : {(t : I) | psi t} -> TOPE) -> (phi : {(s : J) | zeta s} -> TOPE) -> (f : <{(t, s) : I * J | psi t /\\ zeta s} -> X t s >) -> (_ : <{t : I | psi t} -> <{s : J | zeta s} -> X t s [chi s |-> f (t, s)]> [phi t |-> \\s -> f (t, s)]>) -> <{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t, s)]> := \\I -> \\J -> \\psi -> \\zeta -> \\X -> \\chi -> \\phi -> \\f -> \\k -> \\(t, s) -> k t s","title":"Formalising RS17"},{"location":"tts/RS17/#formalizing-proofs-from-2017-paper-by-riehl-and-shulman","text":"Here we present and explain formalization of definitions, propositions, and proofs from Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ).","title":"Formalizing proofs from 2017 paper by Riehl and Shulman"},{"location":"tts/RS17/#simplicial-type-theory","text":"This follows definitions and proofs from RS17, Section 3.","title":"Simplicial Type Theory"},{"location":"tts/RS17/#simplicies-and-their-subshapes","text":"First, we define n-simplices for small n: #def \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP #def \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t #def \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Next, we define boundaries of n-simplices: #def \u2202\u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> 0_2 === t \\/ 1_2 === t #def \u2202\u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> (0_2 === s /\\ s <= t) \\/ (s === t) \\/ (s <= t /\\ t === 1_2)","title":"Simplicies and their subshapes"},{"location":"tts/RS17/#connection-squares-proposition-35","text":"#def V : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A[BOT |-> recBOT]> := \\A -> \\f -> \\(t, s) -> recOR(t <= s, s <= t, f s, f t) #def \u039b : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A[BOT |-> recBOT]> := \\A -> \\f -> \\(t, s) -> recOR(t <= s, s <= t, f t, f s)","title":"Connection Squares (Proposition 3.5)"},{"location":"tts/RS17/#shape-products","text":"For Propositions 3.6 and 3.7, we need to introduce product shapes. First, let's define product of two topes in general: #def shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s Now, we can define the shapes used in Propositions 3.6 and 3.7: #def \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 \u0394\u00b2\u00d7\u0394\u00b9 : (t : 2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9","title":"Shape products"},{"location":"tts/RS17/#rs17-section-4","text":"","title":"RS17, Section 4"},{"location":"tts/RS17/#prerequisites","text":"prod : (A : U) -> (B : U) -> U := \\A -> \\B -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\A -> \\B -> \\f -> \u2211 (g : (_ : B) -> A), prod ((x : A) -> g (f x) =_{A} x) ((y : B) -> f (g y) =_{B} y) weq : (A : U) -> (B : U) -> U := \\A -> \\B -> \u2211 (f : (_ : A) -> B), isweq A B f","title":"Prerequisites"},{"location":"tts/RS17/#theorem-41-commutation-of-pi-and-extension-types","text":"Theorem-4.1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {(t : I) | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U >) -> (f : <{t : I | phi t} -> (x : X) -> Y t x >) -> weq <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]> ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\I -> \\psi -> \\phi -> \\X -> \\Y -> \\f -> (\\k -> \\x -> \\t -> k t x, (\\k -> \\{t : I | psi t} -> \\x -> (k x) t, (\\k -> refl_{k}, \\k -> refl_{k})))","title":"Theorem 4.1 (commutation of Pi and extension types)"},{"location":"tts/RS17/#theorem-42-currying-and-commutation-of-arguments-for-extension-types","text":"uncurry_ext : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U> >) -> (chi : {(t : I) | psi t} -> TOPE) -> (phi : {(s : J) | zeta s} -> TOPE) -> (f : <{(t, s) : I * J | psi t /\\ zeta s} -> X t s >) -> (_ : <{t : I | psi t} -> <{s : J | zeta s} -> X t s [chi s |-> f (t, s)]> [phi t |-> \\s -> f (t, s)]>) -> <{(t, s) : I * J | psi t /\\ zeta s} -> X t s [(phi t /\\ zeta s) \\/ (psi t /\\ chi s) |-> f (t, s)]> := \\I -> \\J -> \\psi -> \\zeta -> \\X -> \\chi -> \\phi -> \\f -> \\k -> \\(t, s) -> k t s","title":"Theorem 4.2 (currying and commutation of arguments for extension types)"},{"location":"tts/examples/","text":"","title":"Examples"},{"location":"tts/introduction/","text":"Introduction to rzk-1 rzk-1 is the early version of a proof assistant for synthetic \u221e-categories. It is based very closely on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ). We will refer to Riehl and Shulman's Type Theory as RSTT. In this section, we introduce syntax, discuss features and some of the current limitations of the proof assistant. Overall, a program in rzk-1 consists of a language pragma (specifying that we use rzk-1 and not one of the other languages) followed by a sequence of commands. Right now, only #def command is supported for rzk-1 (other languages support commands like #infer , #whnf , #typecheck ). Here is a small formalisation in an MLTT subset of rzk-1 : #lang rzk-1 -- Flipping the arguments of a function. #def flip : (A : U) -> -- For any types A (B : U) -> -- and B (f : (x : A) -> (y : B) -> A) -> -- given a function f : A -> B -> A ((x : B) -> (y : A) -> A) -- we construct a function of type B -> A -> A := \\A -> \\B -> \\f -> \\y -> \\x -> f x y -- by swapping the arguments -- Flipping a function twice is the same as not doing anything #def flip-flip-is-id : (A : U) -> -- For any types A (B : U) -> -- and B (f : (x : A) -> (y : B) -> A) -> -- given a function f : A -> B -> A flip A B (flip A B f) -- flip (flip f) =_{(x : A) -> (y : B) -> A} -- is identical f -- to f := \\A -> \\B -> \\f -> refl_{f} -- proof by reflexivity Let us explain parts of this code: #lang rzk-1 specifies that we are in using rzk-1 language; -- starts a comment line (until the end of the line); #def <name> : <type> := <term> defines a name <name> to be equal to <term> ; the proof assistant will typecheck <term> against type <type> ; We define two terms here \u2014 flip and flip-flip-is-id ; flip is a function that takes 3 arguments and returns a function of two arguments. flip-flip-is-id is a function that takes two types and a function f and returns a value of an identity type flip B A (flip A B f) =_{...} f , indicating that flipping a function f twice gets us back to f . Syntax Similarly to the three layers in RSTT, rzk-1 has 3 universes: CUBE is the universe of cubes, corresponding to the cube layer; TOPE is the universe of topes, corresponding to the tope layer; U (also written as \ud835\udcb0 ) is the universe of types, corresponding to the types and terms layer. Cube layer All cubes live in CUBE universe. There are two built-in cubes: 1 cube (also written as \ud835\udfd9 ) is a unit cube with a single point *_1 (or \u22c6 ) 2 cube (also written as \ud835\udfda ) is a directed interval cube with points 0_2 and 1_2 It is also possible to have CUBE variables and make products of cubes: I * J (also written as I \u00d7 J ) is a product of cubes I and J (t, s) is a point in I * J if t : I and s : J if ts : I * J , then first ts : I (or \u03c0\u2081 ts : I ) and second ts : J (or \u03c0\u2082 ts : J ) You can usually use (t, s) both as a pattern, and a construction of a pair of points: -- Swap point components of a point in a cube I \u00d7 I #def swap : (I : CUBE) -> (ts : I * I) -> I * I := \\I -> \\(t, s) -> (s, t) Tope layer All topes live in TOPE universe. Here are all the ways to build a tope: Introduce a variable, e.g. (psi : TOPE) -> ... ; Usually, topes depend on point variables from some cube(s). To indicate that, we usually introduce topes as \"functions\" from some cube to TOPE . For example, (psi : (t : I) -> TOPE) -> ... . Use a constant: top tope \\top is written TOP or \u22a4 ; bottom tope \\bot is written BOT or \u22a5 ; tope conjunction \\psi \\land \\phi is written psi /\\ phi or psi \u2227 phi ; tope disjunction \\psi \\lor \\phi is written psi \\/ phi or psi \u2228 phi ; equality tope t \\equiv s is written t === s or t \u2261 s , whenever t and s are points of the same cube; inequality tope t \\leq s is written t <= s or t \u2264 s whenever t : 2 and s : 2 . Types and terms Function (dependent product) types \\prod_{x : A} B are written (x : A) -> B or (x : A) \u2192 B specifying the name of the argument is mandatory; i.e. A -> B is invalid syntax! values of function types are \\lambda -abstractions written in one of the following ways: \\x -> <body> or \u03bbx -> <body> \u2014 this is usually fine; \\(x : A) -> <body> or \u03bb(x : A) -> <body> \u2014 this sometimes helps the typechecker; Dependent sum type \\sum_{x : A} B is written \u2211 (x : A), B or Sigma (x : A), B specifying the name of the argument is mandatory; i.e. \u2211 A, B is invalid syntax! values of dependent sum types are pairs written as (x, y) ; to access components of a dependent pair p , use first p (or \u03c0\u2081 p ) and second p (or \u03c0\u2082 p ); first (or \u03c0\u2081 ) and second (or \u03c0\u2082 ) are not valid syntax without an argument! Identity (path) type x =_A y is written x =_{A} y specifying the type A is mandatory; i.e. x = y is invalid syntax! the only value of an identity type is refl_{x} whose type is x =_{A} x whenever x : A path induction is done using J path eliminator; for any type A and a : A , type family C : \\prod_{x : A} ((a =_A x) \\to \\mathcal{U}) and d : C(a,\\mathsf{refl}_a) and x : A and p : a =_A x we have \\mathcal{J}(A, a, C, d, x, p) : C(x, p) ; in rzk-1 we write idJ(A, a, C, d, x, p) ; idJ is not valid syntax without exactly 6-tuple provided as an argument! Extension types \\left\\langle \\prod_{t : I \\mid \\psi} A \\vert ^{\\phi} _{a} \\right\\rangle are written as <{t : I | psi} -> A [ phi |-> a ]> specifying [ phi |-> a ] is optional, defaults to [ BOT |-> recBOT ] (like in RSTT); specifying psi in {t : I | psi} is mandatory; values of function types are \\lambda -abstractions written in one of the following ways: \\t -> <body> or \u03bbt \u2192 <body> \u2014 this is usually fine; \\{t : I | psi} -> <body> or \u03bb{t : I | psi} -> <body> \u2014 this sometimes helps the typechecker; Types of functions from a shape \\prod_{t : I \\mid \\psi} A are a specialised variant of extension types and are written {t : I | psi} -> A specifying the name of the argument is mandatory; i.e. {I | psi} -> A is invalid syntax! values of function types are \\lambda -abstractions written in one of the following ways: \\t -> <body> or \u03bbt \u2192 <body> \u2014 this is usually fine; \\{t : I | psi} -> <body> or \u03bb{t : I | psi} -> <body> \u2014 this sometimes helps the typechecker; Tope disjuction elimination Following RSTT, rzk-1 introduces two primitive terms for disjunction elimination: recBOT (also written rec\u22a5 ) corresponds to \\mathsf{rec}_\\bot , has any type, and is valid whenever tope context is included in BOT ; recOR(psi, phi, a_psi, a_phi) (also written rec\u2228(psi, phi, a_psi, a_phi) ) corresponds to \\mathsf{rec}_\\lor^{\\psi, \\phi}(a_\\psi, a_\\phi) , is well-typed when a_psi is definitionally equal to a_phi under psi /\\ phi . Soundness First of all, in rzk-1 we have \"type-in-type\", that is U has type U . This is known to make the type system unsound, however, it is usually considered acceptable in proof assistants. And, since it simplifies implementation, rzk-1 follows this convention. Additionally, unlike RSTT, rzk-1 does not prevent cubes or topes to depend on types and terms. For example, the following definition typechecks: #def weird : (A : U) -> (I : (x : A) -> CUBE) -> (x : A) -> (y : A) -> CUBE := \\A -> \\I -> \\x -> \\y -> I x * I y This likely leads to another inconsistency, but it will hardly lead to bugs in actual proofs of interest, so current version embraces this treatment of universes.","title":"Introduction"},{"location":"tts/introduction/#introduction-to-rzk-1","text":"rzk-1 is the early version of a proof assistant for synthetic \u221e-categories. It is based very closely on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ). We will refer to Riehl and Shulman's Type Theory as RSTT. In this section, we introduce syntax, discuss features and some of the current limitations of the proof assistant. Overall, a program in rzk-1 consists of a language pragma (specifying that we use rzk-1 and not one of the other languages) followed by a sequence of commands. Right now, only #def command is supported for rzk-1 (other languages support commands like #infer , #whnf , #typecheck ). Here is a small formalisation in an MLTT subset of rzk-1 : #lang rzk-1 -- Flipping the arguments of a function. #def flip : (A : U) -> -- For any types A (B : U) -> -- and B (f : (x : A) -> (y : B) -> A) -> -- given a function f : A -> B -> A ((x : B) -> (y : A) -> A) -- we construct a function of type B -> A -> A := \\A -> \\B -> \\f -> \\y -> \\x -> f x y -- by swapping the arguments -- Flipping a function twice is the same as not doing anything #def flip-flip-is-id : (A : U) -> -- For any types A (B : U) -> -- and B (f : (x : A) -> (y : B) -> A) -> -- given a function f : A -> B -> A flip A B (flip A B f) -- flip (flip f) =_{(x : A) -> (y : B) -> A} -- is identical f -- to f := \\A -> \\B -> \\f -> refl_{f} -- proof by reflexivity Let us explain parts of this code: #lang rzk-1 specifies that we are in using rzk-1 language; -- starts a comment line (until the end of the line); #def <name> : <type> := <term> defines a name <name> to be equal to <term> ; the proof assistant will typecheck <term> against type <type> ; We define two terms here \u2014 flip and flip-flip-is-id ; flip is a function that takes 3 arguments and returns a function of two arguments. flip-flip-is-id is a function that takes two types and a function f and returns a value of an identity type flip B A (flip A B f) =_{...} f , indicating that flipping a function f twice gets us back to f .","title":"Introduction to rzk-1"},{"location":"tts/introduction/#syntax","text":"Similarly to the three layers in RSTT, rzk-1 has 3 universes: CUBE is the universe of cubes, corresponding to the cube layer; TOPE is the universe of topes, corresponding to the tope layer; U (also written as \ud835\udcb0 ) is the universe of types, corresponding to the types and terms layer.","title":"Syntax"},{"location":"tts/introduction/#cube-layer","text":"All cubes live in CUBE universe. There are two built-in cubes: 1 cube (also written as \ud835\udfd9 ) is a unit cube with a single point *_1 (or \u22c6 ) 2 cube (also written as \ud835\udfda ) is a directed interval cube with points 0_2 and 1_2 It is also possible to have CUBE variables and make products of cubes: I * J (also written as I \u00d7 J ) is a product of cubes I and J (t, s) is a point in I * J if t : I and s : J if ts : I * J , then first ts : I (or \u03c0\u2081 ts : I ) and second ts : J (or \u03c0\u2082 ts : J ) You can usually use (t, s) both as a pattern, and a construction of a pair of points: -- Swap point components of a point in a cube I \u00d7 I #def swap : (I : CUBE) -> (ts : I * I) -> I * I := \\I -> \\(t, s) -> (s, t)","title":"Cube layer"},{"location":"tts/introduction/#tope-layer","text":"All topes live in TOPE universe. Here are all the ways to build a tope: Introduce a variable, e.g. (psi : TOPE) -> ... ; Usually, topes depend on point variables from some cube(s). To indicate that, we usually introduce topes as \"functions\" from some cube to TOPE . For example, (psi : (t : I) -> TOPE) -> ... . Use a constant: top tope \\top is written TOP or \u22a4 ; bottom tope \\bot is written BOT or \u22a5 ; tope conjunction \\psi \\land \\phi is written psi /\\ phi or psi \u2227 phi ; tope disjunction \\psi \\lor \\phi is written psi \\/ phi or psi \u2228 phi ; equality tope t \\equiv s is written t === s or t \u2261 s , whenever t and s are points of the same cube; inequality tope t \\leq s is written t <= s or t \u2264 s whenever t : 2 and s : 2 .","title":"Tope layer"},{"location":"tts/introduction/#types-and-terms","text":"Function (dependent product) types \\prod_{x : A} B are written (x : A) -> B or (x : A) \u2192 B specifying the name of the argument is mandatory; i.e. A -> B is invalid syntax! values of function types are \\lambda -abstractions written in one of the following ways: \\x -> <body> or \u03bbx -> <body> \u2014 this is usually fine; \\(x : A) -> <body> or \u03bb(x : A) -> <body> \u2014 this sometimes helps the typechecker; Dependent sum type \\sum_{x : A} B is written \u2211 (x : A), B or Sigma (x : A), B specifying the name of the argument is mandatory; i.e. \u2211 A, B is invalid syntax! values of dependent sum types are pairs written as (x, y) ; to access components of a dependent pair p , use first p (or \u03c0\u2081 p ) and second p (or \u03c0\u2082 p ); first (or \u03c0\u2081 ) and second (or \u03c0\u2082 ) are not valid syntax without an argument! Identity (path) type x =_A y is written x =_{A} y specifying the type A is mandatory; i.e. x = y is invalid syntax! the only value of an identity type is refl_{x} whose type is x =_{A} x whenever x : A path induction is done using J path eliminator; for any type A and a : A , type family C : \\prod_{x : A} ((a =_A x) \\to \\mathcal{U}) and d : C(a,\\mathsf{refl}_a) and x : A and p : a =_A x we have \\mathcal{J}(A, a, C, d, x, p) : C(x, p) ; in rzk-1 we write idJ(A, a, C, d, x, p) ; idJ is not valid syntax without exactly 6-tuple provided as an argument! Extension types \\left\\langle \\prod_{t : I \\mid \\psi} A \\vert ^{\\phi} _{a} \\right\\rangle are written as <{t : I | psi} -> A [ phi |-> a ]> specifying [ phi |-> a ] is optional, defaults to [ BOT |-> recBOT ] (like in RSTT); specifying psi in {t : I | psi} is mandatory; values of function types are \\lambda -abstractions written in one of the following ways: \\t -> <body> or \u03bbt \u2192 <body> \u2014 this is usually fine; \\{t : I | psi} -> <body> or \u03bb{t : I | psi} -> <body> \u2014 this sometimes helps the typechecker; Types of functions from a shape \\prod_{t : I \\mid \\psi} A are a specialised variant of extension types and are written {t : I | psi} -> A specifying the name of the argument is mandatory; i.e. {I | psi} -> A is invalid syntax! values of function types are \\lambda -abstractions written in one of the following ways: \\t -> <body> or \u03bbt \u2192 <body> \u2014 this is usually fine; \\{t : I | psi} -> <body> or \u03bb{t : I | psi} -> <body> \u2014 this sometimes helps the typechecker;","title":"Types and terms"},{"location":"tts/introduction/#tope-disjuction-elimination","text":"Following RSTT, rzk-1 introduces two primitive terms for disjunction elimination: recBOT (also written rec\u22a5 ) corresponds to \\mathsf{rec}_\\bot , has any type, and is valid whenever tope context is included in BOT ; recOR(psi, phi, a_psi, a_phi) (also written rec\u2228(psi, phi, a_psi, a_phi) ) corresponds to \\mathsf{rec}_\\lor^{\\psi, \\phi}(a_\\psi, a_\\phi) , is well-typed when a_psi is definitionally equal to a_phi under psi /\\ phi .","title":"Tope disjuction elimination"},{"location":"tts/introduction/#soundness","text":"First of all, in rzk-1 we have \"type-in-type\", that is U has type U . This is known to make the type system unsound, however, it is usually considered acceptable in proof assistants. And, since it simplifies implementation, rzk-1 follows this convention. Additionally, unlike RSTT, rzk-1 does not prevent cubes or topes to depend on types and terms. For example, the following definition typechecks: #def weird : (A : U) -> (I : (x : A) -> CUBE) -> (x : A) -> (y : A) -> CUBE := \\A -> \\I -> \\x -> \\y -> I x * I y This likely leads to another inconsistency, but it will hardly lead to bugs in actual proofs of interest, so current version embraces this treatment of universes.","title":"Soundness"},{"location":"tts/recId/","text":"Tope disjuction elimination along identity paths \\mathsf{rec}_{\\lor}^{\\psi,\\phi}(a_\\psi, a_\\phi) (written recOR(psi, phi, a_psi, a_phi) in the code) is well-typed when a_\\psi and a_\\phi are definitionally equal on \\psi \\land \\phi . Sometimes this is too strong since many terms are not definitionally equal, but only equal up to a path. Luckily, assuming relative function extensionality, we can define a weaker version of rec_{\\lor} ( recOR ), which we call recId , that can work in presence of a witness of type \\prod_{t : I \\mid \\psi \\land \\phi} a_\\psi = a_\\phi . Prerequisites We begin by introducing common HoTT definitions: #lang rzk-1 -- A is contractible there exists x : A such that for any y : A we have x = y. #def iscontr : (A : U) -> U := \\A -> \u2211 (a : A), (x : A) -> a =_{A} x -- A is a proposition if for any x, y : A we have x = y #def isaprop : (A : U) -> U := \\A -> (x : A) -> (y : A) -> x =_{A} y -- A is a set if for any x, y : A the type x =_{A} y is a proposition #def isaset : (A : U) -> U := \\A -> (x : A) -> (y : A) -> isaprop (x =_{A} y) -- Non-dependent product of A and B #def prod : (A : U) -> (B : U) -> U := \\A -> \\B -> \u2211 (x : A), B -- A function f : A -> B is an equivalence -- if there exists g : B -> A -- such that for all x : A we have g (f x) = x -- and for all y : B we have f (g y) = y #def isweq : (A : U) -> (B : U) -> (f : (x : A) -> B) -> U := \\A -> \\B -> \\f -> \u2211 (g : (x : B) -> A), prod ((x : A) -> g (f x) =_{A} x) ((y : B) -> f (g y) =_{B} y) -- Equivalence of types A and B #def weq : (A : U) -> (B : U) -> U := \\A -> \\B -> \u2211 (f : (x : A) -> B), isweq A B f -- Transport along a path #def transport : (A : U) -> (C : (x : A) -> U) -> (x : A) -> (y : A) -> (p : x =_{A} y) -> (cx : C x) -> C y := \\A -> \\C -> \\x -> \\y -> \\p -> \\cx -> idJ(A, x, (\\z -> \\q -> C z), cx, y, p) Relative function extensionality We can now define relative function extensionality. There are several formulations, we provide two, following Riehl and Shulman: -- [RS17, Axiom 4.6] Relative function extensionality. #def relfunext : U := (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t} -> U >) -> (iscontrA : <{t : I | psi t} -> iscontr (A t) >) -> (a : <{t : I | psi t /\\ phi t} -> A t >) -> <{t : I | psi t} -> A t [ psi t /\\ phi t |-> a t]> -- [RS17, Proposition 4.8] A (weaker) formulation of function extensionality. #def relfunext2 : U := (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t} -> U >) -> (a : <{t : I | psi t /\\ phi t} -> A t >) -> (f : <{t : I | psi t} -> A t [ psi t /\\ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ psi t /\\ phi t |-> a t ]>) -> weq (f =_{<{t : I | psi t} -> A t [ psi t /\\ phi t |-> a t ]>} g) <{t : I | psi t} -> f t =_{A t} g t [ psi t /\\ phi t |-> refl_{f t} ]> Construction of recId The idea is straightforward. We ask for a proof that a = b for all points in psi /\\ phi . Then, by relative function extensionality ( relfunext2 ), we can show that restrictions of a and b to psi /\\ phi are equal. If we reformulate a as extension of its restriction, then we can transport such reformulation along the path connecting two restrictions and apply recOR . First, we define how to restrict an extension type to a subshape: -- Restrict extension type to a subshape. #def restrict : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a : <{t : I | psi t} -> A t >) -> <{t : I | psi t /\\ phi t} -> A t > := \\I -> \\psi -> \\phi -> \\A -> \\a -> \\t -> a t Then, how to reformulate an a (or b ) as an extension of its restriction: -- Reformulate extension type as an extension of a restriction. #def ext-of-restrict : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a : <{t : I | psi t} -> A t >) -> <{t : I | psi t} -> A t [ psi t /\\ phi t |-> restrict I psi phi A a t ]> := \\I -> \\psi -> \\phi -> \\A -> \\a -> \\t -> a t Now, assuming relative function extensionality, we construct a path between restrictions: -- Transform extension of an identity into an identity of restrictions. #def restricts-path : (r : relfunext2) -> (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a_psi : <{t : I | psi t} -> A t >) -> (a_phi : <{t : I | phi t} -> A t >) -> (e : <{t : I | psi t /\\ phi t} -> a_psi t =_{A t} a_phi t >) -> restrict I psi phi A a_psi =_{ <{t : I | psi t /\\ phi t} -> A t > } restrict I phi psi A a_phi := \\r -> \\I -> \\psi -> \\phi -> \\A -> \\a_psi -> \\a_phi -> \\e -> (first (second (r I (\\t -> psi t /\\ phi t) (\\t -> BOT) (\\t -> A t) (\\t -> recBOT) (\\t -> a_psi t) (\\t -> a_phi t)))) e Finally, we bring everything together into recId : -- A weaker version of recOR, demanding only a path between a and b: -- recOR(psi, phi, a, b) demands that for psi /\\ phi we have a == b (definitionally) -- (recId psi phi a b e) demands that e is the proof that a = b (intensionally) for psi /\\ phi #def recId : (r : relfunext2) -> (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a_psi : <{t : I | psi t} -> A t >) -> (a_phi : <{t : I | phi t} -> A t >) -> (e : <{t : I | psi t /\\ phi t} -> a_psi t =_{A t} a_phi t >) -> <{t : I | psi t \\/ phi t} -> A t > := \\r -> \\I -> \\psi -> \\phi -> \\A -> \\a_psi -> \\a_phi -> \\e -> \\t -> recOR(psi t, phi t , transport <{t : I | psi t /\\ phi t} -> A t > (\\ra -> <{t : I | psi t} -> A t [ psi t /\\ phi t |-> ra t]>) (restrict I psi phi A a_psi) (restrict I phi psi A a_phi) (restricts-path r I psi phi A a_psi a_phi e) (ext-of-restrict I psi phi A a_psi) t , ext-of-restrict I phi psi A a_phi t) Gluing extension types An application of of recId is gluing together extension types, whenever we can show that they are equal on the intersection of shapes: -- If two extension types are equal along two subshapes, -- then they are also equal along their union. #def id-along-border : (r : relfunext2) -> (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a : <{t : I | psi t \\/ phi t} -> A t >) -> (b : <{t : I | psi t \\/ phi t} -> A t >) -> (e_psi : <{t : I | psi t} -> a t =_{A t} b t >) -> (e_phi : <{t : I | phi t} -> a t =_{A t} b t >) -> (border-is-a-set : <{t : I | psi t /\\ phi t} -> isaset (A t) >) -> <{t : I | psi t \\/ phi t} -> a t =_{A t} b t > := \\r -> \\I -> \\psi -> \\phi -> \\A -> \\a -> \\b -> \\e_psi -> \\e_phi -> \\border-is-a-set -> recId r I psi phi (\\{t : I | psi t \\/ phi t} -> a t =_{A t} b t) e_psi e_phi (\\{t : I | psi t /\\ phi t} -> border-is-a-set t (a t) (b t) (e_psi t) (e_phi t))","title":"Weak tope disjunction elimination"},{"location":"tts/recId/#tope-disjuction-elimination-along-identity-paths","text":"\\mathsf{rec}_{\\lor}^{\\psi,\\phi}(a_\\psi, a_\\phi) (written recOR(psi, phi, a_psi, a_phi) in the code) is well-typed when a_\\psi and a_\\phi are definitionally equal on \\psi \\land \\phi . Sometimes this is too strong since many terms are not definitionally equal, but only equal up to a path. Luckily, assuming relative function extensionality, we can define a weaker version of rec_{\\lor} ( recOR ), which we call recId , that can work in presence of a witness of type \\prod_{t : I \\mid \\psi \\land \\phi} a_\\psi = a_\\phi .","title":"Tope disjuction elimination along identity paths"},{"location":"tts/recId/#prerequisites","text":"We begin by introducing common HoTT definitions: #lang rzk-1 -- A is contractible there exists x : A such that for any y : A we have x = y. #def iscontr : (A : U) -> U := \\A -> \u2211 (a : A), (x : A) -> a =_{A} x -- A is a proposition if for any x, y : A we have x = y #def isaprop : (A : U) -> U := \\A -> (x : A) -> (y : A) -> x =_{A} y -- A is a set if for any x, y : A the type x =_{A} y is a proposition #def isaset : (A : U) -> U := \\A -> (x : A) -> (y : A) -> isaprop (x =_{A} y) -- Non-dependent product of A and B #def prod : (A : U) -> (B : U) -> U := \\A -> \\B -> \u2211 (x : A), B -- A function f : A -> B is an equivalence -- if there exists g : B -> A -- such that for all x : A we have g (f x) = x -- and for all y : B we have f (g y) = y #def isweq : (A : U) -> (B : U) -> (f : (x : A) -> B) -> U := \\A -> \\B -> \\f -> \u2211 (g : (x : B) -> A), prod ((x : A) -> g (f x) =_{A} x) ((y : B) -> f (g y) =_{B} y) -- Equivalence of types A and B #def weq : (A : U) -> (B : U) -> U := \\A -> \\B -> \u2211 (f : (x : A) -> B), isweq A B f -- Transport along a path #def transport : (A : U) -> (C : (x : A) -> U) -> (x : A) -> (y : A) -> (p : x =_{A} y) -> (cx : C x) -> C y := \\A -> \\C -> \\x -> \\y -> \\p -> \\cx -> idJ(A, x, (\\z -> \\q -> C z), cx, y, p)","title":"Prerequisites"},{"location":"tts/recId/#relative-function-extensionality","text":"We can now define relative function extensionality. There are several formulations, we provide two, following Riehl and Shulman: -- [RS17, Axiom 4.6] Relative function extensionality. #def relfunext : U := (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t} -> U >) -> (iscontrA : <{t : I | psi t} -> iscontr (A t) >) -> (a : <{t : I | psi t /\\ phi t} -> A t >) -> <{t : I | psi t} -> A t [ psi t /\\ phi t |-> a t]> -- [RS17, Proposition 4.8] A (weaker) formulation of function extensionality. #def relfunext2 : U := (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t} -> U >) -> (a : <{t : I | psi t /\\ phi t} -> A t >) -> (f : <{t : I | psi t} -> A t [ psi t /\\ phi t |-> a t ]>) -> (g : <{t : I | psi t} -> A t [ psi t /\\ phi t |-> a t ]>) -> weq (f =_{<{t : I | psi t} -> A t [ psi t /\\ phi t |-> a t ]>} g) <{t : I | psi t} -> f t =_{A t} g t [ psi t /\\ phi t |-> refl_{f t} ]>","title":"Relative function extensionality"},{"location":"tts/recId/#construction-of-recid","text":"The idea is straightforward. We ask for a proof that a = b for all points in psi /\\ phi . Then, by relative function extensionality ( relfunext2 ), we can show that restrictions of a and b to psi /\\ phi are equal. If we reformulate a as extension of its restriction, then we can transport such reformulation along the path connecting two restrictions and apply recOR . First, we define how to restrict an extension type to a subshape: -- Restrict extension type to a subshape. #def restrict : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a : <{t : I | psi t} -> A t >) -> <{t : I | psi t /\\ phi t} -> A t > := \\I -> \\psi -> \\phi -> \\A -> \\a -> \\t -> a t Then, how to reformulate an a (or b ) as an extension of its restriction: -- Reformulate extension type as an extension of a restriction. #def ext-of-restrict : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a : <{t : I | psi t} -> A t >) -> <{t : I | psi t} -> A t [ psi t /\\ phi t |-> restrict I psi phi A a t ]> := \\I -> \\psi -> \\phi -> \\A -> \\a -> \\t -> a t Now, assuming relative function extensionality, we construct a path between restrictions: -- Transform extension of an identity into an identity of restrictions. #def restricts-path : (r : relfunext2) -> (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a_psi : <{t : I | psi t} -> A t >) -> (a_phi : <{t : I | phi t} -> A t >) -> (e : <{t : I | psi t /\\ phi t} -> a_psi t =_{A t} a_phi t >) -> restrict I psi phi A a_psi =_{ <{t : I | psi t /\\ phi t} -> A t > } restrict I phi psi A a_phi := \\r -> \\I -> \\psi -> \\phi -> \\A -> \\a_psi -> \\a_phi -> \\e -> (first (second (r I (\\t -> psi t /\\ phi t) (\\t -> BOT) (\\t -> A t) (\\t -> recBOT) (\\t -> a_psi t) (\\t -> a_phi t)))) e Finally, we bring everything together into recId : -- A weaker version of recOR, demanding only a path between a and b: -- recOR(psi, phi, a, b) demands that for psi /\\ phi we have a == b (definitionally) -- (recId psi phi a b e) demands that e is the proof that a = b (intensionally) for psi /\\ phi #def recId : (r : relfunext2) -> (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a_psi : <{t : I | psi t} -> A t >) -> (a_phi : <{t : I | phi t} -> A t >) -> (e : <{t : I | psi t /\\ phi t} -> a_psi t =_{A t} a_phi t >) -> <{t : I | psi t \\/ phi t} -> A t > := \\r -> \\I -> \\psi -> \\phi -> \\A -> \\a_psi -> \\a_phi -> \\e -> \\t -> recOR(psi t, phi t , transport <{t : I | psi t /\\ phi t} -> A t > (\\ra -> <{t : I | psi t} -> A t [ psi t /\\ phi t |-> ra t]>) (restrict I psi phi A a_psi) (restrict I phi psi A a_phi) (restricts-path r I psi phi A a_psi a_phi e) (ext-of-restrict I psi phi A a_psi) t , ext-of-restrict I phi psi A a_phi t)","title":"Construction of recId"},{"location":"tts/recId/#gluing-extension-types","text":"An application of of recId is gluing together extension types, whenever we can show that they are equal on the intersection of shapes: -- If two extension types are equal along two subshapes, -- then they are also equal along their union. #def id-along-border : (r : relfunext2) -> (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : (t : I) -> TOPE) -> (A : <{t : I | psi t \\/ phi t} -> U >) -> (a : <{t : I | psi t \\/ phi t} -> A t >) -> (b : <{t : I | psi t \\/ phi t} -> A t >) -> (e_psi : <{t : I | psi t} -> a t =_{A t} b t >) -> (e_phi : <{t : I | phi t} -> a t =_{A t} b t >) -> (border-is-a-set : <{t : I | psi t /\\ phi t} -> isaset (A t) >) -> <{t : I | psi t \\/ phi t} -> a t =_{A t} b t > := \\r -> \\I -> \\psi -> \\phi -> \\A -> \\a -> \\b -> \\e_psi -> \\e_phi -> \\border-is-a-set -> recId r I psi phi (\\{t : I | psi t \\/ phi t} -> a t =_{A t} b t) e_psi e_phi (\\{t : I | psi t /\\ phi t} -> border-is-a-set t (a t) (b t) (e_psi t) (e_phi t))","title":"Gluing extension types"}]}
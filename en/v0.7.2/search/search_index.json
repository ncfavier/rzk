{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rzk proof assistant","text":"<p>Rzk is an experimental proof assistant, based on \u00abType Theory for Synthetic \u221e-categories\u00bb<sup>1</sup>.</p> <p>Get started with Rzk Try Rzk Playground</p>"},{"location":"#about-this-project","title":"About this project","text":"<p>This project has started with the idea of bringing Riehl and Shulman's 2017 paper<sup>1</sup> to \"life\" by implementing a proof assistant based on their type theory with shapes. At the moment, Rzk provides a language that is close to the original paper, as well as some tooling around it (such as a VS Code extension and a language server with syntax highlighting and formatting support).</p>"},{"location":"#formalizing-category-theory","title":"Formalizing \u221e-category theory","text":"<p>A big portion of the original paper (up to the \u221e-categorical Yoneda lemma) has been formalized in Rzk (see Yoneda for \u221e-categories<sup>2</sup>). More formalization results are under way (see sHoTT). There are also some efforts to formalize the HoTT Book in Rzk (see hottbook).</p>"},{"location":"#using-rzk","title":"Using Rzk","text":"<p>The recommended way of interacting with Rzk is via VS Code (see Getting Started), but you can also download binaries from GitHub Releases, build from sources, or try setting up the Rzk Language Server with your editor of choice. Additionally, for \"throwaway\" single-file formalizations, you can use Rzk Online Playground.</p>"},{"location":"#implementation","title":"Implementation","text":"<p>Rzk serves also as a playground for some techniques of developing proof assistants in Haskell. In particular, it features a version of second-order abstract syntax for handling binders and, in the future, dependent type inference through higher-order unification<sup>3</sup> <sup>4</sup>. The idea is ultimately, to provide higher-order unification and/or dependent type inference \"as a library\", keeping the implementation of Rzk (at least its core language) small, maintainable, and safe.</p> <p>Another important part of Rzk is the tope layer solver<sup>5</sup>, which is a built-in intuitionistic theorem prover required for a part of the type theory. Although its implementation is fairly simple, it is sufficient to check existing proofs in synthetic \u221e-categories without requiring any explicit proofs for the tope layer.</p> <p>Rzk and the tooling around it is developed by just a couple of people. See the list of contributors at CONTRIBUTORS.md.</p>"},{"location":"#discussing-rzk-and-getting-help","title":"Discussing Rzk and getting help","text":"<p>A Zulip chat is available for all to join and chat about Rzk, including formalization projects, development of Rzk, and related projects:</p> <p>Join Rzk Zulip</p>"},{"location":"#other-proof-assistants-for-hott","title":"Other proof assistants for HoTT","text":"<p>Rzk is not the first or the only proof assistant where it's possible to do (a variant of) homotopy type theory. See a brief comparison of Rzk with other proof assistants.</p> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9\u21a9</p> </li> <li> <p>Nikolai Kudasov, Emily Riehl, Jonathan Weinberger. Formalizing the \u221e-categorical Yoneda lemma. 2023. https://arxiv.org/abs/2309.08340 \u21a9</p> </li> <li> <p>Nikolai Kudasov. Functional Pearl: Dependent type inference via free higher-order unification. 2022. https://arxiv.org/abs/2204.05653 \u21a9</p> </li> <li> <p>Nikolai Kudasov. E-Unification for Second-Order Abstract Syntax. In 8th International Conference on Formal Structures for Computation and Deduction (FSCD 2023). Leibniz International Proceedings in Informatics (LIPIcs), Volume 260, pp. 10:1-10:22, Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik (2023) https://doi.org/10.4230/LIPIcs.FSCD.2023.10 \u21a9</p> </li> <li> <p>Nikolai Kudasov. Experimental prover for Tope logic. SCAN 2023, pages 37\u201339. 2023. https://www.mathnet.ru/ConfLogos/2220/abstracts.pdf#page=38 \u21a9</p> </li> </ol>"},{"location":"CHANGELOG/","title":"Changelog for <code>rzk</code>","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to the Haskell Package Versioning Policy.</p>"},{"location":"CHANGELOG/#v072-2023-12-12","title":"v0.7.2 \u2014 2023-12-12","text":"<p>Fixes: - Fixes for <code>rzk format</code>:     - Fix extra space after open parens in formatter (see #155);     - Replace line string content with tokens when checking open parens (see #156); - Throw an error when <code>rzk.yaml</code>'s <code>include</code> is empty (see #154);</p> <p>Changes to the Rzk website:   - Support multiple languages in the documentation (see #150);       - English is the default;       - Russian documentation is partially translated and is available at http://rzk-lang.github.io/rzk/ru/;   - Add a blog (see #153 and <code>e438820</code>);       - The blog is not versioned and is always available at https://rzk-lang.github.io/rzk/en/blog/;   - Add a new Other proof assistants for HoTT page (also in Russian);   - Add a new Introduction to Dependent Types page (also in Russian)   - Add (default) social cards   - Integrate ToC on the left   - Use Inria Sans for English, PT Sans for Russian</p>"},{"location":"CHANGELOG/#v071-2023-12-08","title":"v0.7.1 \u2014 2023-12-08","text":"<ul> <li>Fix default build to include Rzk Language Server (<code>rzk lsp</code>) (see <code>9b78a15</code>);</li> <li>Apply formatting to <code>recId.rzk.md</code> example (see <code>4032724</code>);</li> </ul>"},{"location":"CHANGELOG/#v070-2023-12-08","title":"v0.7.0 \u2014 2023-12-08","text":"<p>Major changes:</p> <ul> <li>Add an experimental <code>rzk format</code> command (by Abdelrahman Abounegm, with feedback by Fredrik Bakke (see sHoTT#142) and Nikolai Kudasov):</li> <li>Automatically format files, partially automating the Code Style of the sHoTT project</li> <li>Notable features:<ul> <li>Adds a space after the opening parenthesis to help with the code tree structure</li> <li>Puts the definition conclusion (type, starting with <code>:</code>) and construction (body, starting with <code>:=</code>) on new lines</li> <li>Adds a space after the <code>\\</code> of a lambda term and around binary operators (like <code>,</code>)</li> <li>Moves binary operators to the beginning of the next line if they appear at the end of the previous one.</li> <li>Replaces common ASCII sequences with their Unicode equivalent</li> <li>A CLI subcommand (<code>rzk format</code>) with <code>--check</code> and <code>--write</code> options</li> </ul> </li> <li>Known limitations<ul> <li>The 80 character line limit is currently not enforced due to the difficulty of determining where to add line breaks (for reference, check out this post by a Dart <code>fmt</code> engineer)</li> <li>Fixing indentation is not yet implemented due to the need for more semantics than the lexer provides to determine indentation level.</li> <li>There may be rare edge cases in which applying the formatter twice could result in additional edits that were not detected the first time.</li> </ul> </li> </ul> <p>Minor changes:</p> <ul> <li>Fix \"latest\" Rzk Playground link (see #137);</li> <li>Add more badges to README (see #136);</li> </ul>"},{"location":"CHANGELOG/#v067-2023-10-07","title":"v0.6.7 \u2014 2023-10-07","text":"<ul> <li>Fix build on some systems (fix <code>BNFC:bnfc</code> executable dependency, see #125)</li> <li>Improve Rzk Playground (see #124 by @deemp):</li> <li>Add <code>snippet_url</code> parameter</li> <li>Migrated from NextJS to Vite</li> <li>Use <code>setText</code> on <code>params</code> attribute</li> <li>Slightly improve documentation:</li> <li>Add links to Rzk Zulip (see #131)</li> <li>Add <code>cabal update</code> to instructions (see <code>3aa8fd3</code>)</li> </ul>"},{"location":"CHANGELOG/#v066-2023-10-02","title":"v0.6.6 \u2014 2023-10-02","text":"<ul> <li>Fix builds on Windows (and macOS) (see #121)</li> </ul>"},{"location":"CHANGELOG/#v065-2023-10-01","title":"v0.6.5 \u2014 2023-10-01","text":"<p>This version contains mostly intrastructure improvements:</p> <ul> <li>Typecheck using <code>rzk.yaml</code> if it exists (see #119)</li> <li>Update Rzk Playground and Nix Flake (see #84)</li> <li>Rzk Playground now uses CodeMirror 6 and NextJS</li> <li><code>miso</code> dependency is dropped</li> <li>GHCJS 9.6 is now used</li> <li>Support <code>snippet={code}</code> or <code>code={code}</code> param (see #118)<ul> <li>Support for <code>snippet_url={URL}</code> is temporarily dropped</li> </ul> </li> <li>Update to GHC 9.6, latest Stackage Nightly, improve Rzk setup, and GitHub Actions (see #116)</li> <li>Add logging for Rzk Language Server (see #114)</li> </ul> <p>Fixes:</p> <ul> <li>Fix error messages in Rzk Playground (see #115)</li> </ul>"},{"location":"CHANGELOG/#v064-2023-09-27","title":"v0.6.4 \u2014 2023-09-27","text":"<p>This version improves the stucture of the project, in particular w.r.t dependencies:</p> <ul> <li>Add custom snapshot and explicit lower bounds (see #108)</li> </ul>"},{"location":"CHANGELOG/#v063-2023-09-27","title":"v0.6.3 \u2014 2023-09-27","text":"<p>This version contains a fix for the command line interface of <code>rzk</code>:</p> <ul> <li> <p>Fix command line <code>rzk typecheck</code> (see #106)</p> </li> <li> <p>Previous version ignored failures in the command line     (the bug was introced when allowing better autocompletion in LSP).</p> </li> </ul>"},{"location":"CHANGELOG/#v062-2023-09-26","title":"v0.6.2 \u2014 2023-09-26","text":"<p>This version contains some improvements in efficiency and also to the language server:</p> <ul> <li>Improve efficiency of the tope solver, applying LEM for directed interval only as a fallback option (see #102)</li> <li>Support autocompleting definitions from previous modules (see #102)</li> <li>Well-typed definitions from the same module also work if the module is only partially well-typed!</li> <li>Improve information order in the error messages given in LSP diagnostics (see #104)</li> </ul>"},{"location":"CHANGELOG/#v061-2023-09-24","title":"v0.6.1 \u2014 2023-09-24","text":"<p>This version contains a minor fix:</p> <ul> <li>Catch exceptions in the parser, fixing LSP for files where layout resolver fails (see #99).</li> </ul>"},{"location":"CHANGELOG/#v060-2023-09-23","title":"v0.6.0 \u2014 2023-09-23","text":"<p>This version introduces a proper LSP server with basic support for incremental typechecking and some minor improvements:</p> <ol> <li>LSP server with incremental typechecking (see #95);</li> <li>Improve error messages for unclosed <code>#section</code> and extra <code>#end</code> (see #91).</li> </ol>"},{"location":"CHANGELOG/#v057-2023-09-21","title":"v0.5.7 \u2014 2023-09-21","text":"<p>This version contains two fixes (see #88) for issues discovered in rzk-lang/sHoTT#30:</p> <ol> <li>We now only generate well-typed LEM instances in the tope solver, speeding up significantly.</li> <li>We fix \\(\\eta\\)-rule for product cubes, to not get stopped by reflexive equality topes like \\(\\langle \\langle \\pi_1 (t_{12}), \\pi_2 (t_{12}) \\rangle, t_3 \\rangle \\equiv \\langle t_{12}, t_3 \\rangle\\).</li> </ol>"},{"location":"CHANGELOG/#v056-2023-09-19","title":"v0.5.6 \u2014 2023-09-19","text":"<p>This version fixes the behaviour of glob (see <code>77b7cc0</code>).</p>"},{"location":"CHANGELOG/#v055-2023-09-19","title":"v0.5.5 \u2014 2023-09-19","text":"<p>This version contains Unicode and tope logic-related fixes:</p> <ol> <li>Fix (add missing checks) for subshapes (see #85);</li> <li>Allow to handle wildcards in <code>rzk</code> itself (see #83);</li> <li>Fix Unicode on machines with non-standard locales (see #82);</li> <li>Specify <code>happy</code> and <code>alex</code> as build tools to fix cabal build from Hackage (see #80).</li> <li>Add configuration for MkDocs plugin for Rzk (see #79).</li> </ol>"},{"location":"CHANGELOG/#v054-2023-08-19","title":"v0.5.4 \u2014 2023-08-19","text":"<p>This version contains minor improvements:</p> <ol> <li>Improve typechecking by trying an easier unification strategy first (see #76);</li> <li>Update GitHub Action for Nix (see #74).</li> </ol>"},{"location":"CHANGELOG/#v053-2023-07-12","title":"v0.5.3 \u2014 2023-07-12","text":"<p>This version contains a few minor improvements:</p> <ol> <li>Allow patterns in dependent function types (see #67);</li> <li>Hint about possible shape coercions (see #67);</li> <li>Enable doctests (see #68);</li> <li>Improve documentation (add recommended installation instructions via VS Code)</li> <li>Migrate from <code>fizruk</code> to <code>rzk-lang</code> organisation on GitHub (see <code>ee0d063</code>);</li> <li>Speed up GHCJS build with Nix (see #66);</li> </ol>"},{"location":"CHANGELOG/#v052-2023-07-05","title":"v0.5.2 \u2014 2023-07-05","text":"<p>This version introduces support for Unicode syntax, better recognition of Markdown code blocks and improves documentation a bit:</p> <ul> <li>Support some Unicode syntax (see #61);</li> <li>Support curly braces syntax for code blocks (see #64);</li> <li>Update documentation a bit (see 07b520a6 and 7cc7f383);</li> <li>Factor out Pygments highlighting to https://github.com/rzk-lang/pygments-rzk;</li> <li>Use new cache action for Nix (see #60).</li> </ul>"},{"location":"CHANGELOG/#v051-2023-06-29","title":"v0.5.1 \u2014 2023-06-29","text":"<p>This version fixes <code>Unit</code> type and makes some changes to documentation:</p> <ul> <li>Fix computation for <code>Unit</code> (see 2f7d6295);</li> <li>Update documentation (see ea2d176b);</li> <li>Use mike to deploy versioned docs (see 99cf721a);</li> <li>Replace MkDocs hook with the published plugin (see #58);</li> <li>Switch to Material theme for MkDocs (see #57);</li> <li>Fix links to <code>*.rzk.md</code> in <code>mkdocs.yml</code> (see 8ba1c55b);</li> </ul>"},{"location":"CHANGELOG/#v05-2023-06-20","title":"v0.5 \u2014 2023-06-20","text":"<p>This version contains the following changes:</p> <ul> <li><code>Unit</code> type (with <code>unit</code> value) (see ede02611 and bf9d6cd9;</li> <li>Add basic tokenizer support via <code>rzk tokenize</code> (see #53);</li> <li>Add location information for shadowing warnings and duplicate definition errors (see bf9d6cd9).</li> </ul>"},{"location":"CHANGELOG/#v041-2023-06-16","title":"v0.4.1 \u2014 2023-06-16","text":"<p>This is version contains minor changes, primarily in tools around rzk:</p> <ul> <li>Add <code>rzk version</code> command (see f1709dc7);</li> <li>Add action to release binaries (see 9286afae);</li> <li>Automate SVG rendering in MkDocs (see #49);</li> <li>Read <code>stdin</code> when no filepaths are given (see 936c15a3);</li> <li>Add Pygments highlighting (see 01c2a017, cbd656cc, 5220ddf9, 142ec003, 5c7425f2);</li> <li>Update HighlightJS config for rzk v0.4.0 (see 171ee63f);</li> </ul>"},{"location":"CHANGELOG/#v040-2023-05-18","title":"v0.4.0 \u2014 2023-05-18","text":"<p>This version introduces sections and variables. The feature is similar to <code>Variable</code> command in Coq. An important difference, however, is that <code>rzk</code> does not allow definitions to use variables implicitly and adds <code>uses (...)</code> annotations to ensure such dependencies are not accidental.</p> <ul> <li>Variables and sections (Coq-style) (see #38);</li> </ul> <p>Minor improvements:</p> <ul> <li>Add flake, set up nix and cabal builds, cache nix store on CI (see #39);</li> <li>Apply stylish-haskell (see 7d42ef62);</li> </ul>"},{"location":"CHANGELOG/#v030-2023-04-28","title":"v0.3.0 \u2014 2023-04-28","text":"<p>This version introduces an experimental feature for generating visualisations for simplicial terms in SVG. To enable rendering, enable option <code>\"render\" = \"svg\"</code> (to disable, <code>\"render\" = \"none\"</code>):</p> <pre><code>#set-option \"render\" = \"svg\"  -- enable rendering in SVG\n</code></pre> <p>Minor changes:</p> <ul> <li>Exit with non-zero code upon a type error (see b135c4fb)</li> <li>Fix external links and some typos in the documentation</li> </ul> <p>Fixes:</p> <ul> <li>Fixed an issue with tope solver when context was empty (see 6196af9e);</li> <li>Fixed #33 (missing coherence check for restricted types).</li> </ul>"},{"location":"CHANGELOG/#v020-2023-04-20","title":"v0.2.0 - 2023-04-20","text":"<p>This version was a complete rewrite of the proof assistant, using a new parser, a new internal representation, and a rewrite of the typechecking logic. This is still a prototype, but, arguably, significantly more stable and manageable than version 0.1.0.</p>"},{"location":"CHANGELOG/#language","title":"Language","text":"<p>Syntax is almost entirely backwards compatible with version 0.1.0. Typechecking has been fixed and improved.</p>"},{"location":"CHANGELOG/#breaking-changes","title":"Breaking Changes","text":"<p>The only known breaking changes are:</p> <ol> <li>Terms like <code>second x y</code> which previous have been parsed as <code>second (x y)</code>    now are properly parsed as <code>(second x) y</code>.</li> <li>It is now necessary to have at least a minimal indentation in the definition of a term after a newline.</li> <li>Unicode syntax is temporarily disabled, except for dependent sums and arrows in function types.</li> <li>The restriction syntax <code>[ ... ]</code> now has a slightly different precedence, so some parentheses are required, e.g. in <code>(A -&gt; B) [ phi |-&gt; f]</code> or <code>(f t = g t) [ phi |-&gt; f]</code>.</li> <li>Duplicate top-level definitions are no longer allowed.</li> </ol>"},{"location":"CHANGELOG/#deprecated-syntax","title":"Deprecated Syntax","text":"<p>The angle brackets for extension types are supported, but deprecated, as they are completely unnecessary now: <code>&lt;{t : I | psi t} -&gt; A t [ phi t |-&gt; a t ]&gt;</code> can now be written as <code>{t : I | psi t} -&gt; A t [ phi t |-&gt; a t]</code> or even <code>(t : psi) -&gt; A t [ phi t |-&gt; a t ]</code>.</p>"},{"location":"CHANGELOG/#syntax-relaxation","title":"Syntax Relaxation","text":"<p>Otherwise, syntax is now made more flexible:</p> <ol> <li>Function parameters can be unnamed: <code>A -&gt; B</code> is the same as <code>(_ : A) -&gt; B</code>.</li> <li>Angle brackets are now optional: <code>{t : I | psi t} -&gt; A t [ phi t |-&gt; a t ]</code></li> <li>Nullary extension types are possible: <code>A t [ phi t |-&gt; a t ]</code></li> <li>Lambda abstractions can introduce multiple arguments:</li> </ol> <pre><code>#def hom : (A : U) -&gt; A -&gt; A -&gt; U\n  := \\A x y -&gt;\n    (t : \u0394\u00b9) -&gt; A [ \u2202\u0394\u00b9 t |-&gt; recOR(t === 0_2, t === 1_2, x, y) ]\n</code></pre> <ol> <li>Parameters can be introduced simultaneously for the type and body. Moreover, multiple parameters can be introduced with the same type:</li> </ol> <pre><code>#def hom (A : U) (x y : A) : U\n  := (t : \u0394\u00b9) -&gt; A [ \u2202\u0394\u00b9 t |-&gt; recOR(t === 0_2, t === 1_2, x, y) ]\n</code></pre> <ol> <li>Restrictions can now support multiple subshapes, effectively internalising <code>recOR</code>:</li> </ol> <pre><code>#def hom (A : U) (x y : A) : U\n  := (t : \u0394\u00b9) -&gt; A [ t === 0_2 |-&gt; x, t === 1_2 |-&gt; y ]\n</code></pre> <ol> <li> <p>There are now 3 syntactic versions of <code>refl</code> with different amount of explicit annotations:    <code>refl</code>, <code>refl_{x}</code> and <code>refl_{x : A}</code></p> </li> <li> <p>There are now 2 syntactic versions of identity types (<code>=</code>): <code>x = y</code> and <code>x =_{A} y</code>.</p> </li> <li> <p><code>recOR</code> now supports alternative syntax with an arbitrary number of subshapes:    <code>recOR( tope1 |-&gt; term1, tope2 |-&gt; term2, ..., topeN |-&gt; termN )</code></p> </li> <li> <p>Now it is possible to have type ascriptions: <code>t as T</code>. This can help with ensuring types of subexpressions in parts of formalisations, or to upcast types.</p> </li> <li> <p>New (better) commands are now supported:</p> <ol> <li><code>#define &lt;name&gt; (&lt;param&gt;)* : &lt;type&gt; := &lt;term&gt;</code> \u2014 same as <code>#def</code>, but with full spelling of the word</li> <li><code>#postulate &lt;name&gt; (&lt;param&gt;)* : &lt;type&gt;</code> \u2014 postulate an axiom</li> <li><code>#check &lt;term&gt; : &lt;type&gt;</code> \u2014 typecheck an expression against a given type</li> <li><code>#compute-whnf &lt;term&gt;</code> \u2014 compute (WHNF) of a term</li> <li><code>#compute-nf &lt;term&gt;</code> \u2014 compute normal form of a term</li> <li><code>#compute &lt;term&gt;</code> \u2014 alias for <code>#compute-whnf</code></li> <li> <p><code>#set-option &lt;option&gt; = &lt;value&gt;</code> \u2014 set a (typechecker) option:</p> </li> <li> <p><code>#set-option \"verbosity\" = \"silent\"</code> \u2014 no log printing</p> </li> <li><code>#set-option \"verbosity\" = \"normal\"</code> \u2014 log typechecking progress</li> <li> <p><code>#set-option \"verbosity\" = \"debug\"</code> \u2014 log every intermediate action      (may be useful to debug when some definition does not typecheck)</p> </li> <li> <p><code>#unset-option &lt;option&gt;</code> \u2014 revert option's value to its default</p> </li> </ol> </li> </ol>"},{"location":"CHANGELOG/#simple-shape-coercions","title":"Simple Shape Coercions","text":"<p>In some places, shapes (cube indexed tope families) can be used directly:</p> <ol> <li> <p>In function parameters: <code>(\u039b -&gt; A) -&gt; (\u0394\u00b2 -&gt; A)</code> is the same as <code>({(t, s) : 2 * 2 | \u039b (t, s)} -&gt; A) -&gt; ({(t, s) : 2 * 2 | \u0394\u00b2} -&gt; A)</code></p> </li> <li> <p>In parameter types of lambda abstractions: <code>\\((t, s) : \u0394\u00b2) -&gt; ...</code> is the same as <code>\\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -&gt; ...</code></p> </li> </ol>"},{"location":"CHANGELOG/#better-type-inference","title":"Better Type Inference","text":"<ol> <li> <p>It is now not required to annotate point variables with tope restrictions, the typechecker is finally smart enough to figure them out from the context.</p> </li> <li> <p>It is now possible to simply write <code>refl</code> in most situations.</p> </li> <li> <p>It is now possible to omit the index type in an identity type: <code>x = y</code></p> </li> </ol>"},{"location":"CHANGELOG/#better-output-and-error-message","title":"Better output and error message","text":"<p>The output and error messages have been slightly improved, but not in a major way.</p>"},{"location":"CHANGELOG/#internal-representation","title":"Internal representation","text":"<p>A new internal representation (a version of second-order abstract syntax) allows to stop worrying about name captures in substitutions, so the implementation is much more trustworthy. The new representation will also allow to bring in higher-order unification in the future, for better type inference, matching, etc.</p> <p>New representation also allowed annotating each (sub)term with its type to avoid recomputations and some other minor speedups. There are still some performance issues, which need to be debugged, but overall it is much faster than version 0.1.0 already.</p>"},{"location":"CONTRIBUTORS/","title":"List of contributors","text":"<p>The following people have contributed to Rzk proof assistant:</p> <ol> <li>Nikolai Kudasov</li> <li>Abdelrahman Abounegm \u2014 contributed to the Rzk Language Server</li> <li>Danila Danko \u2014 helped set up Nix and Rzk playground</li> </ol> <p>You may see actual contributed commits in the Contributors page on GitHub.</p>"},{"location":"community/","title":"Rzk Community","text":"<p>There is a small community of mathematicians and computer scientists around Rzk.</p>"},{"location":"community/#chat","title":"Chat","text":"<p>A Zulip chat is available for all to join and chat about Rzk, including formalization projects, development of Rzk, and related projects:</p> <p>Join Rzk Zulip</p>"},{"location":"related/","title":"Other proof assistants for HoTT","text":"<p>Rzk is not the first or the only proof assistant where it's possible to do (a variant of) homotopy type theory. Here is an incomplete list of such proof assistants and corresponding formalization libraries.</p>"},{"location":"related/#agda","title":"Agda","text":"<p>Agda is a dependently typed programming language (and also a proof assistant).</p> <p>While by default Agda is not compatible with HoTT because of built-in Axiom K, it supports <code>--without-K</code> option, allowing to restore the compatibility with univalence. Some notable HoTT libraries in Agda include <code>agda-unimath</code>, <code>HoTT-Agda</code>.</p> <p>Rzk's syntax for expressions is partially inspired by Agda. Rzk's (experimental) formatter is based on the code style accepted in emilyriehl/yoneda and rzk-lang/sHoTT projects, which comes largely from the code style of <code>agda-unimath</code>.</p> <p>Agda is implemented in Haskell.</p>"},{"location":"related/#arend","title":"Arend","text":"<p>Arend is a theorem prover based on homotopy type theory with an interval type, making it similar to cubical type theories. Arend features a standard library at JetBrains/arend-lib.</p> <p>Arend is developed by JetBrains, and is implemented in Java. It also features a plugin for IntelliJ IDEA turning it into an IDE for Arend.</p>"},{"location":"related/#aya","title":"Aya","text":"<p>Aya is an experimental cubical proof assistant, featuring type system features similar to Cubical Agda, redtt, and Arend. It also features overlapping and order-independent pattern matching, as well as some functional programming features similar to Haskell and Idris.</p> <p>Aya is implemented in Java.</p> <p>Formalizations in Aya?</p> <p>I do not know of existing formalization libraries in Aya.</p>"},{"location":"related/#the-red-family","title":"The red* family","text":"<p>cooltt, redtt, and RedPRL are a family of experimental proof assistants developed by the RedPRL Development Team.</p> <p>There is a redtt mathematical library</p> <p>The red* family of proof assistants is implemented in OCaml. The developers also have a related A.L.G.A.E. project, which aims to provide composable (OCaml) libraries that facilitate the construction of a usable proof assistant from a core type checker."},{"location":"related/#coq","title":"Coq","text":"<p>Coq is a mature proof assistant, based on the Calculus of Inductive Constructions. The original HoTT formalization, UniMath, initiated by Vladimir Voevodsky, is done in Coq and is maintained to this day by The UniMath Coordinating Committee. Other notable formalizations of HoTT in Coq include Coq-HoTT<sup>3</sup></p> <p>Coq is implemented in OCaml.</p>"},{"location":"related/#cubical-agda","title":"Cubical Agda","text":"<p>Cubical Agda is a mode extending Agda with a variety of features from Cubical Type Theory<sup>1</sup> <sup>2</sup>.</p> <p>Although technical a mode within Agda, it is probably best seen as a separate language. Cubical Agda (as well as other cubical proof assistants) supports a variant of extension types found in Rzk, albeit restricted to the use with cubical intervals.</p> <p>Some notable formalizations in Cubical Agda include <code>cubical</code> and 1lab.</p> <p>Cubical Agda as part of Agda is implemented in Haskell.</p>"},{"location":"related/#cubicaltt","title":"<code>cubicaltt</code>","text":"<p><code>cubicaltt</code> is an experimental cubical proof assistant<sup>1</sup> and a precursor to Cubical Agda.</p> <p>Several formalizations in <code>cubicaltt</code> can be found at https://github.com/mortberg/cubicaltt/tree/master/examples.</p> <p><code>cubicaltt</code> is implemented in Haskell.</p>"},{"location":"related/#lean","title":"Lean","text":"<p>Lean is a teorem prover and a dependently typed programming language, based on the Calculus of Inductive Constructions. Similarly to Coq, Lean encourages heavy use of tactics and automation.</p> <p>Lean 2, similarly to Agda, supported a mode without uniqueness of identity proofs (UIP), which allowed for HoTT formalizations. Hence, a formalization of HoTT in Lean 2<sup>4</sup> exists. However, since Lean 2 is not supported anymore, the formalization is also unmantained.</p> <p>Lean 3 and 4 has dropped the mode that allowed (direct) HoTT formalization. There is, however, an unmaintained port of Lean 2 HoTT Library to Lean 3.</p> <p>Lean 2 and 3 are implemented in C++. Lean 4 is implemented in itself (and a bit of C++)!</p> <ol> <li> <p>Cyril Cohen, Thierry Coquand, Simon Huber, and Anders M\u00f6rtberg. Cubical Type Theory: A Constructive Interpretation of the Univalence Axiom. In 21st International Conference on Types for Proofs and Programs (TYPES 2015). Leibniz International Proceedings in Informatics (LIPIcs), Volume 69, pp. 5:1-5:34, Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik (2018) https://doi.org/10.4230/LIPIcs.TYPES.2015.5 \u21a9\u21a9</p> </li> <li> <p>Thierry Coquand, Simon Huber, and Anders M\u00f6rtberg. 2018. On Higher Inductive Types in Cubical Type Theory. In Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science (LICS '18). Association for Computing Machinery, New York, NY, USA, 255\u2013264. https://doi.org/10.1145/3209108.3209197 \u21a9</p> </li> <li> <p>Andrej Bauer, Jason Gross, Peter LeFanu Lumsdaine, Michael Shulman, Matthieu Sozeau, and Bas Spitters. 2017. The HoTT library: a formalization of homotopy type theory in Coq. In Proceedings of the 6th ACM SIGPLAN Conference on Certified Programs and Proofs (CPP 2017). Association for Computing Machinery, New York, NY, USA, 164\u2013172. https://doi.org/10.1145/3018610.3018615 \u21a9</p> </li> <li> <p>Floris van Doorn, Jakob von Raumer &amp; Ulrik Buchholtz. 2017. Homotopy Type Theory in Lean. In: Ayala-Rinc\u00f3n, M., Mu\u00f1oz, C.A. (eds) Interactive Theorem Proving. ITP 2017. Lecture Notes in Computer Science(), vol 10499. Springer, Cham. https://doi.org/10.1007/978-3-319-66107-0_30 \u21a9</p> </li> </ol>"},{"location":"tools/","title":"Tools","text":"<p>Rzk proof assistant comes with built-in language server and formatter.</p> <p>Other tools help enhance user experience or automate things.</p>"},{"location":"tools/#vs-code-extension-for-rzk","title":"VS Code extension for Rzk","text":"<p>See rzk-lang/vscode-rzk. VS Code extension offers a lot of conveniences and using VS Code is recommended for newcomers, as it is considered the primary use case and has most support from the developers.</p>"},{"location":"tools/#mkdocs-plugin-for-rzk","title":"MkDocs plugin for Rzk","text":"<p>See rzk-lang/mkdocs-plugin-rzk. MkDocs plugin enhances documentation build from literate Rzk Markdown files: - adds diagram rendering (experimental) - adds definition anchors (helpful to have \"permalinks\" to definitions)</p>"},{"location":"tools/#github-action-for-rzk","title":"GitHub Action for Rzk","text":"<p>See rzk-lang/rzk-action. This action allows to check your Rzk formalizations on GitHub automatically. It can also be used to check formatting (experimental).</p>"},{"location":"tools/#syntax-highlighting-pygments-for-rzk","title":"Syntax highlighting (Pygments) for Rzk","text":"<p>See rzk-lang/pygments-rzk. This is a simple syntax highlighter for Pygments (used by MkDocs and <code>minted</code> package in LaTeX). Note that VS Code extension is using the Rzk Language Server for more accurate \"semantic highlighting\".</p>"},{"location":"examples/recId.rzk/","title":"Tope disjuction elimination along identity paths","text":"<p>\\(\\mathsf{rec}_{\\lor}^{\\\u03c8,\\\u03c6}(a_\\\u03c8, a*\\\u03c6)\\) (written <code>recOR(\u03c8, \u03c6, a_psi, a_phi)</code> in the code) is well-typed when \\(a*\\\u03c8\\) and \\(a*\\\u03c6\\) are _definitionally equal* on \\(\\\u03c8 \\land \\\u03c6\\). Sometimes this is too strong since many terms are not definitionally equal, but only equal up to a path. Luckily, assuming relative function extensionality, we can define a weaker version of \\(rec*{\\lor}\\) (<code>recOR</code>), which we call <code>recId</code>, that can work in presence of a witness of type \\(\\prod*{t : I \\mid \\\u03c8 \\land \\\u03c6} a*\\\u03c8 = a*\\\u03c6\\).</p>"},{"location":"examples/recId.rzk/#prerequisites","title":"Prerequisites","text":"<p>This file relies on some definitions, defined in</p> <ul> <li>Getting Started &gt; Dependent Types</li> </ul> <p>We begin by introducing common HoTT definitions:</p> <pre><code>#lang rzk-1\n-- A is contractible there exists x : A such that for any y : A we have x = y.\n#define iscontr (A : U)\n  : U\n  := \u03a3 ( a : A) , (x : A) \u2192 a =_{A} x\n\n-- A is a proposition if for any x, y : A we have x = y\n#define isaprop (A : U)\n  : U\n  := ( x : A) \u2192 (y : A) \u2192 x =_{A} y\n\n-- A is a set if for any x, y : A the type x =_{A} y is a proposition\n#define isaset (A : U)\n  : U\n  := ( x : A) \u2192 (y : A) \u2192 isaprop (x =_{A} y)\n\n-- A function f : A \u2192 B is an equivalence\n-- if there exists g : B \u2192 A\n-- such that for all x : A we have g (f x) = x\n-- and for all y : B we have f (g y) = y\n#define isweq (A : U) (B : U) (f : A \u2192 B)\n  : U\n  := \u03a3 ( g : B \u2192 A)\n  , prod\n    ( ( x : A) \u2192 g (f x) =_{A} x)\n    ( ( y : B) \u2192 f (g y) =_{B} y)\n\n-- Equivalence of types A and B\n#define weq (A : U) (B : U)\n  : U\n  := \u03a3 ( f : A \u2192 B)\n  , isweq A B f\n\n-- Transport along a path\n#define transport\n  ( A : U)\n  ( C : A \u2192 U)\n  ( x y : A)\n  ( p : x =_{A} y)\n  : C x \u2192 C y\n  := \\ cx \u2192 idJ(A , x , (\\ z q \u2192 C z) , cx , y , p)\n</code></pre>"},{"location":"examples/recId.rzk/#relative-function-extensionality","title":"Relative function extensionality","text":"<p>We can now define relative function extensionality. There are several formulations, we provide two, following Riehl and Shulman:</p> <pre><code>-- [RS17, Axiom 4.6] Relative function extensionality.\n#define relfunext\n  : U\n  := ( I : CUBE)\n  \u2192 ( \u03c8 : I \u2192 TOPE)\n  \u2192 ( \u03c6 : \u03c8 \u2192 TOPE)\n  \u2192 ( A : \u03c8 \u2192 U)\n  \u2192 ( ( t : \u03c8) \u2192 iscontr (A t))\n  \u2192 ( a : ( t : \u03c6) \u2192 A t)\n  \u2192 ( t : \u03c8) \u2192 A t [ \u03c6 t \u21a6 a t]\n\n-- [RS17, Proposition 4.8] A (weaker) formulation of function extensionality.\n#define relfunext2\n  : U\n  :=\n    ( I : CUBE)\n  \u2192 ( \u03c8 : I \u2192 TOPE)\n  \u2192 ( \u03c6 : \u03c8 \u2192 TOPE)\n  \u2192 ( A : \u03c8 \u2192 U)\n  \u2192 ( a : ( t : \u03c6) \u2192 A t)\n  \u2192 ( f : (t : \u03c8) \u2192 A t [ \u03c6 t \u21a6 a t ])\n  \u2192 ( g : ( t : \u03c8) \u2192 A t [ \u03c6 t \u21a6 a t ])\n  \u2192 weq\n    ( f = g)\n    ( ( t : \u03c8) \u2192 (f t =_{A t} g t) [ \u03c6 t \u21a6 refl ])\n</code></pre>"},{"location":"examples/recId.rzk/#construction-of-recid","title":"Construction of <code>recId</code>","text":"<p>The idea is straightforward. We ask for a proof that <code>a = b</code> for all points in <code>\u03c8 \u2227 \u03c6</code>. Then, by relative function extensionality (<code>relfunext2</code>), we can show that restrictions of <code>a</code> and <code>b</code> to <code>\u03c8 \u2227 \u03c6</code> are equal. If we reformulate <code>a</code> as extension of its restriction, then we can <code>transport</code> such reformulation along the path connecting two restrictions and apply <code>recOR</code>.</p> <p>First, we define how to restrict an extension type to a subshape:</p> <pre><code>#section construction-of-recId\n\n#variable r : relfunext2\n#variable I : CUBE\n#variables \u03c8 \u03c6 : I \u2192 TOPE\n#variable A : (t : I | \u03c8 t \u2228 \u03c6 t) \u2192 U\n\n-- Restrict extension type to a subshape.\n#define restrict_phi\n  ( a : ( t : \u03c6) \u2192 A t)\n  : ( t : I | \u03c8 t \u2227 \u03c6 t) \u2192 A t\n  := \\ t \u2192 a t\n\n-- Restrict extension type to a subshape.\n#define restrict_psi\n  ( a : ( t : \u03c8) \u2192 A t)\n  : ( t : I | \u03c8 t \u2227 \u03c6 t) \u2192 A t\n  := \\ t \u2192 a t\n</code></pre> <p>Then, how to reformulate an <code>a</code> (or <code>b</code>) as an extension of its restriction:</p> <pre><code>-- Reformulate extension type as an extension of a restriction.\n#define ext-of-restrict_psi\n  ( a : ( t : \u03c8) \u2192 A t)\n  : ( t : \u03c8)\n  \u2192 A t [ \u03c8 t \u2227 \u03c6 t \u21a6 restrict_psi a t ]\n  := a  -- type is coerced automatically here\n\n-- Reformulate extension type as an extension of a restriction.\n#define ext-of-restrict_phi\n  ( a : ( t : \u03c6) \u2192 A t)\n  : ( t : \u03c6)\n  \u2192 A t [ \u03c8 t \u2227 \u03c6 t \u21a6 restrict_phi a t ]\n  := a  -- type is coerced automatically here\n</code></pre> <p>Now, assuming relative function extensionality, we construct a path between restrictions:</p> <pre><code>-- Transform extension of an identity into an identity of restrictions.\n#define restricts-path\n  ( a_psi : (t : \u03c8) \u2192 A t)\n  ( a_phi : (t : \u03c6) \u2192 A t)\n  : ( e : (t : I | \u03c8 t \u2227 \u03c6 t) \u2192 a_psi t = a_phi t)\n  \u2192 restrict_psi a_psi = restrict_phi a_phi\n  :=\n  first\n  ( second\n    ( r I\n      ( \\ t \u2192 \u03c8 t \u2227 \u03c6 t)\n      ( \\ t \u2192 BOT)\n      ( \\ t \u2192 A t)\n      ( \\ t \u2192 recBOT)\n      ( \\ t \u2192 a_psi t)\n      ( \\ t \u2192 a_phi t)))\n</code></pre> <p>Finally, we bring everything together into <code>recId</code>:</p> <pre><code>-- A weaker version of recOR, demanding only a path between a and b:\n-- recOR(\u03c8, \u03c6, a, b) demands that for \u03c8 \u2227 \u03c6 we have a == b (definitionally)\n-- (recId \u03c8 \u03c6 a b e) demands that e is the proof that a = b (intensionally) for \u03c8 \u2227 \u03c6\n#define recId uses (r) -- we declare that recId is using r on purpose\n  ( a_psi : (t : \u03c8) \u2192 A t)\n  ( a_phi : (t : \u03c6) \u2192 A t)\n  ( e : (t : I | \u03c8 t \u2227 \u03c6 t) \u2192 a_psi t = a_phi t)\n  : ( t : I | \u03c8 t \u2228 \u03c6 t) \u2192 A t\n  := \\ t \u2192 recOR(\n        \u03c8 t \u21a6\n          transport\n          ( ( s : I | \u03c8 s \u2227 \u03c6 s) \u2192 A s)\n          ( \\ ra \u2192 (s : \u03c8) \u2192 A s [ \u03c8 s \u2227 \u03c6 s \u21a6 ra s ])\n          ( restrict_psi a_psi)\n          ( restrict_phi a_phi)\n          ( restricts-path a_psi a_phi e)\n          ( ext-of-restrict_psi a_psi)\n          ( t)\n      , \u03c6 t \u21a6\n          ext-of-restrict_phi a_phi t\n      )\n\n#end construction-of-recId\n</code></pre>"},{"location":"examples/recId.rzk/#gluing-extension-types","title":"Gluing extension types","text":"<p>An application of of <code>recId</code> is gluing together extension types, whenever we can show that they are equal on the intersection of shapes:</p> <pre><code>-- If two extension types are equal along two subshapes,\n-- then they are also equal along their union.\n#define id-along-border\n  ( r : relfunext2)\n  ( I : CUBE)\n  ( \u03c8 : I \u2192 TOPE)\n  ( \u03c6 : I \u2192 TOPE)\n  ( A : (t : I | \u03c8 t \u2228 \u03c6 t) \u2192 U)\n  ( a b : (t : I | \u03c8 t \u2228 \u03c6 t) \u2192 A t)\n  ( e_psi : (t : \u03c8) \u2192 a t = b t)\n  ( e_phi : (t : \u03c6) \u2192 a t = b t)\n  ( border-is-a-set : (t : I | \u03c8 t \u2227 \u03c6 t) \u2192 isaset (A t))\n  : ( t : I | \u03c8 t \u2228 \u03c6 t) \u2192 a t = b t\n  :=\n  recId r I \u03c8 \u03c6\n  ( \\ t \u2192 a t = b t)\n  ( e_psi)\n  ( e_phi)\n  ( \\ t \u2192 border-is-a-set t (a t) (b t) (e_psi t) (e_phi t))\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with Rzk","text":"<ol> <li>Install Rzk.</li> <li>Get a quick overview of Rzk language.</li> <li>Get through the introduction to dependent types in Rzk.</li> <li>Learn how to configure formalization projects in Rzk.</li> <li>Learn more about Rzk features in the Rzk Reference.</li> </ol>"},{"location":"getting-started/dependent-types.rzk/","title":"Dependent types","text":"<p>In this file we will look at Rzk primitives to work with dependent types.</p> <p>Reference material</p> <p>This page is mostly based on the introduction of dependent types in the HoTT Book (Sections 1.2\u20131.6), immediately introducing corresponding formalizations in Rzk and noting some differences.</p> <p>This is a literate Rzk file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"getting-started/dependent-types.rzk/#functions","title":"Functions","text":"<p>The type <code>(x : A) \u2192 B x</code> is the type of (dependent) functions with an argument of type <code>A</code> and, for each input <code>x</code>, the output type <code>B x</code>.</p> <p>As a simple example of a dependent function, consider the identity function:</p> <pre><code>#define identity\n  : ( A : U) \u2192 (x : A) \u2192 A\n  := \\ A x \u2192 x\n</code></pre> <p>Since we are not using <code>x</code> in the type of <code>identity</code>, we can simply write the type of the argument, without providing its name:</p> <pre><code>#define identity\u2081\n  : ( A : U) \u2192 A \u2192 A\n  := \\ A x \u2192 x\n</code></pre> <p>We can write this definition differently, by putting <code>(A : U)</code> into parameters (before <code>:</code>), and omitting it in the lambda abstraction:</p> <pre><code>#define identity\u2082\n  ( A : U)\n  : A \u2192 A\n  := \\ x \u2192 x\n</code></pre> <p>We could also move <code>x</code> into parameters as well, although this probably does not increase readability anymore:</p> <pre><code>#define identity\u2083\n  ( A : U)\n  ( x : A)\n  : A\n  := x\n</code></pre> <p>Another, less trivial example of a dependent function is the one that swaps the arguments of another function:</p> <pre><code>#define swap\n  ( A B C : U)\n  : ( A \u2192 B \u2192 C) \u2192 (B \u2192 A \u2192 C)\n  := \\ f \u2192 \\ b a \u2192 f a b\n</code></pre>"},{"location":"getting-started/dependent-types.rzk/#product-types","title":"Product types","text":"<p>Rzk does not have built-in product types, since they are a special case of \u03a3-types, which we will discuss soon. For now, we give definition of product types:</p> <pre><code>#define prod\n  ( A B : U)\n  : U\n  := \u03a3 ( _ : A) , B\n</code></pre> <p>The type <code>prod A B</code> corresponds to the product type \\(A \\times B\\). The <code>Unit</code> type corresponds to the type \\(\\mathbf{1}\\).</p> <p>The intended elements of <code>prod A B</code> are only pairs <code>(a, b) : prod A B</code> where <code>a : A</code> and <code>b : B</code>. Similarly, intended element of <code>Unit</code> is only <code>unit</code>. However, formally, this is not immediately true and instead is a theorem that we can prove.</p>"},{"location":"getting-started/dependent-types.rzk/#remark-on-type-formers","title":"Remark on type formers","text":"<p>Formally, we have the following constituents of the definition for product types and function types (for comparison):</p> <ol> <li> <p>Type formation:</p> <ul> <li><code>prod A B</code> is a type whenever <code>A</code> and <code>B</code> are types</li> <li><code>A \u2192 B</code> is a type whenever <code>A</code> and <code>B</code> are types</li> </ul> </li> <li> <p>Constructors (introduction rules):</p> <ul> <li><code>(x , y)</code> is a term of type <code>prod A B</code> whenever <code>x : A</code> and <code>y : B</code></li> <li><code>\\ x \u2192 y</code> is a term of type <code>A \u2192 B</code> whenever for any <code>x : A</code> we have <code>y : B</code></li> </ul> </li> <li> <p>Eliminators (elimination rules):</p> <ul> <li> <p>Given <code>z : prod A B</code>, we can project the first and second components:</p> <ul> <li><code>first z : A</code> and <code>second z : B</code></li> <li> <p>it is also possible to pattern match (deconstruct) in a function argument or when introducing a parameter, e.g.</p> <pre><code>#define swap-prod\u2081\n  ( A B : U)\n  : prod A B \u2192 prod B A\n  := \\ (x , y) \u2192 (y , x)\n\n#define swap-prod\u2082\n  ( A B : U)\n  ( (x , y) : prod A B)\n  : prod B A\n  := ( y , x)\n</code></pre> </li> <li> <p>more generally, eliminators come in a form of an induction principle, which we will discuss below   and can be defined in Rzk in terms of pattern matching or <code>first</code> and <code>second</code>:</p> <pre><code>#define ind-prod\n  ( A B : U)\n  ( C : prod A B \u2192 U)\n  ( f : (a : A) \u2192 (b : B) \u2192 C (a , b))\n  : (z : prod A B) \u2192 C z\n  := \\ (a , b) \u2192 f a b\n</code></pre> </li> </ul> </li> <li> <p>Given <code>f : A \u2192 B</code>, we can apply it to an argument of type <code>a : A</code>:</p> <ul> <li><code>f a : B</code></li> </ul> </li> </ul> <p>Built-in eliminators in Rzk</p> <p>Built-in eliminators in Rzk need to be always fully applied (e.g. <code>first</code> without an argument is invalid syntax!). Technically, this corresponds with the \"second presentation\" of type theory in Appendix A.2 of the HoTT Book. In practice, this is not always convenient for users, as we often want to curry some of these built-ins, so wrapper functions are introduced (by users), for example:</p> <pre><code>#define pr\u2081\n  ( A B : U)\n  : prod A B \u2192 A\n  := \\ p \u2192 first p\n</code></pre> </li> <li> <p>Computation rules:</p> <ul> <li>Projecting from a pair is computed as follows for any <code>x : A</code> and <code>y : B</code>:<ul> <li><code>first (x , y) \u2261 x</code></li> <li><code>second (x , y) \u2261 y</code></li> </ul> </li> <li>Applying an lambda abstraction is computed by substituting the argument into a body:</li> <li><code>(\\ x \u2192 y) a \u2261 y{x \u21a6 a}</code> when <code>a : A</code> and for all <code>x : A</code>, <code>y : B</code>.</li> </ul> </li> <li> <p>Uniqueness principle (optional):</p> <ul> <li>For any <code>z : prod A B</code>, we have <code>z \u2261 (first z, second z)</code></li> <li>This holds definitionally for product types and \u03a3-types in Rzk, but is provable in a weaker (propositional) form in HoTT Book</li> <li>For any function <code>f : A \u2192 B</code>, we have <code>f \u2261 \\ x \u2192 f x</code></li> </ul> </li> </ol>"},{"location":"getting-started/dependent-types.rzk/#recursion-principle","title":"Recursion principle","text":"<p>Following the HoTT Book, for each type former we can formalize its recursion principle. A recursion principle for type <code>T</code> is a function that allows to produce a result of arbitrary type <code>C</code> from a value of type <code>T</code>:</p> <pre><code>#define rec-T\n  ( C : U)\n  -- ... (parameters to the recursion principle)\n  : T \u2192 C\n</code></pre> <p>For example, for the product type <code>prod A B</code>, recursion principle looks like this:</p> <pre><code>#define rec-prod\n  ( A B : U)\n  ( C : U)\n  ( f : A \u2192 B \u2192 C)\n  : prod A B \u2192 C\n  := \\ ( a , b) \u2192 f a b\n</code></pre> <p>For the <code>Unit</code> type, recursion principle is trivial:</p> <pre><code>#define rec-Unit\n  ( C : U)\n  ( c : C)\n  : Unit \u2192 C\n  := \\ unit \u2192 c\n</code></pre>"},{"location":"getting-started/dependent-types.rzk/#induction-principle","title":"Induction principle","text":"<p>To define a dependent function out of a type, we use its induction principle, which can be seen as a dependent version of the recursion principle. An induction principle for type <code>T</code> is a function that allows to produce a result of arbitrary type <code>C z</code> from a value <code>z : T</code>:</p> <pre><code>#define ind-T\n  ( C : T \u2192 U)\n  -- ... (parameters to the induction principle)\n  : (z : T) \u2192 C z\n</code></pre> <p>For example, for the product type <code>prod A B</code>, induction principle looks like this:</p> <pre><code>#define ind-prod\n  ( A B : U)\n  ( C : prod A B \u2192 U)\n  ( f : (a : A) \u2192 (b : B) \u2192 C (a , b))\n  : ( z : prod A B) \u2192 C z\n  := \\ ( a , b) \u2192 f a b\n</code></pre> <p>We can use <code>ind-prod</code> to prove the uniqueness principle for products. Here we use the identity type, which we will cover later, but for now it is sufficient to know that there is always an element <code>refl_{x} : x =_{A} x</code> for any <code>x : A</code>.</p> <pre><code>#define uniq-prod\n  ( A B : U)\n  ( z : prod A B)\n  : ( first z , second z) =_{prod A B} z\n  := ind-prod A B\n      ( \\ z' \u2192 (first z' , second z') =_{prod A B} z') -- C\n      ( \\ a b \u2192 refl_{(a , b)})\n        -- C (a, b)\n        -- \u2261 ( \\ z' \u2192 (first z', second z') =_{prod A B} z') (a, b)\n        -- \u2261 (first (a, b), second (a, b)) =_{prod A B} (a, b)\n        -- \u2261 (a, second (a, b)) =_{prod A B} (a, b)\n        -- \u2261 (a, b) =_{prod A B} (a, b)\n      z\n</code></pre> <p>Since in Rzk the uniqueness principle is builtin, a simpler proof also works:</p> <pre><code>#define uniq-prod'\n  ( A B : U)\n  ( z : prod A B)\n  : ( first z , second z) =_{prod A B} z\n  := refl_{z} -- works in Rzk, not in HoTT Book, since in Rzk we have (first z, second z) \u2261 z\n</code></pre> <p>For the <code>Unit</code> type, induction principle is trivial:</p> <pre><code>#define ind-Unit\n  ( C : Unit \u2192 U)\n  ( c : C unit)\n  : ( z : Unit) \u2192 C z\n  := \\ unit \u2192 c\n</code></pre> <p>Unlike <code>rec-Unit</code>, induction principle for <code>Unit</code> is not useless, since it allows, for example, to prove the uniqueness principle:</p> <pre><code>#define uniq-Unit\n  ( z : Unit)\n  : unit =_{Unit} z\n  := ind-Unit\n      ( \\ z' \u2192 unit =_{Unit} z')\n      ( refl_{unit})\n      z\n</code></pre> <p>Again, since Rzk has a builtin uniqueness principle for <code>Unit</code>, a simpler proof also works:</p> <pre><code>#define uniq-Unit'\n  ( z : Unit)\n  : unit =_{Unit} z\n  := refl_{z} -- works in Rzk, not in HoTT Book, since in Rzk we have unit \u2261 z\n</code></pre>"},{"location":"getting-started/dependent-types.rzk/#dependent-pair-types-types","title":"Dependent pair types (\u03a3-types)","text":"<p>A straightforward generalization of product types to dependent pairs <code>\u03a3 (a : A), B a</code> where <code>A</code> is a type and <code>B : A \u2192 U</code> is a type family indexed in <code>A</code>.</p> <p>The indended values of <code>\u03a3 (a : A), B a</code> are pairs <code>(a , b)</code> of terms <code>a : A</code> and <code>b : B a</code>. Note that the type of the second component may depend on the value of the first component. When the type family <code>B</code> is constant, e.g. <code>(\\ _ \u2192 C)</code>, then <code>\u03a3 (a : A), B a</code> becomes exactly the product type <code>prod A C</code>.</p> <p>To eliminate dependent pairs, we use <code>first</code>, <code>second</code>, or pattern matching on pairs. However, the types of projections are less obvious compared to the case of product types.</p>"},{"location":"getting-started/dependent-types.rzk/#projections","title":"Projections","text":"<p>The first projection can be easily defined in terms of pattern matching:</p> <pre><code>#define pr\u2081\n  ( A : U)\n  ( B : A \u2192 U)\n  : ( \u03a3 ( a : A) , B a) \u2192 A\n  := \\ ( a , _) \u2192 a\n</code></pre> <p>However, second projection requires some care. For instance, we might try this:</p> <pre><code>-- NOTE: incorrect definition\n#define pr\u2082\n  ( A : U)\n  ( B : A \u2192 U)\n  : (\u03a3 (a : A), B a) \u2192 B a  -- ERROR!\n  := \\ (_ , b) \u2192 b\n</code></pre> <pre><code>undefined variable: a\n</code></pre> <p>We get the <code>undefined variable</code> error since <code>a</code> is not visible outside of \u03a3-type definition. To access it, we need a dependent function:</p> <pre><code>#define pr\u2082\n  ( A : U)\n  ( B : A \u2192 U)\n  : ( z : \u03a3 (a : A) , B a) \u2192 B (pr\u2081 A B z)\n  := \\ ( _ , b) \u2192 b\n</code></pre> <p>In Rzk, it is sometimes more convenient to talk about \u03a3-types as \"total\" types (as in \"total spaces\"):</p> <pre><code>#define total-type\n  ( A : U)\n  ( B : A \u2192 U)\n  : U\n  := \u03a3 ( a : A) , B a\n</code></pre> <p>We can use pattern matching in the function type and this new definition to write second projection slightly differently:</p> <pre><code>#define pr\u2082'\n  ( A : U)\n  ( B : A \u2192 U)\n  ( ( a , b) : total-type A B)\n  : B a\n  := b\n</code></pre>"},{"location":"getting-started/dependent-types.rzk/#recursion-and-induction-principles","title":"Recursion and induction principles","text":"<p>The recursion principle for \u03a3-types is a simple generalization of the recursion principle for product types:</p> <pre><code>#define rec-\u03a3\n  ( A : U)\n  ( B : A \u2192 U)\n  ( C : U)\n  ( f : (a : A) \u2192 B a \u2192 C)\n  : total-type A B \u2192 C\n  := \\ ( a , b) \u2192 f a b\n</code></pre> <p>The induction principle is, again, a generalization of the recursion principle to dependent types:</p> <pre><code>#define ind-\u03a3\n  ( A : U)\n  ( B : A \u2192 U)\n  ( C : total-type A B \u2192 U)\n  ( f : (a : A) \u2192 (b : B a) \u2192 C (a , b))\n  : ( z : total-type A B) \u2192 C z\n  := \\ ( a , b) \u2192 f a b\n</code></pre> <p>As before, using <code>ind-\u03a3</code> we may prove the uniqueness principle, now for \u03a3-types:</p> <pre><code>#define uniq-\u03a3\n  ( A : U)\n  ( B : A \u2192 U)\n  ( z : total-type A B)\n  : ( pr\u2081 A B z , pr\u2082 A B z) =_{total-type A B} z\n  := ind-\u03a3 A B\n      ( \\ z \u2192 (pr\u2081 A B z , pr\u2082 A B z) =_{total-type A B} z)\n      ( \\ a b \u2192 refl_{(a , b)})\n      z\n</code></pre> <p>And again, Rzk can accept a simpler proof, since uniqueness for \u03a3-types is already built into it:</p> <pre><code>#define uniq-\u03a3'\n  ( A : U)\n  ( B : A \u2192 U)\n  ( z : total-type A B)\n  : ( pr\u2081 A B z , pr\u2082 A B z) =_{total-type A B} z\n  := refl_{z} -- works in Rzk, but not in HoTT Book\n</code></pre>"},{"location":"getting-started/dependent-types.rzk/#type-theoretic-axiom-of-choice","title":"Type-theoretic \"axiom\" of choice","text":"<p>Using <code>ind-\u03a3</code> we can also prove a type-theoretic axiom of choice:</p> <pre><code>#define AxiomOfChoice\n  : U\n  := ( A : U)\n    \u2192 ( B : U)\n    \u2192 ( R : A \u2192 B \u2192 U)\n    \u2192 ( ( x : A) \u2192 \u03a3 (y : B) , R x y)\n    \u2192 ( \u03a3 ( f : A \u2192 B) , (x : A) \u2192 R x (f x))\n</code></pre> <p>You are encouraged to try proving this yourself first.</p> <p>If you encounter problems, try looking for the proof in the HoTT Book Section 1.6 (page 32).</p> <p>If you still have issues formalizing it in Rzk, you may peek here:</p> Proof of the type theoretic axiom of choice <pre><code>#define ac : AxiomOfChoice\n  := \\ A B R g \u2192 ( \\ a \u2192 first (g a) , \\ x \u2192 second (g x))\n  -- g    : (x : A) \u2192 \u03a3 (y : B), R x y\n  -- x    : A\n  -- g x  : \u03a3 (y : B), R x y\n  -- second (g x) : R x (first (g x))\n\n  -- f : A \u2192 B\n  -- f := \\ a \u2192 first (g a)\n  --\n  -- R x (f x)\n  -- == R x ((\\ a \u2192 first (g a)) x)\n  -- == R x (first (g x))\n</code></pre>"},{"location":"getting-started/dependent-types.rzk/#coproducts","title":"Coproducts","text":"<p>Given types \\(A\\) and \\(B\\) a coproduct type \\(A + B\\) corresponds intuitively to a disjoint union of \\(A\\) and \\(B\\) (in set theory). We also have a nullary version: \\(\\mathbf{0}\\) (empty type).</p> <p>In Rzk, empty type and coproduct types do not exist, but a weaker version can be postulated.</p>"},{"location":"getting-started/dependent-types.rzk/#postulating-the-empty-type","title":"Postulating the empty type","text":"<p>For example, an empty type can be postulated as follows:</p> <pre><code>#postulate Void\n  : U\n#postulate ind-Void\n  ( C : Void \u2192 U)\n  : ( z : Void) \u2192 C z\n</code></pre> <p>Since there should be no values of type <code>Void</code>, the induction principle corresponds to the principle that from falsehood anything follows. A non-dependent version of that corresponds to the recursion principle, which we can define in terms of <code>ind-Void</code>:</p> <pre><code>#define rec-Void\n  ( C : U)\n  : Void \u2192 C\n  := ind-Void (\\ _ \u2192 C)\n</code></pre>"},{"location":"getting-started/dependent-types.rzk/#postulating-the-coproduct-type","title":"Postulating the coproduct type","text":"<p>Postulating coproducts</p> <p>This subsection currently provides postulates with little explanation. Once Rzk has support for user-defined (higher) inductive types or built-in coproducts, this section will be updated.</p> <p>Similarly, we can postulate the coproduct:</p> <pre><code>#postulate coprod\n  ( A B : U)\n  : U\n</code></pre> <p>There are two ways to create a term of type <code>coprod A B</code> \u2014 inject a term from <code>A</code> or a term of <code>B</code>:</p> <pre><code>#postulate inl\n  ( A B : U)\n  : A \u2192 coprod A B\n#postulate inr\n  ( A B : U)\n  : B \u2192 coprod A B\n</code></pre> <p>To eliminate a coproduct, we have to provide two handlers \u2014 one for the left case and one for the right:</p> <pre><code>#postulate ind-coprod\n  ( A B : U)\n  ( C : coprod A B \u2192 U)\n  ( l : (a : A) \u2192 C (inl A B a))\n  ( r : (b : B) \u2192 C (inr A B b))\n  : ( z : coprod A B) \u2192 C z\n</code></pre> <p>Since we are postulating the induction principle, we also have to provide the computational rules explicitly. However, in Rzk, we can only postulate propositional computational rules:</p> <pre><code>#postulate ind-coprod-inl\n  ( A B : U)\n  ( C : coprod A B \u2192 U)\n  ( l : (a : A) \u2192 C (inl A B a))\n  ( r : (b : B) \u2192 C (inr A B b))\n  ( a : A)\n  : ind-coprod A B C l r (inl A B a) = l a\n\n#postulate ind-coprod-inr\n  ( A B : U)\n  ( C : coprod A B \u2192 U)\n  ( l : (a : A) \u2192 C (inl A B a))\n  ( r : (b : B) \u2192 C (inr A B b))\n  ( b : B)\n  : ind-coprod A B C l r (inr A B b) = r b\n</code></pre> <p>We can now define recursion for coproducts as a special case of induction:</p> <pre><code>#define rec-coprod\n  ( A B : U)\n  ( C : U)\n  ( l : A \u2192 C)\n  ( r : B \u2192 C)\n  : coprod A B \u2192 C\n  := ind-coprod A B (\\ _ \u2192 C) l r\n</code></pre> <p>The uniqueness principle for coproducts says that any coproduct is either an <code>inl</code> or an <code>inr</code>. Proving the uniqueness is fairly straightforward, except we have to provide some intermediate types explicitly:</p> <pre><code>#define uniq-coprod\n  ( A B : U)\n  ( z : coprod A B)\n  : coprod\n      ( \u03a3 ( a : A) , inl A B a = z)\n      ( \u03a3 ( b : B) , inr A B b = z)\n  := ind-coprod A B\n      ( \\ z' \u2192 coprod\n          ( \u03a3 ( a : A) , inl A B a = z')\n          ( \u03a3 ( b : B) , inr A B b = z'))\n      ( \\ a' \u2192 inl\n          ( \u03a3 ( a : A) , (inl A B a = inl A B a'))\n          ( \u03a3 ( b : B) , (inr A B b = inl A B a'))\n          ( a' , refl))\n      ( \\ b' \u2192 inr\n          ( \u03a3 ( a : A) , (inl A B a = inr A B b'))\n          ( \u03a3 ( b : B) , (inr A B b = inr A B b'))\n          ( b' , refl))\n      z\n</code></pre>"},{"location":"getting-started/dependent-types.rzk/#booleans","title":"Booleans","text":"<p>Postulating booleans</p> <p>This subsection currently provides postulates with little explanation. Once Rzk has support for user-defined (higher) inductive types or built-in booleans, this section will be updated.</p> <pre><code>#postulate Bool\n  : U\n#postulate false\n  : Bool\n#postulate true\n  : Bool\n</code></pre> <pre><code>#postulate ind-Bool\n  ( C : Bool \u2192 U)\n  ( f : C false)\n  ( t : C true)\n  : ( z : Bool) \u2192 C z\n</code></pre> <pre><code>#postulate ind-Bool-false\n  ( C : Bool \u2192 U)\n  ( f : C false)\n  ( t : C true)\n  : ind-Bool C f t false = f\n#postulate ind-Bool-true\n  ( C : Bool \u2192 U)\n  ( f : C false)\n  ( t : C true)\n  : ind-Bool C f t true = t\n</code></pre> <pre><code>#define rec-Bool\n  ( C : U)\n  ( f t : C)\n  : Bool \u2192 C\n  := ind-Bool (\\ _ \u2192 C) f t\n</code></pre> <pre><code>#define uniq-Bool\n  ( z : Bool)\n  : coprod (z = false) (z = true)\n  := ind-Bool\n      ( \\ z' \u2192 coprod (z' = false) (z' = true))\n      ( inl (false = false) (false = true) refl)\n      ( inr (true = false) (true = true) refl)\n      z\n</code></pre> <pre><code>#define not\n  : Bool \u2192 Bool\n  := rec-Bool Bool true false\n</code></pre> <p>Unfortunately, because computation rules are postulated in a weak form, they do not compute automatically and have to be used explicitly, so the following proof does not work:</p> <pre><code>#define not-not-is-identity\n  : (z : Bool) \u2192 not (not z) = z\n  := ind-Bool\n      ( \\ z \u2192 not (not z) = z)\n      ( refl)\n      ( refl)\n</code></pre> <p>There is a way to fix the proof, but we'll need to learn more about the identity types before we can do that.</p>"},{"location":"getting-started/dependent-types.rzk/#natural-numbers","title":"Natural numbers","text":"<p>Postulating natural numbers</p> <p>This subsection currently provides postulates without explanations. Once Rzk has support for user-defined (higher) inductive types or built-in natural numbers, this section will be updated.</p> <pre><code>#postulate \u2115\n  : U\n#postulate zero\n  : \u2115\n#postulate succ (n : \u2115)\n  : \u2115\n\n#postulate ind-\u2115\n  ( C : \u2115 \u2192 U)\n  ( base : C zero)\n  ( step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : ( n : \u2115) \u2192 C n\n\n#postulate ind-\u2115-zero\n  ( C : \u2115 \u2192 U)\n  ( base : C zero)\n  ( step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : ind-\u2115 C base step zero = base\n#postulate ind-\u2115-succ\n  ( C : \u2115 \u2192 U)\n  ( base : C zero)\n  ( step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  ( n : \u2115)\n  : ind-\u2115 C base step (succ n) = step n (ind-\u2115 C base step n)\n</code></pre> <pre><code>#define rec-\u2115\n  ( C : U)\n  ( base : C)\n  ( step : (n : \u2115) \u2192 C \u2192 C)\n  : \u2115 \u2192 C\n  := ind-\u2115 (\\ _ \u2192 C) base step\n</code></pre> <pre><code>#define double-\u2115\n  : \u2115 \u2192 \u2115\n  := rec-\u2115 \u2115 zero (\\ _ m \u2192 succ (succ m))\n</code></pre> <pre><code>#define compute-ind-\u2115-zero\n  ( C : \u2115 \u2192 U)\n  ( base : C zero)\n  ( step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : C zero\n  := base\n\n#define compute-ind-\u2115-one\n  ( C : \u2115 \u2192 U)\n  ( base : C zero)\n  ( step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : C (succ zero)\n  := step zero (compute-ind-\u2115-zero C base step)\n\n#define compute-ind-\u2115-two\n  ( C : \u2115 \u2192 U)\n  ( base : C zero)\n  ( step : (n : \u2115) \u2192 C n \u2192 C (succ n))\n  : C (succ (succ zero))\n  := step (succ zero) (compute-ind-\u2115-one C base step)\n\n#compute compute-ind-\u2115-two (\\ _ \u2192 \u2115) zero (\\ _ m \u2192 succ (succ m))\n</code></pre>"},{"location":"getting-started/install/","title":"How to install Rzk","text":""},{"location":"getting-started/install/#vs-code-extension-with-binaries-recommended","title":"VS Code extension with binaries (recommended)","text":"<p>These instructions will walk you through setting up Rzk using the \"basic\" setup and VS Code as the editor.</p> <ol> <li>Install VS Code.</li> <li>Launch VS Code and install the <code>rzk</code> extension.</li> <li>Create a new file using \"File &gt; New Text File\" (Ctrl+N). Click the <code>Select a language</code> prompt, type in <code>rzk</code>, and select \"Literate Rzk Markdown\".    </li> <li>You should see the following popup:    </li> <li>Click \"Yes\" button.</li> <li>While it is installing, you can paste the following literate Rzk program into the new file:</li> </ol> <pre><code># Sample literate Rzk markdown\n\n```rzk\n#lang rzk-1\n#define id (A : U)\n  : A -&gt; A\n  := \\ x -&gt; x\n```\n</code></pre> <ol> <li>When the installation is done you should see the following popup:    </li> <li>Click \"Reload button\".</li> <li>Save your file as <code>example.rzk.md</code>.</li> <li> <p>Open local Terminal (Ctrl+`).</p> </li> <li> <p>In the terminal, run</p> <pre><code>rzk typecheck example.rzk.md\n</code></pre> </li> <li> <p>You should see the output of the proof assistant:</p> <pre><code>Loading file example.rzk.md\nChecking module from example.rzk.md\n[ 1 out of 1 ] Checking #define id\nEverything is ok!\n</code></pre> </li> <li> <p>Congratulations! Now you have a working rzk setup :) Note that the rzk extension will notify you about updates of <code>rzk</code> and prompt updating to new versions.</p> </li> <li> <p>See Quickstart to get familiar with the Rzk language!</p> </li> </ol>"},{"location":"getting-started/install/#install-binaries","title":"Install binaries","text":""},{"location":"getting-started/install/#download-from-github","title":"Download from GitHub","text":"<p>You can download and use binaries (at least for some platforms) directly for one of the latest releases on GitHub at https://github.com/rzk-lang/rzk/releases. If your platform is not represented, please consider leaving an issue at https://github.com/rzk-lang/rzk/issues/new.</p>"},{"location":"getting-started/install/#install-from-sources","title":"Install from sources","text":"<p>You can install <code>rzk</code> from sources. You can get the latest \"stable\" release from Hackage or build from the <code>develop</code> branch on GitHub.</p>"},{"location":"getting-started/install/#stack","title":"Stack","text":"<p>To build and install with Stack from Hackage:</p> <pre><code>stack install rzk\n</code></pre> <p>To build and install with Stack from sources on GitHub:</p> <pre><code>git clone https://github.com/rzk-lang/rzk.git\ncd rzk\ngit checkout develop\nstack build &amp;&amp; stack install\n</code></pre>"},{"location":"getting-started/install/#cabal-install","title":"cabal-install","text":"<p>To build and install with <code>cabal-install</code> from Hackage:</p> <pre><code>cabal v2-update\ncabal v2-install rzk\n</code></pre> <p>To build and install with <code>cabal-install</code> from sources on GitHub:</p> <pre><code>git clone https://github.com/rzk-lang/rzk.git\ncd rzk\ngit checkout develop\ncabal v2-build &amp;&amp; cabal v2-install\n</code></pre>"},{"location":"getting-started/install/#nix","title":"Nix","text":"<p>Work-in-progress</p> <p>To be done.</p>"},{"location":"getting-started/project/","title":"Setting up an Rzk project","text":"<p>Work-in-progress</p> <p>Guide will be here soon. For now, please use the template project: https://github.com/rzk-lang/rzk-project-template. Also check out https://github.com/rzk-lang/sHoTT for an example of a project with generated documentation.</p>"},{"location":"getting-started/quickstart.rzk/","title":"Quick introduction into Rzk","text":"<p>Work-in-progress</p> <p>Documentation is a work in progress.</p> <p>First, install Rzk.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"reference/cube-layer.rzk/","title":"Cube layer","text":"<pre><code>#lang rzk-1\n</code></pre> <p>All cubes live in <code>CUBE</code> universe.</p> <p>There are two built-in cubes:</p> <ol> <li><code>1</code> cube is a unit cube with a single point <code>*_1</code></li> <li><code>2</code> cube is a directed interval cube with points <code>0_2</code> and <code>1_2</code></li> </ol> <p>It is also possible to have <code>CUBE</code> variables and make products of cubes:</p> <ol> <li><code>I * J</code>  is a product of cubes <code>I</code> and <code>J</code></li> <li><code>(t, s)</code> is a point in <code>I * J</code> if <code>t : I</code> and <code>s : J</code></li> <li>if <code>ts : I * J</code>, then <code>first ts : I</code> and <code>second ts : J</code></li> </ol> <p>You can usually use <code>(t, s)</code> both as a pattern, and a construction of a pair of points:</p> <pre><code>-- Swap point components of a point in a cube I \u00d7 I\n#define swap\n    ( I : CUBE)\n  : ( I \u00d7 I) \u2192 I \u00d7 I\n  := \\ ( t , s) \u2192 (s , t)\n</code></pre>"},{"location":"reference/extension-types.rzk/","title":"Extension types","text":"<ol> <li> <p>Extension types \\(\\left\\langle \\prod_{t : I \\mid \\psi} A \\vert ^{\\phi} _{a} \\right\\rangle\\) are written as <code>{t : I | psi t} -&gt; A [ phi |-&gt; a ]</code></p> <ul> <li>specifying <code>[ phi |-&gt; a ]</code> is optional, semantically defaults to <code>[ BOT |-&gt; recBOT ]</code> (like in RSTT);</li> <li>specifying <code>psi</code> in <code>{t : I | psi}</code> is mandatory;</li> <li>values of function types are \\(\\lambda\\)-abstractions written in one of the following ways:<ul> <li><code>\\t -&gt; &lt;body&gt;</code> \u2014 this is usually fine;</li> <li><code>\\{t : I | psi} -&gt; &lt;body&gt;</code> \u2014 this sometimes helps the typechecker;</li> </ul> </li> </ul> </li> <li> <p>Types of functions from a shape \\(\\prod_{t : I \\mid \\psi} A\\) are a specialised variant of extension types and are written <code>{t : I | psi} -&gt; A</code></p> <ul> <li>specifying the name of the argument is mandatory; i.e. <code>{I | psi} -&gt; A</code> is invalid syntax!</li> <li>values of function types are \\(\\lambda\\)-abstractions written in one of the following ways:<ul> <li><code>\\t -&gt; &lt;body&gt;</code> \u2014 this is usually fine;</li> <li><code>\\{t : I | psi} -&gt; &lt;body&gt;</code> \u2014 this sometimes helps the typechecker;</li> </ul> </li> </ul> </li> </ol> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> </ol>"},{"location":"reference/introduction.rzk/","title":"Introduction","text":"<p><code>rzk</code> is an experimental proof assistant for synthetic \u221e-categories. <code>rzk-1</code> is an early version of the language supported by <code>rzk</code>. The language is based on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb<sup>1</sup>. In this section, we introduce syntax, discuss features and some of the current limitations of the proof assistant.</p> <p>Overall, a program in <code>rzk-1</code> consists of a language pragma (specifying that we use <code>rzk-1</code> and not one of the other languages<sup>2</sup>) followed by a sequence of commands. For now, we will only use <code>#define</code> command.</p> <p>Here is a small formalisation in an MLTT subset of <code>rzk-1</code>:</p> <pre><code>#lang rzk-1\n-- Flipping the arguments of a function.\n#define flip\n    (A B : U)                         -- For any types A and B\n    (C : (x : A) -&gt; (y : B) -&gt; U)     -- and a type family C\n    (f : (x : A) -&gt; (y : B) -&gt; C x y) -- given a function f : A -&gt; B -&gt; C\n  : (y : B) -&gt; (x : A) -&gt; C x y       -- we construct a function of type B -&gt; A -&gt; C\n  := \\y x -&gt; f x y    -- by swapping the arguments\n\n-- Flipping a function twice is the same as not doing anything\n#define flip-flip-is-id\n    (A B : U)                         -- For any types A and B\n    (C : (x : A) -&gt; (y : B) -&gt; U)     -- and a type family C\n    (f : (x : A) -&gt; (y : B) -&gt; C x y) -- given a function f : A -&gt; B -&gt; C\n  : f = flip B A (\\y x -&gt; C x y)\n          (flip A B C f)              -- flipping f twice is the same as f\n  := refl                             -- proof by reflexivity\n</code></pre> <p>Let us explain parts of this code:</p> <ol> <li><code>#lang rzk-1</code> specifies that we are in using <code>rzk-1</code> language;</li> <li><code>--</code> starts a comment line (until the end of the line);</li> <li><code>#define \u00abname\u00bb : \u00abtype\u00bb := \u00abterm\u00bb</code> defines a name <code>\u00abname\u00bb</code> to be equal to <code>\u00abterm\u00bb</code>; the proof assistant will typecheck <code>\u00abterm\u00bb</code> against type <code>\u00abtype\u00bb</code>;</li> <li>We define two terms here \u2014 <code>flip</code> and <code>flip-flip-is-id</code>;</li> <li><code>flip</code> is a function that takes 4 arguments and returns a function of two arguments.</li> <li><code>flip-flip-is-id</code> is a function that takes two types, a type family, and a function <code>f</code> and returns a value of an identity type <code>flip ... (flip ... f) = f</code>, indicating that flipping a function <code>f</code> twice gets us back to <code>f</code>.</li> </ol> <p>Similarly to the three layers in Riehl and Shulman's type theory, <code>rzk-1</code> has 3 universes:</p> <ul> <li><code>CUBE</code> is the universe of cubes, corresponding to the cube layer;</li> <li><code>TOPE</code> is the universe of topes, corresponding to the tope layer;</li> <li><code>U</code> is the universe of types, corresponding to the types and terms layer.</li> </ul> <p>These are explained in the following sections.</p>"},{"location":"reference/introduction.rzk/#soundness","title":"Soundness","text":"<p><code>rzk-1</code> assumes \"type-in-type\", that is <code>U</code> has type <code>U</code>. This is known to make the type system unsound (due to Russell and Curry-style paradoxes), however, it is sometimes considered acceptable in proof assistants. And, since it simplifies implementation, <code>rzk-1</code> embraces this assumption, at least for now.</p> <p>Moreover, <code>rzk-1</code> does not prevent cubes or topes to depend on types and terms. For example, the following definition typechecks:</p> <pre><code>#define weird\n    (A : U)\n    (I : A -&gt; CUBE)\n    (x y : A)\n  : CUBE\n  := I x * I y\n</code></pre> <p>This likely leads to another inconsistency, but it will probably not lead to bugs in actual proofs of interest, so current version embraces this lax treatment of universes.</p> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> <li> <p>In version :octicons-tag-24: v0.1.0, <code>rzk</code> has supported simply typed lambda calculus, PCF, and MLTT. However, those languages have been removed.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/render.rzk/","title":"Rendering Diagrams","text":"<p>Starting from version <code>0.3.0</code>, <code>rzk</code> supports rendering of topes, types, and terms as diagrams.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>To enable rendering, enable option <code>\"render\" = \"svg\"</code> (to disable, <code>\"render\" = \"none\"</code>):</p> <pre><code>#set-option \"render\" = \"svg\"  -- enable rendering in SVG\n</code></pre> <p>Rendering is completely automatic, and works in the following situations:</p> <ol> <li>Mapping from a shape (including curried mappings), up to 3 dimensions, only in products of <code>2</code> cubes;</li> <li>Type of mapping from a shape (including curried mappings), up to 3 dimensions, only in products of <code>2</code> cubes.</li> <li>Mappings from a shape that is a section of an existing shape.</li> </ol> <p>The rendering assigns the following colors:</p> <ul> <li>purple is assigned for parameters (context) variables;</li> <li>blue is used for fillings for types (e.g. for <code>hom</code> and <code>hom2</code>);</li> <li>red is used for terms (e.g. <code>Segal-comp-witness</code>);</li> <li>orange is used for shapes in the tope layer;</li> <li>grey is used for discarded parts of a (larger) mapping (e.g. when extracting a diagonal/face from a larger shape).</li> </ul> <p>The SVG pictures can be inserted directly into <code>.md</code> files before a corresponding <code>rzk</code> code block. At the bottom of a markdown file, you might want to add stylization, e.g.:</p> <pre><code>&lt;style&gt;\n.rzk-render { transition: transform .2s; /* Animation */ }\n.rzk-render:hover { transform: scale(1.5); /* (150% zoom - Note: if the zoom is too large, it will go outside of the viewport) */ }\n&lt;/style&gt;\n\n&lt;!-- Definitions for the SVG images above --&gt;\n&lt;svg width=\"0\" height=\"0\"&gt;\n  &lt;defs&gt;\n    &lt;style data-bx-fonts=\"Noto Serif\"&gt;@import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap);&lt;/style&gt;\n    &lt;marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"5\" refY=\"5\"\n      markerWidth=\"5\" markerHeight=\"5\" orient=\"auto-start-reverse\"&gt;\n      &lt;path d=\"M 0 2 L 5 5 L 0 8 z\" stroke=\"purple\" fill=\"purple\" /&gt;\n    &lt;/marker&gt;\n  &lt;/defs&gt;\n  &lt;style&gt;\n    text, textPath {\n      font-family: Noto Serif;\n      font-size: 28px;\n      dominant-baseline: middle;\n      text-anchor: middle;\n    }\n  &lt;/style&gt;\n&lt;/svg&gt;\n</code></pre>"},{"location":"reference/render.rzk/#examples","title":"Examples","text":""},{"location":"reference/render.rzk/#visualising-simplicial-topes","title":"Visualising Simplicial Topes","text":"<p>Topes are visualised with orange color:</p> <p> \u2022 \u2022 \u2022 </p> <p><pre><code>-- 2-simplex\n#define \u0394\u00b2 : (2 * 2) -&gt; TOPE\n  := \\(t, s) -&gt; s &lt;= t\n</code></pre>  Boundary of a tope:</p> <p> \u2022 \u2022 \u2022 </p> <pre><code>-- boundary of a 2-simplex\n#define \u2202\u0394\u00b2 : \u0394\u00b2 -&gt; TOPE\n  := \\(t, s) -&gt; s === 0_2 \\/ t === 1_2 \\/ s === t\n</code></pre> <p>The busiest tope diagram involves the entire 3D cube: </p> <p> \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 </p> <p><pre><code>-- 3-dim cube\n#define 2\u00b3 : (2 * 2 * 2) -&gt; TOPE\n  := \\_ -&gt; TOP\n</code></pre> </p> <p> \u2022 \u2022 \u2022 \u2022 </p> <pre><code>-- 3-simplex\n#define \u0394\u00b3 : (2 * 2 * 2) -&gt; TOPE\n  := \\((t1, t2), t3) -&gt; t3 &lt;= t2 /\\ t2 &lt;= t1\n</code></pre> <p></p>"},{"location":"reference/render.rzk/#visualising-simplicial-types","title":"Visualising Simplicial Types","text":"<p>Types are visualised with blue color. Recognised parameter part (e.g. fixed endpoints, edges, faces with clear labels) are visualised with purple color. When a type is constructed by taking a part of another shape, the rest of the larger shape is colored using gray color.</p> <p> x y </p> <pre><code>-- [RS17, Definition 5.1]\n-- The type of arrows in A from x to y.\n#define hom\n  (A : U)   -- A type.\n  (x y : A) -- Two points in A.\n  : U                   -- (hom A x y) is a 1-simplex (an arrow)\n  := (t : 2) -&gt; A [    -- in A where\n    t === 0_2 |-&gt; x,    -- * the left endpoint is exactly x\n    t === 1_2 |-&gt; y     -- * the right endpoint is exactly y\n  ]\n</code></pre> <p> f f h h g g x y z </p> <pre><code>-- [RS17, Definition 5.2]\n-- the type of commutative triangles in A\n#define hom2\n  (A : U)           -- A type.\n  (x y z : A)       -- Three points in A.\n  (f : hom A x y)   -- An arrow in A from x to y.\n  (g : hom A y z)   -- An arrow in A from y to z.\n  (h : hom A x z)   -- An arrow in A from x to z.\n  : U                           -- (hom2 A x y z f g h) is a 2-simplex (triangle)\n  := { (t1, t2) : \u0394\u00b2 } -&gt; A [   -- in A where\n    t2 === 0_2 |-&gt; f t1,        -- * the top edge is exactly f,\n    t1 === 1_2 |-&gt; g t2,        -- * the right edge is exactly g, and\n    t2 === t1  |-&gt; h t2         -- * the diagonal is exactly h\n  ]\n</code></pre>"},{"location":"reference/render.rzk/#visualising-terms-of-simplicial-types","title":"Visualising Terms of Simplicial Types","text":"<p>Terms (with non-trivial labels) are visualised with red color (you can see a detailed label on hover). Recognised parameter part (e.g. fixed endpoints, edges, faces with clear labels) are visualised with purple color. When a term is constructed by taking a part of another shape, the rest of the larger shape is colored using gray color.</p> <p>We can visualise terms that fill a shape:</p> <p> recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 \u2022 \u2022 \u2022 \u2022 </p> <pre><code>#define square\n  (A : U)\n  (x y z : A)\n  (f : hom A x y)\n  (g : hom A y z)\n  (h : hom A x z)\n  (a : Sigma (h' : hom A x z), hom2 A x y z f g h')\n  : (2 * 2) -&gt; A\n  := \\(t, s) -&gt; recOR( s &lt;= t |-&gt; second a (t, s) , t &lt;= s |-&gt; second a (s, t))\n</code></pre> <p>If a term is extracted as a part of a larger shape, generally, the whole shape will be shown (in gray):</p> <p> \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2081 a (\u03c0\u2082 x\u2085) \u03c0\u2081 a (\u03c0\u2082 x\u2085) x x f f \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2081 a (\u03c0\u2082 x\u2085) y y \u03c0\u2081 a (\u03c0\u2082 x\u2085) z z \u03c0\u2081 a (\u03c0\u2082 x\u2085) x x y y z y z </p> <pre><code>#define face\n  (A : U)\n  (x y z : A)\n  (f : hom A x y)\n  (a : Sigma (g : hom A y z), {((t1, t2), t3) : 2 * 2 * 2 | t3 &lt;= t1 \\/ t2 &lt;= t1} -&gt; A [ t1 === 0_2 |-&gt; f t2, t1 === 1_2 |-&gt; g t3 ])\n  : \u0394\u00b2 -&gt; A\n  := \\(t, s) -&gt; second a ((t, t), s)\n</code></pre> <p> <p></p>"},{"location":"reference/sections.rzk/","title":"Sections and Variables","text":"<p>Sections and variables allow to simplify definitions by factoring out common assumptions.</p> <p>Coq-style variables</p> <p><code>rzk</code> implements variables similarly to <code>Variable</code> command in Coq. An important difference is that <code>rzk</code> does not allow definitions to use variables implicitly and adds <code>uses (...)</code> annotations to ensure such dependencies are not accidental. This is, perhaps, somewhat related to this error message in Coq.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"reference/sections.rzk/#variables","title":"Variables","text":"<p>Consider the following definitions:</p> <pre><code>#define compose\u2081\n  (A B C : U)\n  (g : B -&gt; C)\n  (f : A -&gt; B)\n  : A -&gt; C\n  := \\x -&gt; g (f x)\n\n#define twice\u2081\n  (A : U)\n  (h : A -&gt; A)\n  : A -&gt; A\n  := \\x -&gt; h (h x)\n</code></pre> <p>Since it might be common to introduce types <code>A</code>, <code>B</code>, and <code>C</code>, we can declare these are variables:</p> <pre><code>#variables A B C : U\n\n#define compose\u2082\n  (g : B -&gt; C)\n  (f : A -&gt; B)\n  : A -&gt; C\n  := \\x -&gt; g (f x)\n\n#define twice\u2082\n  (h : A -&gt; A)\n  : A -&gt; A\n  := \\x -&gt; h (h x)\n</code></pre> <p>The <code>#variables</code> command here introduces assumptions, which can be used in the following definitions. Importantly, after checking a file (module), all definitions will have the assumptions used (explicitly or implicitly) attached as bound variables.</p>"},{"location":"reference/sections.rzk/#implicitly-used-variables-and-uses","title":"Implicitly used variables (and <code>uses</code>)","text":"<p>We can try going even further and declare variables <code>f</code>, <code>g</code>, <code>h</code>, and <code>x</code>:</p> <pre><code>#variable g : B -&gt; C\n#variable f : A -&gt; B\n#variable h : A -&gt; A\n#variable x : A\n\n-- #define bad-compose\u2083 : C := g (f x)  -- ERROR: implicit assumptions A and B\n#define twice\u2083 : A := h (h x)\n</code></pre> <p>Note how this definition of <code>bad-compose\u2083</code> is implicitly dependent on the types <code>A</code> and <code>B</code>, which is promptly noted by <code>rzk</code>, which issues an error (if we uncomment the corresponding line):</p> <pre><code>implicit assumption\n  B : U\nused in definition of\n  bad-compose\u2083\n</code></pre> <p>To let <code>rzk</code> know that this is not accidental, we can add <code>uses (...)</code> annotation to specify a list of variables implicitly used in the definition:</p> <pre><code>#define compose\u2083 uses (A B) : C := g (f x)\n</code></pre>"},{"location":"reference/sections.rzk/#sections","title":"Sections","text":"<p>To introduce assumption variables temporarily inside of one file, you can use sections:</p> <pre><code>#section example-1\n\n#variables X Y Z : U\n#variable k : X -&gt; X\n#variable x' : X\n\n#define compose\u2084\n  (g : Y -&gt; Z)\n  (f : X -&gt; Y)\n  : X -&gt; Z\n  := \\x -&gt; g (f x)\n\n#define twice\u2084 : X := k (k x')\n\n#end example-1\n</code></pre> <p>Now, once outside of the section, <code>compose\u2084</code> and <code>twice\u2084</code> obtain corresponding parameters (only those used, explicitly or implicitly):</p> <pre><code>-- compose\u2084 : (X : U) -&gt; (Y : U) -&gt; (Z : U) -&gt; (g : Y -&gt; Z) -&gt; (f : X -&gt; Y) -&gt; (X -&gt; Z)\n-- twice\u2084 : (X : U) -&gt; (k : X -&gt; X) -&gt; (x' : X) -&gt; X\n\n#define twice\u2085\n  (T : U)\n  (e : T -&gt; T)\n  : T -&gt; T\n  := compose\u2084 T T T e e\n\n#define identity\n  (T : U)\n  : T -&gt; T\n  := twice\u2084 T (\\t -&gt; t)\n</code></pre> <p>Lack of indentation</p> <p><code>rzk</code> currently does not support indentation, so all definitions and commands inside a section (including nested sections) have to start at the beginning of a line.</p>"},{"location":"reference/tope-disjunction-elimination.rzk/","title":"Tope disjuction elimination","text":"<p>Following Riehl and Shulman's type theory<sup>1</sup>, <code>rzk-1</code> introduces two primitive terms for disjunction elimination:</p> <ol> <li> <p><code>recBOT</code> corresponds to \\(\\mathsf{rec}_\\bot\\), has any type, and is valid whenever tope context is included in <code>BOT</code>;</p> </li> <li> <p><code>recOR(\u00abtope_1\u00bb |-&gt; \u00abterm_1\u00bb, ..., \u00abtope_n\u00bb |-&gt; \u00abterm_n\u00bb)</code> defines a term for a disjunction of topes <code>\u00abtope_1\u00bb \\/ ... \\/ \u00abtope_n\u00bb</code>. This is well-typed when for an intersection of any two topes <code>\u00abtope_i\u00bb /\\ \u00abtope_j\u00bb</code> the corresponding terms <code>\u00abterm_i\u00bb</code> and <code>\u00abterm_j\u00bb</code> are judgementally equal. In particular, <code>recOR(psi |-&gt; a_psi, phi |-&gt; a_phi)</code> corresponds to \\(\\mathsf{rec}_\\lor^{\\psi, \\phi}(a_\\psi, a_\\phi)\\).</p> </li> </ol> <p>Deprecated syntax</p> <p><code>recOR(psi, phi, a_psi, a_phi)</code> corresponds to \\(\\mathsf{rec}_\\lor^{\\psi, \\phi}(a_\\psi, a_\\phi)\\), is well-typed when <code>a_psi</code> is definitionally equal to <code>a_phi</code> under <code>psi /\\ phi</code>. However, this syntax is deprecated since it is easy to confuse which tope relates to which term.</p> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> </ol>"},{"location":"reference/tope-layer.rzk/","title":"Tope layer","text":"<p>All topes live in <code>TOPE</code> universe.</p> <p>Here are all the ways to build a tope:</p> <ol> <li> <p>Introduce a variable, e.g. <code>(psi : TOPE) -&gt; ...</code>;</p> <ul> <li>Usually, topes depend on point variables from some cube(s). To indicate that, we usually introduce topes as \"functions\" from some cube to <code>TOPE</code>. For example, <code>(psi : I -&gt; TOPE) -&gt; ...</code>.</li> </ul> </li> <li> <p>Use a constant:</p> <ul> <li>top tope \\(\\top\\) is written <code>TOP</code></li> <li>bottom tope \\(\\bot\\) is written <code>BOT</code></li> </ul> </li> <li> <p>Usa a tope connective:</p> <ul> <li>tope conjunction \\(\\psi \\land \\phi\\) is written <code>psi /\\ phi</code></li> <li>tope disjunction \\(\\psi \\lor \\phi\\) is written <code>psi \\/ phi</code></li> <li>equality tope \\(t \\equiv s\\) is written <code>t === s</code>, whenever <code>t</code> and <code>s</code> are points of the same cube</li> <li>inequality tope \\(t \\leq s\\) is written <code>t &lt;= s</code> whenever <code>t : 2</code> and <code>s : 2</code></li> </ul> </li> </ol>"},{"location":"reference/type-layer.rzk/","title":"Types and terms","text":"<pre><code>#lang rzk-1\n</code></pre>"},{"location":"reference/type-layer.rzk/#functions-dependent-products","title":"Functions (dependent products)","text":"<p>Function (dependent product) types \\(\\prod_{x : A} B\\) are written <code>(x : A) -&gt; B x</code>. Values of function types are \\(\\lambda\\)-abstractions written in one of the following ways:</p> <ul> <li><code>\\x -&gt; &lt;body&gt;</code> \u2014 this is usually fine;</li> <li><code>\\(x : A) -&gt; &lt;body&gt;</code> \u2014 this sometimes helps the typechecker.</li> </ul>"},{"location":"reference/type-layer.rzk/#dependent-sums","title":"Dependent sums","text":"<p>Dependent sum type \\(\\sum_{x : A} B\\) is written <code>\u2211 (x : A), B</code> or <code>Sigma (x : A), B</code>. Values of dependent sum types are pairs written as <code>(x, y)</code>.</p> <p>To access components of a dependent pair <code>p</code>, use <code>first p</code> and <code>second p</code>.</p> <p>Warning</p> <p><code>first</code> and <code>second</code> are not valid syntax without an argument!</p>"},{"location":"reference/type-layer.rzk/#identity-types","title":"Identity types","text":"<p>Identity (path) type \\(x =_A y\\) is written <code>x =_{A} y</code>.</p> <p>Tip</p> <p>Specifying the type <code>A</code> is optional: <code>x = y</code> is valid syntax!</p> <p>Any identity type has value <code>refl_{x : A}</code> whose type is <code>x =_{A} x</code> whenever <code>x : A</code></p> <p>Tip</p> <p>Specifying term and type of <code>refl_{x : A}</code> is optional: <code>refl_{x}</code> and <code>refl</code> are both valid syntax.</p> <p>Path induction is done using \\(\\mathcal{J}\\) path eliminator:</p> <ul> <li>for<ul> <li>any type \\(A\\) and \\(a : A\\),</li> <li>type family \\(C : \\prod_{x : A} ((a =_A x) \\to \\mathcal{U})\\) and</li> <li>\\(d : C(a,\\mathsf{refl}_a)\\) and</li> <li>\\(x : A\\) and \\(p : a =_A x\\)</li> </ul> </li> <li>we have \\(\\mathcal{J}(A, a, C, d, x, p) : C(x, p)\\)</li> </ul> <p>In <code>rzk-1</code> we write <code>idJ(A, a, C, d, x, p)</code></p> <p>Warning</p> <p><code>idJ</code> is not valid syntax without exactly 6-tuple provided as an argument!</p>"},{"location":"reference/builtins/unit.rzk/","title":"Unit type","text":"<p>Since :octicons-tag-24: v0.5.1</p> <pre><code>#lang rzk-1\n</code></pre> <p>In the syntax, only <code>Unit</code> (the type) and <code>unit</code> (the only inhabitant) are provided. Everything else should be available from computation rules. More specifically, <code>rzk</code> takes the uniqueness property of the <code>Unit</code> type (see Section 1.5 of the HoTT book<sup>1</sup>) as the computation rule, meaning that any (well-typed) term of type <code>Unit</code> reduces to <code>unit</code>. This means in particular, that induction and uniqueness can be defined very easily:</p> <pre><code>#define ind-Unit\n  (C : Unit -&gt; U)\n  (C-unit : C unit)\n  (x : Unit)\n  : C x\n  := C-unit\n\n#define uniq-Unit\n  (x : Unit)\n  : x = unit\n  := refl\n\n#define isProp-Unit\n  (x y : Unit)\n  : x = y\n  := refl\n</code></pre> <p>As a non-trivial example, here is a proof that <code>Unit</code> is a Segal type:</p> <pre><code>#section isSegal-Unit\n\n#variable extext : ExtExt\n\n#define iscontr-Unit : isContr Unit\n  := (unit, \\_ -&gt; refl)\n\n#define isContr-\u0394\u00b2\u2192Unit uses (extext)\n  : isContr (\u0394\u00b2 -&gt; Unit)\n  := (\\_ -&gt; unit, \\k -&gt; eq-ext-htpy extext\n    (2 * 2) \u0394\u00b2 (\\_ -&gt; BOT)\n    (\\_ -&gt; Unit) (\\_ -&gt; recBOT)\n    (\\_ -&gt; unit) k\n    (\\_ -&gt; refl)\n    )\n\n#define isSegal-Unit uses (extext)\n  : isSegal Unit\n  := \\x y z f g -&gt; isRetract-ofContr-isContr\n    (\u2211 (h : hom Unit x z), hom2 Unit x y z f g h)\n    (\u0394\u00b2 -&gt; Unit)\n    (\\(_, k) -&gt; k, (\\k -&gt; (\\t -&gt; k (t, t), k), \\_ -&gt; refl))\n    isContr-\u0394\u00b2\u2192Unit\n\n#end isSegal-Unit\n</code></pre> <ol> <li> <p>The Univalent Foundations Program (2013). Homotopy Type Theory: Univalent Foundations of Mathematics. https://homotopytypetheory.org/book \u21a9</p> </li> </ol>"}]}
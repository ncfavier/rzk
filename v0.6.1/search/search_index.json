{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rzk \u2014 an experimental proof assistant for synthetic \u221e-categories","text":"<p><code>rzk</code> is an early prototype of a proof assistant for a family of type systems, including Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb (https://arxiv.org/abs/1705.07442).</p>"},{"location":"examples/hom.rzk/","title":"Hom-type","text":"<pre><code>hom : (A : U) -&gt; (x : A) -&gt; (y : A) -&gt; U\n  := \\A -&gt; \\x -&gt; \\y -&gt; &lt;{t : 2 | TOP} -&gt; A [ t === 0_2 \\/ t === 1_2 |-&gt; recOR(t === 0_2, t === 1_2, x, y) ]&gt;\n</code></pre> <pre><code>RS17:Prop:3.5a : (A : U) -&gt; (f : &lt;{t : 2 | TOP} -&gt; A[BOT |-&gt; recBOT]&gt;) -&gt; &lt;{ts : 2 * 2 | TOP} -&gt; A [BOT |-&gt; recBOT]&gt;\n  := \\(A : U) -&gt; \\(f : &lt;{t : 2 | TOP} -&gt; A[BOT |-&gt; recBOT]&gt;) -&gt; \\{ts : 2 * 2 | TOP} -&gt; recOR ((first ts) &lt;= (second ts), (second ts) &lt;= (first ts), f (second ts), f (first ts))\nRS17:Prop:3.5b : (A : U) -&gt; (f : &lt;{t : 2 | TOP} -&gt; A[BOT |-&gt; recBOT]&gt;) -&gt; &lt;{ts : 2 * 2 | TOP} -&gt; A [BOT |-&gt; recBOT]&gt;\n  := \\(A : U) -&gt; \\(f : &lt;{t : 2 | TOP} -&gt; A[BOT |-&gt; recBOT]&gt;) -&gt; \\{ts : 2 * 2 | TOP} -&gt; recOR ((first ts) &lt;= (second ts), (second ts) &lt;= (first ts), f (first ts), f (second ts))\n</code></pre> <pre><code>isShapeRetraction : (I : CUBE) -&gt; (A : U) -&gt; (phi : (t : I) -&gt; TOPE) -&gt; (psi : (t : I) -&gt; TOPE) -&gt; (f : (k : &lt;{t : I | psi t} -&gt; A [BOT |-&gt; recBOT]&gt;) -&gt; &lt;{t : I | phi t} -&gt; A [BOT |-&gt; recBOT]&gt;) -&gt; U\n  := \\(I : CUBE) -&gt; \\(A : U) -&gt; \\(phi : (t : I) -&gt; TOPE) -&gt; \\(psi : (t : I) -&gt; TOPE) -&gt; \\(f : (k : &lt;{t : I | psi t} -&gt; A [BOT |-&gt; recBOT]&gt;) -&gt; &lt;{t : I | phi t} -&gt; A [BOT |-&gt; recBOT]&gt;) -&gt; \u2211 (g : (k : &lt;{t : I | phi t} -&gt; A [BOT |-&gt; recBOT]&gt;) -&gt; &lt;{t : I | psi t} -&gt; A [BOT |-&gt; recBOT]&gt;), (k : &lt;{t : I | phi t} -&gt; A [BOT |-&gt; recBOT]&gt;) -&gt; f (g k) =_{&lt;{t : I | phi t} -&gt; A [BOT |-&gt; recBOT]&gt;} k\nshapeRetract : (I : CUBE) -&gt; (phi : (t : I) -&gt; TOPE) -&gt; (psi : (t : I) -&gt; TOPE) -&gt; U\n  := \\(I : CUBE) -&gt; \\(phi : (t : I) -&gt; TOPE) -&gt; \\(psi : (t : I) -&gt; TOPE) -&gt; (A : U) -&gt; \u2211 (f : (k : &lt;{t : I | psi t} -&gt; A [BOT |-&gt; recBOT]&gt;) -&gt; &lt;{t : I | phi t} -&gt; A [BOT |-&gt; recBOT]&gt;), isShapeRetraction I A phi psi f\n</code></pre> <pre><code>\u0394\u00b9 : (t : 2) -&gt; TOPE\n  := \\(t : 2) -&gt; TOP\n\u0394\u00b2 : (t : 2 * 2) -&gt; TOPE\n  := \\(t, s) -&gt; s &lt;= t\n\u0394\u00b3 : (t : 2 * 2 * 2) -&gt; TOPE\n  := \\((t1, t2), t3) -&gt; t3 &lt;= t2 /\\ t2 &lt;= t1\nshapeProd : (I : CUBE) -&gt; (J : CUBE) -&gt; (psi : (t : I) -&gt; TOPE) -&gt; (chi : (s : J) -&gt; TOPE) -&gt; (ts : I * J) -&gt; TOPE\n  := \\I -&gt; \\J -&gt; \\psi -&gt; \\chi -&gt; \\(t, s) -&gt; psi t /\\ chi s\n\u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -&gt; TOPE\n  := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9\n\u0394\u00b2\u00d7\u0394\u00b9 : (t : 2 * 2 * 2) -&gt; TOPE\n  := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9\n</code></pre> <pre><code>\u0394\u00b2-is-retract-of-\u0394\u00b9\u00d7\u0394\u00b9 : shapeRetract (2 * 2) \u0394\u00b2 \u0394\u00b9\u00d7\u0394\u00b9\n  := \\A -&gt; (\\k -&gt; \\ts -&gt; k ts, (\\k -&gt; \\(t, s) -&gt; recOR(t &lt;= s, s &lt;= t, k (t, s), k (t, s)), \\k -&gt; refl_{k}))\n</code></pre> <pre><code>\u0394\u00b3-is-retract-of-\u0394\u00b2\u00d7\u0394\u00b9 : shapeRetract (2 * 2 * 2) \u0394\u00b3 \u0394\u00b2\u00d7\u0394\u00b9\n  := \\A -&gt; (\\k -&gt; \\ts -&gt; k ((first (first ts), second ts), second (first ts)), (\\k -&gt; \\ts -&gt; recOR((second ts) &lt;= (second (first ts)), (second (first ts)) &lt;= (second ts) /\\ (second ts) &lt;= (first (first ts)) \\/ (first (first ts)) &lt;= second ts, k ((first (first ts), second ts), second (first ts)), recOR((second (first ts)) &lt;= (second ts) /\\ (second ts) &lt;= (first (first ts)), (first (first ts)) &lt;= second ts, k ((first (first ts), second ts), second (first ts)), k ((first (first ts), first (first ts)), second (first ts)))), \\k -&gt; refl_{k}))\n</code></pre>"},{"location":"examples/recId.rzk/","title":"Tope disjuction elimination along identity paths","text":"<p>\\(\\mathsf{rec}_{\\lor}^{\\psi,\\phi}(a_\\psi, a_\\phi)\\) (written <code>recOR(psi, phi, a_psi, a_phi)</code> in the code) is well-typed when \\(a_\\psi\\) and \\(a_\\phi\\) are definitionally equal on \\(\\psi \\land \\phi\\). Sometimes this is too strong since many terms are not definitionally equal, but only equal up to a path. Luckily, assuming relative function extensionality, we can define a weaker version of \\(rec_{\\lor}\\) (<code>recOR</code>), which we call <code>recId</code>, that can work in presence of a witness of type \\(\\prod_{t : I \\mid \\psi \\land \\phi} a_\\psi = a_\\phi\\).</p>"},{"location":"examples/recId.rzk/#prerequisites","title":"Prerequisites","text":"<p>We begin by introducing common HoTT definitions:</p> <pre><code>#lang rzk-1\n-- A is contractible there exists x : A such that for any y : A we have x = y.\n#define iscontr (A : U) : U\n  := \u2211 (a : A), (x : A) -&gt; a =_{A} x\n-- A is a proposition if for any x, y : A we have x = y\n#define isaprop (A : U) : U\n  := (x : A) -&gt; (y : A) -&gt; x =_{A} y\n-- A is a set if for any x, y : A the type x =_{A} y is a proposition\n#define isaset (A : U) : U\n  := (x : A) -&gt; (y : A) -&gt; isaprop (x =_{A} y)\n-- Non-dependent product of A and B\n#define prod (A : U) (B : U) : U\n  := \u2211 (x : A), B\n-- A function f : A -&gt; B is an equivalence\n-- if there exists g : B -&gt; A\n-- such that for all x : A we have g (f x) = x\n-- and for all y : B we have f (g y) = y\n#define isweq (A : U) (B : U) (f : A -&gt; B) : U\n  := \u2211 (g : B -&gt; A), prod ((x : A) -&gt; g (f x) =_{A} x) ((y : B) -&gt; f (g y) =_{B} y)\n-- Equivalence of types A and B\n#define weq (A : U) (B : U) : U\n  := \u2211 (f : A -&gt; B), isweq A B f\n-- Transport along a path\n#define transport\n(A : U)\n(C : A -&gt; U)\n(x y : A)\n(p : x =_{A} y)\n    : C x -&gt; C y\n  := \\cx -&gt; idJ(A, x, (\\z q -&gt; C z), cx, y, p)\n</code></pre>"},{"location":"examples/recId.rzk/#relative-function-extensionality","title":"Relative function extensionality","text":"<p>We can now define relative function extensionality. There are several formulations, we provide two, following Riehl and Shulman:</p> <pre><code>-- [RS17, Axiom 4.6] Relative function extensionality.\n#define relfunext : U\n  := (I : CUBE)\n  -&gt; (psi : I -&gt; TOPE)\n  -&gt; (phi : psi -&gt; TOPE)\n  -&gt; (A : psi -&gt; U)\n  -&gt; ((t : psi) -&gt; iscontr (A t))\n  -&gt; (a : (t : phi) -&gt; A t)\n  -&gt; (t : psi) -&gt; A t [ phi t |-&gt; a t]\n-- [RS17, Proposition 4.8] A (weaker) formulation of function extensionality.\n#define relfunext2 : U\n  := (I : CUBE)\n  -&gt; (psi : I -&gt; TOPE)\n  -&gt; (phi : psi -&gt; TOPE)\n  -&gt; (A : psi -&gt; U)\n  -&gt; (a : (t : phi) -&gt; A t)\n  -&gt; (f : (t : psi) -&gt; A t [ phi t |-&gt; a t ])\n  -&gt; (g : (t : psi) -&gt; A t [ phi t |-&gt; a t ])\n  -&gt; weq (f = g)\n((t : psi) -&gt; (f t =_{A t} g t) [ phi t |-&gt; refl ])\n</code></pre>"},{"location":"examples/recId.rzk/#construction-of-recid","title":"Construction of <code>recId</code>","text":"<p>The idea is straightforward. We ask for a proof that <code>a = b</code> for all points in <code>psi /\\ phi</code>. Then, by relative function extensionality (<code>relfunext2</code>), we can show that restrictions of <code>a</code> and <code>b</code> to <code>psi /\\ phi</code> are equal. If we reformulate <code>a</code> as extension of its restriction, then we can <code>transport</code> such reformulation along the path connecting two restrictions and apply <code>recOR</code>.</p> <p>First, we define how to restrict an extension type to a subshape:</p> <pre><code>#section construction-of-recId\n#variable r : relfunext2\n#variable I : CUBE\n#variables psi phi : I -&gt; TOPE\n#variable A : {t : I | psi t \\/ phi t} -&gt; U\n-- Restrict extension type to a subshape.\n#define restrict_phi\n(a : {t : I | phi t} -&gt; A t)\n  : {t : I | psi t /\\ phi t} -&gt; A t\n  := \\t -&gt; a t\n-- Restrict extension type to a subshape.\n#define restrict_psi\n(a : {t : I | psi t} -&gt; A t)\n  : {t : I | psi t /\\ phi t} -&gt; A t\n  := \\t -&gt; a t\n</code></pre> <p>Then, how to reformulate an <code>a</code> (or <code>b</code>) as an extension of its restriction:</p> <pre><code>-- Reformulate extension type as an extension of a restriction.\n#define ext-of-restrict_psi\n(a : {t : I | psi t} -&gt; A t)\n  : (t : psi) -&gt; A t [ psi t /\\ phi t |-&gt; restrict_psi a t ]\n  := a  -- type is coerced automatically here\n-- Reformulate extension type as an extension of a restriction.\n#define ext-of-restrict_phi\n(a : {t : I | phi t} -&gt; A t)\n  : (t : phi) -&gt; A t [ psi t /\\ phi t |-&gt; restrict_phi a t ]\n  := a  -- type is coerced automatically here\n</code></pre> <p>Now, assuming relative function extensionality, we construct a path between restrictions:</p> <pre><code>-- Transform extension of an identity into an identity of restrictions.\n#define restricts-path\n(a_psi : (t : psi) -&gt; A t)\n(a_phi : (t : phi) -&gt; A t)\n(e : {t : I | psi t /\\ phi t} -&gt; a_psi t = a_phi t)\n  : restrict_psi a_psi = restrict_phi a_phi\n  := (first (second (r I\n      (\\t -&gt; psi t /\\ phi t)\n      (\\t -&gt; BOT)\n      (\\t -&gt; A t)\n      (\\t -&gt; recBOT)\n      (\\t -&gt; a_psi t)\n      (\\t -&gt; a_phi t)))) e\n</code></pre> <p>Finally, we bring everything together into <code>recId</code>:</p> <pre><code>-- A weaker version of recOR, demanding only a path between a and b:\n-- recOR(psi, phi, a, b) demands that for psi /\\ phi we have a == b (definitionally)\n-- (recId psi phi a b e) demands that e is the proof that a = b (intensionally) for psi /\\ phi\n#define recId uses (r) -- we declare that recId is using r on purpose\n(a_psi : (t : psi) -&gt; A t)\n(a_phi : (t : phi) -&gt; A t)\n(e : {t : I | psi t /\\ phi t} -&gt; a_psi t = a_phi t)\n  : {t : I | psi t \\/ phi t} -&gt; A t\n  := \\t -&gt; recOR(\n        psi t |-&gt; transport\n          ({s : I | psi s /\\ phi s} -&gt; A s)\n(\\ra -&gt; (s : psi) -&gt; A s [ psi s /\\ phi s |-&gt; ra s ])\n          (restrict_psi a_psi)\n          (restrict_phi a_phi)\n          (restricts-path a_psi a_phi e)\n          (ext-of-restrict_psi a_psi)\n          t,\n        phi t |-&gt; ext-of-restrict_phi a_phi t\n      )\n#end construction-of-recId\n</code></pre>"},{"location":"examples/recId.rzk/#gluing-extension-types","title":"Gluing extension types","text":"<p>An application of of <code>recId</code> is gluing together extension types, whenever we can show that they are equal on the intersection of shapes:</p> <pre><code>-- If two extension types are equal along two subshapes,\n-- then they are also equal along their union.\n#define id-along-border\n(r : relfunext2)\n(I : CUBE)\n(psi : I -&gt; TOPE)\n(phi : I -&gt; TOPE)\n(A : {t : I | psi t \\/ phi t} -&gt; U)\n(a b : {t : I | psi t \\/ phi t} -&gt; A t)\n(e_psi : (t : psi) -&gt; a t = b t)\n(e_phi : (t : phi) -&gt; a t = b t)\n(border-is-a-set : {t : I | psi t /\\ phi t} -&gt; isaset (A t))\n  : {t : I | psi t \\/ phi t} -&gt; a t = b t\n  := recId r I psi phi\n        (\\t -&gt; a t = b t)\n        e_psi e_phi\n        (\\t -&gt; border-is-a-set t (a t) (b t) (e_psi t) (e_phi t))\n</code></pre>"},{"location":"getting-started/changelog/","title":"Changelog for <code>rzk</code>","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to the Haskell Package Versioning Policy.</p>"},{"location":"getting-started/changelog/#v061-2023-09-24","title":"v0.6.1 \u2014 2023-09-24","text":"<p>This version contains a minor fix:</p> <ul> <li>Catch exceptions in the parser, fixing LSP for files where layout resolver fails (see #99).</li> </ul>"},{"location":"getting-started/changelog/#v060-2023-09-23","title":"v0.6.0 \u2014 2023-09-23","text":"<p>This version introduces a proper LSP server with basic support for incremental typechecking and some minor improvements:</p> <ol> <li>LSP server with incremental typechecking (see #95);</li> <li>Improve error messages for unclosed <code>#section</code> and extra <code>#end</code> (see #91).</li> </ol>"},{"location":"getting-started/changelog/#v057-2023-09-21","title":"v0.5.7 \u2014 2023-09-21","text":"<p>This version contains two fixes (see #88) for issues discovered in rzk-lang/sHoTT#30:</p> <ol> <li>We now only generate well-typed LEM instances in the tope solver, speeding up significantly.</li> <li>We fix \\(\\eta\\)-rule for product cubes, to not get stopped by reflexive equality topes like \\(\\langle \\langle \\pi_1 (t_{12}), \\pi_2 (t_{12}) \\rangle, t_3 \\rangle \\equiv \\langle t_{12}, t_3 \\rangle\\).</li> </ol>"},{"location":"getting-started/changelog/#v056-2023-09-19","title":"v0.5.6 \u2014 2023-09-19","text":"<p>This version fixes the behaviour of glob (see <code>77b7cc0</code>).</p>"},{"location":"getting-started/changelog/#v055-2023-09-19","title":"v0.5.5 \u2014 2023-09-19","text":"<p>This version contains Unicode and tope logic-related fixes:</p> <ol> <li>Fix (add missing checks) for subshapes (see #85);</li> <li>Allow to handle wildcards in <code>rzk</code> itself (see #83);</li> <li>Fix Unicode on machines with non-standard locales (see #82);</li> <li>Specify <code>happy</code> and <code>alex</code> as build tools to fix cabal build from Hackage (see #80).</li> <li>Add configuration for MkDocs plugin for Rzk (see #79).</li> </ol>"},{"location":"getting-started/changelog/#v054-2023-08-19","title":"v0.5.4 \u2014 2023-08-19","text":"<p>This version contains minor improvements:</p> <ol> <li>Improve typechecking by trying an easier unification strategy first (see #76);</li> <li>Update GitHub Action for Nix (see #74).</li> </ol>"},{"location":"getting-started/changelog/#v053-2023-07-12","title":"v0.5.3 \u2014 2023-07-12","text":"<p>This version contains a few minor improvements:</p> <ol> <li>Allow patterns in dependent function types (see #67);</li> <li>Hint about possible shape coercions (see #67);</li> <li>Enable doctests (see #68);</li> <li>Improve documentation (add recommended installation instructions via VS Code)</li> <li>Migrate from <code>fizruk</code> to <code>rzk-lang</code> organisation on GitHub (see <code>ee0d063</code>);</li> <li>Speed up GHCJS build with Nix (see #66);</li> </ol>"},{"location":"getting-started/changelog/#v052-2023-07-05","title":"v0.5.2 \u2014 2023-07-05","text":"<p>This version introduces support for Unicode syntax, better recognition of Markdown code blocks and improves documentation a bit:</p> <ul> <li>Support some Unicode syntax (see #61);</li> <li>Support curly braces syntax for code blocks (see #64);</li> <li>Update documentation a bit (see 07b520a6 and 7cc7f383);</li> <li>Factor out Pygments highlighting to https://github.com/rzk-lang/pygments-rzk;</li> <li>Use new cache action for Nix (see #60).</li> </ul>"},{"location":"getting-started/changelog/#v051-2023-06-29","title":"v0.5.1 \u2014 2023-06-29","text":"<p>This version fixes <code>Unit</code> type and makes some changes to documentation:</p> <ul> <li>Fix computation for <code>Unit</code> (see 2f7d6295);</li> <li>Update documentation (see ea2d176b);</li> <li>Use mike to deploy versioned docs (see 99cf721a);</li> <li>Replace MkDocs hook with the published plugin (see #58);</li> <li>Switch to Material theme for MkDocs (see #57);</li> <li>Fix links to <code>*.rzk.md</code> in <code>mkdocs.yml</code> (see 8ba1c55b);</li> </ul>"},{"location":"getting-started/changelog/#v05-2023-06-20","title":"v0.5 \u2014 2023-06-20","text":"<p>This version contains the following changes:</p> <ul> <li><code>Unit</code> type (with <code>unit</code> value) (see ede02611 and bf9d6cd9;</li> <li>Add basic tokenizer support via <code>rzk tokenize</code> (see #53);</li> <li>Add location information for shadowing warnings and duplicate definition errors (see bf9d6cd9).</li> </ul>"},{"location":"getting-started/changelog/#v041-2023-06-16","title":"v0.4.1 \u2014 2023-06-16","text":"<p>This is version contains minor changes, primarily in tools around rzk:</p> <ul> <li>Add <code>rzk version</code> command (see f1709dc7);</li> <li>Add action to release binaries (see 9286afae);</li> <li>Automate SVG rendering in MkDocs (see #49);</li> <li>Read <code>stdin</code> when no filepaths are given (see 936c15a3);</li> <li>Add Pygments highlighting (see 01c2a017, cbd656cc, 5220ddf9, 142ec003, 5c7425f2);</li> <li>Update HighlightJS config for rzk v0.4.0 (see 171ee63f);</li> </ul>"},{"location":"getting-started/changelog/#v040-2023-05-18","title":"v0.4.0 \u2014 2023-05-18","text":"<p>This version introduces sections and variables. The feature is similar to <code>Variable</code> command in Coq. An important difference, however, is that <code>rzk</code> does not allow definitions to use variables implicitly and adds <code>uses (...)</code> annotations to ensure such dependencies are not accidental.</p> <ul> <li>Variables and sections (Coq-style) (see #38);</li> </ul> <p>Minor improvements:</p> <ul> <li>Add flake, set up nix and cabal builds, cache nix store on CI (see #39);</li> <li>Apply stylish-haskell (see 7d42ef62);</li> </ul>"},{"location":"getting-started/changelog/#v030-2023-04-28","title":"v0.3.0 \u2014 2023-04-28","text":"<p>This version introduces an experimental feature for generating visualisations for simplicial terms in SVG. To enable rendering, enable option <code>\"render\" = \"svg\"</code> (to disable, <code>\"render\" = \"none\"</code>):</p> <pre><code>#set-option \"render\" = \"svg\"  -- enable rendering in SVG\n</code></pre> <p>Minor changes:</p> <ul> <li>Exit with non-zero code upon a type error (see b135c4fb)</li> <li>Fix external links and some typos in the documentation</li> </ul> <p>Fixes:</p> <ul> <li>Fixed an issue with tope solver when context was empty (see 6196af9e);</li> <li>Fixed #33 (missing coherence check for restricted types).</li> </ul>"},{"location":"getting-started/changelog/#v020-2023-04-20","title":"v0.2.0 - 2023-04-20","text":"<p>This version was a complete rewrite of the proof assistant, using a new parser, a new internal representation, and a rewrite of the typechecking logic. This is still a prototype, but, arguably, significantly more stable and manageable than version 0.1.0.</p>"},{"location":"getting-started/changelog/#language","title":"Language","text":"<p>Syntax is almost entirely backwards compatible with version 0.1.0. Typechecking has been fixed and improved.</p>"},{"location":"getting-started/changelog/#breaking-changes","title":"Breaking Changes","text":"<p>The only known breaking changes are:</p> <ol> <li>Terms like <code>second x y</code> which previous have been parsed as <code>second (x y)</code>    now are properly parsed as <code>(second x) y</code>.</li> <li>It is now necessary to have at least a minimal indentation in the definition of a term after a newline.</li> <li>Unicode syntax is temporarily disabled, except for dependent sums and arrows in function types.</li> <li>The restriction syntax <code>[ ... ]</code> now has a slightly different precedence, so some parentheses are required, e.g. in <code>(A -&gt; B) [ phi |-&gt; f]</code> or <code>(f t = g t) [ phi |-&gt; f]</code>.</li> <li>Duplicate top-level definitions are no longer allowed.</li> </ol>"},{"location":"getting-started/changelog/#deprecated-syntax","title":"Deprecated Syntax","text":"<p>The angle brackets for extension types are supported, but deprecated, as they are completely unnecessary now: <code>&lt;{t : I | psi t} -&gt; A t [ phi t |-&gt; a t ]&gt;</code> can now be written as <code>{t : I | psi t} -&gt; A t [ phi t |-&gt; a t]</code> or even <code>(t : psi) -&gt; A t [ phi t |-&gt; a t ]</code>.</p>"},{"location":"getting-started/changelog/#syntax-relaxation","title":"Syntax Relaxation","text":"<p>Otherwise, syntax is now made more flexible:</p> <ol> <li>Function parameters can be unnamed: <code>A -&gt; B</code> is the same as <code>(_ : A) -&gt; B</code>.</li> <li>Angle brackets are now optional: <code>{t : I | psi t} -&gt; A t [ phi t |-&gt; a t ]</code></li> <li>Nullary extension types are possible: <code>A t [ phi t |-&gt; a t ]</code></li> <li>Lambda abstractions can introduce multiple arguments:</li> </ol> <pre><code>#def hom : (A : U) -&gt; A -&gt; A -&gt; U\n  := \\A x y -&gt;\n(t : \u0394\u00b9) -&gt; A [ \u2202\u0394\u00b9 t |-&gt; recOR(t === 0_2, t === 1_2, x, y) ]\n</code></pre> <ol> <li>Parameters can be introduced simultaneously for the type and body. Moreover, multiple parameters can be introduced with the same type:</li> </ol> <pre><code>#def hom (A : U) (x y : A) : U\n  := (t : \u0394\u00b9) -&gt; A [ \u2202\u0394\u00b9 t |-&gt; recOR(t === 0_2, t === 1_2, x, y) ]\n</code></pre> <ol> <li>Restrictions can now support multiple subshapes, effectively internalising <code>recOR</code>:</li> </ol> <pre><code>#def hom (A : U) (x y : A) : U\n  := (t : \u0394\u00b9) -&gt; A [ t === 0_2 |-&gt; x, t === 1_2 |-&gt; y ]\n</code></pre> <ol> <li> <p>There are now 3 syntactic versions of <code>refl</code> with different amount of explicit annotations:    <code>refl</code>, <code>refl_{x}</code> and <code>refl_{x : A}</code></p> </li> <li> <p>There are now 2 syntactic versions of identity types (<code>=</code>): <code>x = y</code> and <code>x =_{A} y</code>.</p> </li> <li> <p><code>recOR</code> now supports alternative syntax with an arbitrary number of subshapes:    <code>recOR( tope1 |-&gt; term1, tope2 |-&gt; term2, ..., topeN |-&gt; termN )</code></p> </li> <li> <p>Now it is possible to have type ascriptions: <code>t as T</code>. This can help with ensuring types of subexpressions in parts of formalisations, or to upcast types.</p> </li> <li> <p>New (better) commands are now supported:</p> <ol> <li><code>#define &lt;name&gt; (&lt;param&gt;)* : &lt;type&gt; := &lt;term&gt;</code> \u2014 same as <code>#def</code>, but with full spelling of the word</li> <li><code>#postulate &lt;name&gt; (&lt;param&gt;)* : &lt;type&gt;</code> \u2014 postulate an axiom</li> <li><code>#check &lt;term&gt; : &lt;type&gt;</code> \u2014 typecheck an expression against a given type</li> <li><code>#compute-whnf &lt;term&gt;</code> \u2014 compute (WHNF) of a term</li> <li><code>#compute-nf &lt;term&gt;</code> \u2014 compute normal form of a term</li> <li><code>#compute &lt;term&gt;</code> \u2014 alias for <code>#compute-whnf</code></li> <li> <p><code>#set-option &lt;option&gt; = &lt;value&gt;</code> \u2014 set a (typechecker) option:</p> </li> <li> <p><code>#set-option \"verbosity\" = \"silent\"</code> \u2014 no log printing</p> </li> <li><code>#set-option \"verbosity\" = \"normal\"</code> \u2014 log typechecking progress</li> <li> <p><code>#set-option \"verbosity\" = \"debug\"</code> \u2014 log every intermediate action      (may be useful to debug when some definition does not typecheck)</p> </li> <li> <p><code>#unset-option &lt;option&gt;</code> \u2014 revert option's value to its default</p> </li> </ol> </li> </ol>"},{"location":"getting-started/changelog/#simple-shape-coercions","title":"Simple Shape Coercions","text":"<p>In some places, shapes (cube indexed tope families) can be used directly:</p> <ol> <li> <p>In function parameters: <code>(\u039b -&gt; A) -&gt; (\u0394\u00b2 -&gt; A)</code> is the same as <code>({(t, s) : 2 * 2 | \u039b (t, s)} -&gt; A) -&gt; ({(t, s) : 2 * 2 | \u0394\u00b2} -&gt; A)</code></p> </li> <li> <p>In parameter types of lambda abstractions: <code>\\((t, s) : \u0394\u00b2) -&gt; ...</code> is the same as <code>\\{(t, s) : 2 * 2 | \u0394\u00b2 (t, s)} -&gt; ...</code></p> </li> </ol>"},{"location":"getting-started/changelog/#better-type-inference","title":"Better Type Inference","text":"<ol> <li> <p>It is now not required to annotate point variables with tope restrictions, the typechecker is finally smart enough to figure them out from the context.</p> </li> <li> <p>It is now possible to simply write <code>refl</code> in most situations.</p> </li> <li> <p>It is now possible to omit the index type in an identity type: <code>x = y</code></p> </li> </ol>"},{"location":"getting-started/changelog/#better-output-and-error-message","title":"Better output and error message","text":"<p>The output and error messages have been slightly improved, but not in a major way.</p>"},{"location":"getting-started/changelog/#internal-representation","title":"Internal representation","text":"<p>A new internal representation (a version of second-order abstract syntax) allows to stop worrying about name captures in substitutions, so the implementation is much more trustworthy. The new representation will also allow to bring in higher-order unification in the future, for better type inference, matching, etc.</p> <p>New representation also allowed annotating each (sub)term with its type to avoid recomputations and some other minor speedups. There are still some performance issues, which need to be debugged, but overall it is much faster than version 0.1.0 already.</p>"},{"location":"getting-started/install/","title":"How to install Rzk","text":""},{"location":"getting-started/install/#vs-code-extension-with-binaries-recommended","title":"VS Code extension with binaries (recommended)","text":"<p>These instructions will walk you through setting up Rzk using the \"basic\" setup and VS Code as the editor.</p> <ol> <li>Install VS Code.</li> <li>Launch VS Code and install the <code>rzk</code> extension.</li> <li>Create a new file using \"File &gt; New Text File\" (Ctrl+N). Click the <code>Select a language</code> prompt, type in <code>rzk</code>, and select \"Literate Rzk Markdown\".   </li> <li>You should see the following popup:   </li> <li>Click \"Yes\" button.</li> <li> <p>While it is installing, you can paste the following literate Rzk program into the new file:</p> <pre><code># Sample literate Rzk markdown\n```rzk\n#lang rzk-1\n#define id (A : U)\n  : A -&gt; A\n  := \\ x -&gt; x\n```\n</code></pre> </li> <li> <p>When the installation is done you should see the following popup:   </p> </li> <li>Click \"Reload button\".</li> <li>Save your file as <code>example.rzk.md</code>.</li> <li> <p>Open local Terminal (Ctrl+`).</p> </li> <li> <p>In the terminal, run</p> <pre><code>rzk typecheck example.rzk.md\n</code></pre> </li> <li> <p>You should see the output of the proof assistant:</p> <pre><code>Loading file example.rzk.md\nChecking module from example.rzk.md\n[ 1 out of 1 ] Checking #define id\nEverything is ok!\n</code></pre> </li> <li> <p>Congratulations! Now you have a working rzk setup :) Note that the rzk extension will notify you about updates of <code>rzk</code> and prompt updating to new versions.</p> </li> <li> <p>See Quickstart to get familiar with the Rzk language!</p> </li> </ol>"},{"location":"getting-started/install/#install-binaries","title":"Install binaries","text":""},{"location":"getting-started/install/#download-from-github","title":"Download from GitHub","text":"<p>You can download and use binaries (at least for some platforms) directly for one of the latest releases on GitHub at https://github.com/rzk-lang/rzk/releases. If your platform is not represented, please consider leaving an issue at https://github.com/rzk-lang/rzk/issues/new.</p>"},{"location":"getting-started/install/#install-from-sources","title":"Install from sources","text":"<p>You can install <code>rzk</code> from sources. You can get the latest \"stable\" release from Hackage or build from the <code>develop</code> branch on GitHub.</p>"},{"location":"getting-started/install/#stack","title":"Stack","text":"<p>To build and install with Stack from Hackage:</p> <pre><code>stack install rzk\n</code></pre> <p>To build and install with Stack from sources on GitHub:</p> <pre><code>git clone https://github.com/rzk-lang/rzk.git\ncd rzk\ngit checkout develop\nstack build &amp;&amp; stack install\n</code></pre>"},{"location":"getting-started/install/#cabal-install","title":"cabal-install","text":"<p>To build and install with <code>cabal-install</code> from Hackage:</p> <pre><code>cabal v2-install rzk\n</code></pre> <p>To build and install with <code>cabal-install</code> from sources on GitHub:</p> <pre><code>git clone https://github.com/rzk-lang/rzk.git\ncd rzk\ngit checkout develop\ncabal v2-build &amp;&amp; cabal v2-install\n</code></pre>"},{"location":"getting-started/install/#nix","title":"Nix","text":"<p>Work-in-progress</p> <p>To be done.</p>"},{"location":"getting-started/publishing-with-mkdocs/","title":"Building and publishing Rzk formalisations with MkDocs","text":"<p>Work-in-progress</p> <p>Guide will be here soon. For now, please, check out https://github.com/emilyriehl/yoneda for an example with GitHub Actions.</p>"},{"location":"getting-started/quickstart.rzk/","title":"Quick introduction into Rzk","text":"<p>Work-in-progress</p> <p>Documentation is a work in progress.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"reference/cube-layer.rzk/","title":"Cube layer","text":"<pre><code>#lang rzk-1\n</code></pre> <p>All cubes live in <code>CUBE</code> universe.</p> <p>There are two built-in cubes:</p> <ol> <li><code>1</code> cube is a unit cube with a single point <code>*_1</code></li> <li><code>2</code> cube is a directed interval cube with points <code>0_2</code> and <code>1_2</code></li> </ol> <p>It is also possible to have <code>CUBE</code> variables and make products of cubes:</p> <ol> <li><code>I * J</code>  is a product of cubes <code>I</code> and <code>J</code></li> <li><code>(t, s)</code> is a point in <code>I * J</code> if <code>t : I</code> and <code>s : J</code></li> <li>if <code>ts : I * J</code>, then <code>first ts : I</code> and <code>second ts : J</code></li> </ol> <p>You can usually use <code>(t, s)</code> both as a pattern, and a construction of a pair of points:</p> <pre><code>-- Swap point components of a point in a cube I \u00d7 I\n#define swap\n(I : CUBE)\n  : (I * I) -&gt; I * I\n  := \\(t, s) -&gt; (s, t)\n</code></pre>"},{"location":"reference/extension-types.rzk/","title":"Extension types","text":"<ol> <li> <p>Extension types \\(\\left\\langle \\prod_{t : I \\mid \\psi} A \\vert ^{\\phi} _{a} \\right\\rangle\\) are written as <code>{t : I | psi t} -&gt; A [ phi |-&gt; a ]</code></p> <ul> <li>specifying <code>[ phi |-&gt; a ]</code> is optional, semantically defaults to <code>[ BOT |-&gt; recBOT ]</code> (like in RSTT);</li> <li>specifying <code>psi</code> in <code>{t : I | psi}</code> is mandatory;</li> <li>values of function types are \\(\\lambda\\)-abstractions written in one of the following ways:<ul> <li><code>\\t -&gt; &lt;body&gt;</code> \u2014 this is usually fine;</li> <li><code>\\{t : I | psi} -&gt; &lt;body&gt;</code> \u2014 this sometimes helps the typechecker;</li> </ul> </li> </ul> </li> <li> <p>Types of functions from a shape \\(\\prod_{t : I \\mid \\psi} A\\) are a specialised variant of extension types and are written <code>{t : I | psi} -&gt; A</code></p> <ul> <li>specifying the name of the argument is mandatory; i.e. <code>{I | psi} -&gt; A</code> is invalid syntax!</li> <li>values of function types are \\(\\lambda\\)-abstractions written in one of the following ways:<ul> <li><code>\\t -&gt; &lt;body&gt;</code> \u2014 this is usually fine;</li> <li><code>\\{t : I | psi} -&gt; &lt;body&gt;</code> \u2014 this sometimes helps the typechecker;</li> </ul> </li> </ul> </li> </ol> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> </ol>"},{"location":"reference/introduction.rzk/","title":"Introduction","text":"<p><code>rzk</code> is an experimental proof assistant for synthetic \u221e-categories. <code>rzk-1</code> is an early version of the language supported by <code>rzk</code>. The language is based on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb<sup>1</sup>. In this section, we introduce syntax, discuss features and some of the current limitations of the proof assistant.</p> <p>Overall, a program in <code>rzk-1</code> consists of a language pragma (specifying that we use <code>rzk-1</code> and not one of the other languages<sup>2</sup>) followed by a sequence of commands. For now, we will only use <code>#define</code> command.</p> <p>Here is a small formalisation in an MLTT subset of <code>rzk-1</code>:</p> <pre><code>#lang rzk-1\n-- Flipping the arguments of a function.\n#define flip\n(A B : U)                         -- For any types A and B\n(C : (x : A) -&gt; (y : B) -&gt; U)     -- and a type family C\n(f : (x : A) -&gt; (y : B) -&gt; C x y) -- given a function f : A -&gt; B -&gt; C\n  : (y : B) -&gt; (x : A) -&gt; C x y       -- we construct a function of type B -&gt; A -&gt; C\n  := \\y x -&gt; f x y    -- by swapping the arguments\n-- Flipping a function twice is the same as not doing anything\n#define flip-flip-is-id\n(A B : U)                         -- For any types A and B\n(C : (x : A) -&gt; (y : B) -&gt; U)     -- and a type family C\n(f : (x : A) -&gt; (y : B) -&gt; C x y) -- given a function f : A -&gt; B -&gt; C\n  : f = flip B A (\\y x -&gt; C x y)\n          (flip A B C f)              -- flipping f twice is the same as f\n  := refl                             -- proof by reflexivity\n</code></pre> <p>Let us explain parts of this code:</p> <ol> <li><code>#lang rzk-1</code> specifies that we are in using <code>rzk-1</code> language;</li> <li><code>--</code> starts a comment line (until the end of the line);</li> <li><code>#define \u00abname\u00bb : \u00abtype\u00bb := \u00abterm\u00bb</code> defines a name <code>\u00abname\u00bb</code> to be equal to <code>\u00abterm\u00bb</code>; the proof assistant will typecheck <code>\u00abterm\u00bb</code> against type <code>\u00abtype\u00bb</code>;</li> <li>We define two terms here \u2014 <code>flip</code> and <code>flip-flip-is-id</code>;</li> <li><code>flip</code> is a function that takes 4 arguments and returns a function of two arguments.</li> <li><code>flip-flip-is-id</code> is a function that takes two types, a type family, and a function <code>f</code> and returns a value of an identity type <code>flip ... (flip ... f) = f</code>, indicating that flipping a function <code>f</code> twice gets us back to <code>f</code>.</li> </ol> <p>Similarly to the three layers in Riehl and Shulman's type theory, <code>rzk-1</code> has 3 universes:</p> <ul> <li><code>CUBE</code> is the universe of cubes, corresponding to the cube layer;</li> <li><code>TOPE</code> is the universe of topes, corresponding to the tope layer;</li> <li><code>U</code> is the universe of types, corresponding to the types and terms layer.</li> </ul> <p>These are explained in the following sections.</p>"},{"location":"reference/introduction.rzk/#soundness","title":"Soundness","text":"<p><code>rzk-1</code> assumes \"type-in-type\", that is <code>U</code> has type <code>U</code>. This is known to make the type system unsound (due to Russell and Curry-style paradoxes), however, it is sometimes considered acceptable in proof assistants. And, since it simplifies implementation, <code>rzk-1</code> embraces this assumption, at least for now.</p> <p>Moreover, <code>rzk-1</code> does not prevent cubes or topes to depend on types and terms. For example, the following definition typechecks:</p> <pre><code>#define weird\n(A : U)\n(I : A -&gt; CUBE)\n(x y : A)\n  : CUBE\n  := I x * I y\n</code></pre> <p>This likely leads to another inconsistency, but it will probably not lead to bugs in actual proofs of interest, so current version embraces this lax treatment of universes.</p> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> <li> <p>In version  v0.1.0, <code>rzk</code> has supported simply typed lambda calculus, PCF, and MLTT. However, those languages have been removed.\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/render.rzk/","title":"Rendering Diagrams","text":"<p>Starting from version <code>0.3.0</code>, <code>rzk</code> supports rendering of topes, types, and terms as diagrams.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre> <p>To enable rendering, enable option <code>\"render\" = \"svg\"</code> (to disable, <code>\"render\" = \"none\"</code>):</p> <pre><code>#set-option \"render\" = \"svg\"  -- enable rendering in SVG\n</code></pre> <p>Rendering is completely automatic, and works in the following situations:</p> <ol> <li>Mapping from a shape (including curried mappings), up to 3 dimensions, only in products of <code>2</code> cubes;</li> <li>Type of mapping from a shape (including curried mappings), up to 3 dimensions, only in products of <code>2</code> cubes.</li> <li>Mappings from a shape that is a section of an existing shape.</li> </ol> <p>The rendering assigns the following colors:</p> <ul> <li>purple is assigned for parameters (context) variables;</li> <li>blue is used for fillings for types (e.g. for <code>hom</code> and <code>hom2</code>);</li> <li>red is used for terms (e.g. <code>Segal-comp-witness</code>);</li> <li>orange is used for shapes in the tope layer;</li> <li>grey is used for discarded parts of a (larger) mapping (e.g. when extracting a diagonal/face from a larger shape).</li> </ul> <p>The SVG pictures can be inserted directly into <code>.md</code> files before a corresponding <code>rzk</code> code block. At the bottom of a markdown file, you might want to add stylization, e.g.:</p> <pre><code>&lt;style&gt;\n.rzk-render { transition: transform .2s; /* Animation */ }\n.rzk-render:hover { transform: scale(1.5); /* (150% zoom - Note: if the zoom is too large, it will go outside of the viewport) */ }\n&lt;/style&gt;\n&lt;!-- Definitions for the SVG images above --&gt;\n&lt;svg width=\"0\" height=\"0\"&gt;\n&lt;defs&gt;\n&lt;style data-bx-fonts=\"Noto Serif\"&gt;@import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap);&lt;/style&gt;\n&lt;marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"5\" refY=\"5\"\nmarkerWidth=\"5\" markerHeight=\"5\" orient=\"auto-start-reverse\"&gt;\n&lt;path d=\"M 0 2 L 5 5 L 0 8 z\" stroke=\"purple\" fill=\"purple\" /&gt;\n&lt;/marker&gt;\n&lt;/defs&gt;\n&lt;style&gt;\ntext, textPath {\nfont-family: Noto Serif;\nfont-size: 28px;\ndominant-baseline: middle;\ntext-anchor: middle;\n}\n&lt;/style&gt;\n&lt;/svg&gt;\n</code></pre>"},{"location":"reference/render.rzk/#examples","title":"Examples","text":""},{"location":"reference/render.rzk/#visualising-simplicial-topes","title":"Visualising Simplicial Topes","text":"<p>Topes are visualised with orange color:</p> <p> \u2022 \u2022 \u2022 </p> <p><pre><code>-- 2-simplex\n#define \u0394\u00b2 : (2 * 2) -&gt; TOPE\n  := \\(t, s) -&gt; s &lt;= t\n</code></pre>  Boundary of a tope:</p> <p> \u2022 \u2022 \u2022 </p> <pre><code>-- boundary of a 2-simplex\n#define \u2202\u0394\u00b2 : \u0394\u00b2 -&gt; TOPE\n  := \\(t, s) -&gt; s === 0_2 \\/ t === 1_2 \\/ s === t\n</code></pre> <p>The busiest tope diagram involves the entire 3D cube: </p> <p> \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 </p> <p><pre><code>-- 3-dim cube\n#define 2\u00b3 : (2 * 2 * 2) -&gt; TOPE\n  := \\_ -&gt; TOP\n</code></pre> </p> <p> \u2022 \u2022 \u2022 \u2022 </p> <pre><code>-- 3-simplex\n#define \u0394\u00b3 : (2 * 2 * 2) -&gt; TOPE\n  := \\((t1, t2), t3) -&gt; t3 &lt;= t2 /\\ t2 &lt;= t1\n</code></pre> <p></p>"},{"location":"reference/render.rzk/#visualising-simplicial-types","title":"Visualising Simplicial Types","text":"<p>Types are visualised with blue color. Recognised parameter part (e.g. fixed endpoints, edges, faces with clear labels) are visualised with purple color. When a type is constructed by taking a part of another shape, the rest of the larger shape is colored using gray color.</p> <p> x y </p> <pre><code>-- [RS17, Definition 5.1]\n-- The type of arrows in A from x to y.\n#define hom\n(A : U)   -- A type.\n(x y : A) -- Two points in A.\n  : U                   -- (hom A x y) is a 1-simplex (an arrow)\n  := (t : 2) -&gt; A [    -- in A where\n    t === 0_2 |-&gt; x,    -- * the left endpoint is exactly x\n    t === 1_2 |-&gt; y     -- * the right endpoint is exactly y\n  ]\n</code></pre> <p> f f h h g g x y z </p> <pre><code>-- [RS17, Definition 5.2]\n-- the type of commutative triangles in A\n#define hom2\n(A : U)           -- A type.\n(x y z : A)       -- Three points in A.\n(f : hom A x y)   -- An arrow in A from x to y.\n(g : hom A y z)   -- An arrow in A from y to z.\n(h : hom A x z)   -- An arrow in A from x to z.\n  : U                           -- (hom2 A x y z f g h) is a 2-simplex (triangle)\n  := { (t1, t2) : \u0394\u00b2 } -&gt; A [   -- in A where\n    t2 === 0_2 |-&gt; f t1,        -- * the top edge is exactly f,\n    t1 === 1_2 |-&gt; g t2,        -- * the right edge is exactly g, and\n    t2 === t1  |-&gt; h t2         -- * the diagonal is exactly h\n  ]\n</code></pre>"},{"location":"reference/render.rzk/#visualising-terms-of-simplicial-types","title":"Visualising Terms of Simplicial Types","text":"<p>Terms (with non-trivial labels) are visualised with red color (you can see a detailed label on hover). Recognised parameter part (e.g. fixed endpoints, edges, faces with clear labels) are visualised with purple color. When a term is constructed by taking a part of another shape, the rest of the larger shape is colored using gray color.</p> <p>We can visualise terms that fill a shape:</p> <p> recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 recOR (\u03c0\u2082 x\u2086 \u2264 \u03c0\u2081 x\u2086 \u21a6 \u03c0\u2082 a (\u2026 \u2022 \u2022 \u2022 \u2022 </p> <pre><code>#define square\n(A : U)\n(x y z : A)\n(f : hom A x y)\n(g : hom A y z)\n(h : hom A x z)\n(a : Sigma (h' : hom A x z), hom2 A x y z f g h')\n  : (2 * 2) -&gt; A\n  := \\(t, s) -&gt; recOR( s &lt;= t |-&gt; second a (t, s) , t &lt;= s |-&gt; second a (s, t))\n</code></pre> <p>If a term is extracted as a part of a larger shape, generally, the whole shape will be shown (in gray):</p> <p> \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2081 a (\u03c0\u2082 x\u2085) \u03c0\u2081 a (\u03c0\u2082 x\u2085) x x f f \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2082 a x\u2086 \u03c0\u2081 a (\u03c0\u2082 x\u2085) y y \u03c0\u2081 a (\u03c0\u2082 x\u2085) z z \u03c0\u2081 a (\u03c0\u2082 x\u2085) x x y y z y z </p> <pre><code>#define face\n(A : U)\n(x y z : A)\n(f : hom A x y)\n(a : Sigma (g : hom A y z), {((t1, t2), t3) : 2 * 2 * 2 | t3 &lt;= t1 \\/ t2 &lt;= t1} -&gt; A [ t1 === 0_2 |-&gt; f t2, t1 === 1_2 |-&gt; g t3 ])\n  : \u0394\u00b2 -&gt; A\n  := \\(t, s) -&gt; second a ((t, t), s)\n</code></pre> <p> <p></p>"},{"location":"reference/sections.rzk/","title":"Sections and Variables","text":"<p>Sections and variables allow to simplify definitions by factoring out common assumptions.</p> <p>Coq-style variables</p> <p><code>rzk</code> implements variables similarly to <code>Variable</code> command in Coq. An important difference is that <code>rzk</code> does not allow definitions to use variables implicitly and adds <code>uses (...)</code> annotations to ensure such dependencies are not accidental. This is, perhaps, somewhat related to this error message in Coq.</p> <p>This is a literate <code>rzk</code> file:</p> <pre><code>#lang rzk-1\n</code></pre>"},{"location":"reference/sections.rzk/#variables","title":"Variables","text":"<p>Consider the following definitions:</p> <pre><code>#define compose\u2081\n(A B C : U)\n(g : B -&gt; C)\n(f : A -&gt; B)\n  : A -&gt; C\n  := \\x -&gt; g (f x)\n#define twice\u2081\n(A : U)\n(h : A -&gt; A)\n  : A -&gt; A\n  := \\x -&gt; h (h x)\n</code></pre> <p>Since it might be common to introduce types <code>A</code>, <code>B</code>, and <code>C</code>, we can declare these are variables:</p> <pre><code>#variables A B C : U\n#define compose\u2082\n(g : B -&gt; C)\n(f : A -&gt; B)\n  : A -&gt; C\n  := \\x -&gt; g (f x)\n#define twice\u2082\n(h : A -&gt; A)\n  : A -&gt; A\n  := \\x -&gt; h (h x)\n</code></pre> <p>The <code>#variables</code> command here introduces assumptions, which can be used in the following definitions. Importantly, after checking a file (module), all definitions will have the assumptions used (explicitly or implicitly) attached as bound variables.</p>"},{"location":"reference/sections.rzk/#implicitly-used-variables-and-uses","title":"Implicitly used variables (and <code>uses</code>)","text":"<p>We can try going even further and declare variables <code>f</code>, <code>g</code>, <code>h</code>, and <code>x</code>:</p> <pre><code>#variable g : B -&gt; C\n#variable f : A -&gt; B\n#variable h : A -&gt; A\n#variable x : A\n-- #define bad-compose\u2083 : C := g (f x)  -- ERROR: implicit assumptions A and B\n#define twice\u2083 : A := h (h x)\n</code></pre> <p>Note how this definition of <code>bad-compose\u2083</code> is implicitly dependent on the types <code>A</code> and <code>B</code>, which is promptly noted by <code>rzk</code>, which issues an error (if we uncomment the corresponding line):</p> <pre><code>implicit assumption\n  B : U\nused in definition of\n  bad-compose\u2083\n</code></pre> <p>To let <code>rzk</code> know that this is not accidental, we can add <code>uses (...)</code> annotation to specify a list of variables implicitly used in the definition:</p> <pre><code>#define compose\u2083 uses (A B) : C := g (f x)\n</code></pre>"},{"location":"reference/sections.rzk/#sections","title":"Sections","text":"<p>To introduce assumption variables temporarily inside of one file, you can use sections:</p> <pre><code>#section example-1\n#variables X Y Z : U\n#variable k : X -&gt; X\n#variable x' : X\n#define compose\u2084\n(g : Y -&gt; Z)\n(f : X -&gt; Y)\n  : X -&gt; Z\n  := \\x -&gt; g (f x)\n#define twice\u2084 : X := k (k x')\n#end example-1\n</code></pre> <p>Now, once outside of the section, <code>compose\u2084</code> and <code>twice\u2084</code> obtain corresponding parameters (only those used, explicitly or implicitly):</p> <pre><code>-- compose\u2084 : (X : U) -&gt; (Y : U) -&gt; (Z : U) -&gt; (g : Y -&gt; Z) -&gt; (f : X -&gt; Y) -&gt; (X -&gt; Z)\n-- twice\u2084 : (X : U) -&gt; (k : X -&gt; X) -&gt; (x' : X) -&gt; X\n#define twice\u2085\n(T : U)\n(e : T -&gt; T)\n  : T -&gt; T\n  := compose\u2084 T T T e e\n#define identity\n(T : U)\n  : T -&gt; T\n  := twice\u2084 T (\\t -&gt; t)\n</code></pre> <p>Lack of indentation</p> <p><code>rzk</code> currently does not support indentation, so all definitions and commands inside a section (including nested sections) have to start at the beginning of a line.</p>"},{"location":"reference/tope-disjunction-elimination.rzk/","title":"Tope disjuction elimination","text":"<p>Following Riehl and Shulman's type theory<sup>1</sup>, <code>rzk-1</code> introduces two primitive terms for disjunction elimination:</p> <ol> <li> <p><code>recBOT</code> corresponds to \\(\\mathsf{rec}_\\bot\\), has any type, and is valid whenever tope context is included in <code>BOT</code>;</p> </li> <li> <p><code>recOR(\u00abtope_1\u00bb |-&gt; \u00abterm_1\u00bb, ..., \u00abtope_n\u00bb |-&gt; \u00abterm_n\u00bb)</code> defines a term for a disjunction of topes <code>\u00abtope_1\u00bb \\/ ... \\/ \u00abtope_n\u00bb</code>. This is well-typed when for an intersection of any two topes <code>\u00abtope_i\u00bb /\\ \u00abtope_j\u00bb</code> the corresponding terms <code>\u00abterm_i\u00bb</code> and <code>\u00abterm_j\u00bb</code> are judgementally equal. In particular, <code>recOR(psi |-&gt; a_psi, phi |-&gt; a_phi)</code> corresponds to \\(\\mathsf{rec}_\\lor^{\\psi, \\phi}(a_\\psi, a_\\phi)\\).</p> </li> </ol> <p>Deprecated syntax</p> <p><code>recOR(psi, phi, a_psi, a_phi)</code> corresponds to \\(\\mathsf{rec}_\\lor^{\\psi, \\phi}(a_\\psi, a_\\phi)\\), is well-typed when <code>a_psi</code> is definitionally equal to <code>a_phi</code> under <code>psi /\\ phi</code>. However, this syntax is deprecated since it is easy to confuse which tope relates to which term.</p> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories. Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> </ol>"},{"location":"reference/tope-layer.rzk/","title":"Tope layer","text":"<p>All topes live in <code>TOPE</code> universe.</p> <p>Here are all the ways to build a tope:</p> <ol> <li> <p>Introduce a variable, e.g. <code>(psi : TOPE) -&gt; ...</code>;</p> <ul> <li>Usually, topes depend on point variables from some cube(s). To indicate that, we usually introduce topes as \"functions\" from some cube to <code>TOPE</code>. For example, <code>(psi : I -&gt; TOPE) -&gt; ...</code>.</li> </ul> </li> <li> <p>Use a constant:</p> <ul> <li>top tope \\(\\top\\) is written <code>TOP</code></li> <li>bottom tope \\(\\bot\\) is written <code>BOT</code></li> </ul> </li> <li> <p>Usa a tope connective:</p> <ul> <li>tope conjunction \\(\\psi \\land \\phi\\) is written <code>psi /\\ phi</code></li> <li>tope disjunction \\(\\psi \\lor \\phi\\) is written <code>psi \\/ phi</code></li> <li>equality tope \\(t \\equiv s\\) is written <code>t === s</code>, whenever <code>t</code> and <code>s</code> are points of the same cube</li> <li>inequality tope \\(t \\leq s\\) is written <code>t &lt;= s</code> whenever <code>t : 2</code> and <code>s : 2</code></li> </ul> </li> </ol>"},{"location":"reference/type-layer.rzk/","title":"Types and terms","text":"<pre><code>#lang rzk-1\n</code></pre>"},{"location":"reference/type-layer.rzk/#functions-dependent-products","title":"Functions (dependent products)","text":"<p>Function (dependent product) types \\(\\prod_{x : A} B\\) are written <code>(x : A) -&gt; B x</code>. Values of function types are \\(\\lambda\\)-abstractions written in one of the following ways:</p> <ul> <li><code>\\x -&gt; &lt;body&gt;</code> \u2014 this is usually fine;</li> <li><code>\\(x : A) -&gt; &lt;body&gt;</code> \u2014 this sometimes helps the typechecker.</li> </ul>"},{"location":"reference/type-layer.rzk/#dependent-sums","title":"Dependent sums","text":"<p>Dependent sum type \\(\\sum_{x : A} B\\) is written <code>\u2211 (x : A), B</code> or <code>Sigma (x : A), B</code>. Values of dependent sum types are pairs written as <code>(x, y)</code>.</p> <p>To access components of a dependent pair <code>p</code>, use <code>first p</code> and <code>second p</code>.</p> <p>Warning</p> <p><code>first</code> and <code>second</code> are not valid syntax without an argument!</p>"},{"location":"reference/type-layer.rzk/#identity-types","title":"Identity types","text":"<p>Identity (path) type \\(x =_A y\\) is written <code>x =_{A} y</code>.</p> <p>Tip</p> <p>Specifying the type <code>A</code> is optional: <code>x = y</code> is valid syntax!</p> <p>Any identity type has value <code>refl_{x : A}</code> whose type is <code>x =_{A} x</code> whenever <code>x : A</code></p> <p>Tip</p> <p>Specifying term and type of <code>refl_{x : A}</code> is optional: <code>refl_{x}</code> and <code>refl</code> are both valid syntax.</p> <p>Path induction is done using \\(\\mathcal{J}\\) path eliminator:</p> <ul> <li>for<ul> <li>any type \\(A\\) and \\(a : A\\),</li> <li>type family \\(C : \\prod_{x : A} ((a =_A x) \\to \\mathcal{U})\\) and</li> <li>\\(d : C(a,\\mathsf{refl}_a)\\) and</li> <li>\\(x : A\\) and \\(p : a =_A x\\)</li> </ul> </li> <li>we have \\(\\mathcal{J}(A, a, C, d, x, p) : C(x, p)\\)</li> </ul> <p>In <code>rzk-1</code> we write <code>idJ(A, a, C, d, x, p)</code></p> <p>Warning</p> <p><code>idJ</code> is not valid syntax without exactly 6-tuple provided as an argument!</p>"},{"location":"reference/builtins/unit.rzk/","title":"Unit type","text":"<p>Since  v0.5.1</p> <pre><code>#lang rzk-1\n</code></pre> <p>In the syntax, only <code>Unit</code> (the type) and <code>unit</code> (the only inhabitant) are provided. Everything else should be available from computation rules. More specifically, <code>rzk</code> takes the uniqueness property of the <code>Unit</code> type (see Section 1.5 of the HoTT book<sup>1</sup>) as the computation rule, meaning that any (well-typed) term of type <code>Unit</code> reduces to <code>unit</code>. This means in particular, that induction and uniqueness can be defined very easily:</p> <pre><code>#define ind-Unit\n(C : Unit -&gt; U)\n(C-unit : C unit)\n(x : Unit)\n  : C x\n  := C-unit\n#define uniq-Unit\n(x : Unit)\n  : x = unit\n  := refl\n#define isProp-Unit\n(x y : Unit)\n  : x = y\n  := refl\n</code></pre> <p>As a non-trivial example, here is a proof that <code>Unit</code> is a Segal type:</p> <pre><code>#section isSegal-Unit\n#variable extext : ExtExt\n#define iscontr-Unit : isContr Unit\n  := (unit, \\_ -&gt; refl)\n#define isContr-\u0394\u00b2\u2192Unit uses (extext)\n  : isContr (\u0394\u00b2 -&gt; Unit)\n  := (\\_ -&gt; unit, \\k -&gt; eq-ext-htpy extext\n    (2 * 2) \u0394\u00b2 (\\_ -&gt; BOT)\n    (\\_ -&gt; Unit) (\\_ -&gt; recBOT)\n    (\\_ -&gt; unit) k\n    (\\_ -&gt; refl)\n    )\n#define isSegal-Unit uses (extext)\n  : isSegal Unit\n  := \\x y z f g -&gt; isRetract-ofContr-isContr\n(\u2211 (h : hom Unit x z), hom2 Unit x y z f g h)\n    (\u0394\u00b2 -&gt; Unit)\n    (\\(_, k) -&gt; k, (\\k -&gt; (\\t -&gt; k (t, t), k), \\_ -&gt; refl))\n    isContr-\u0394\u00b2\u2192Unit\n#end isSegal-Unit\n</code></pre> <ol> <li> <p>The Univalent Foundations Program (2013). Homotopy Type Theory: Univalent Foundations of Mathematics. https://homotopytypetheory.org/book \u21a9</p> </li> </ol>"},{"location":"related/sHoTT/","title":"sHoTT","text":"<p>sHoTT is a formalisation project for simplicial HoTT and \u221e-categories.</p> <p>The project is a fork of https://github.com/emilyriehl/yoneda, with a goal to grow and eventually include various formalisations for HoTT (e.g. HoTT book), synthetic fibered \u221e-categories from the work of Ulrik Buchholtz and Jonathan Weinberger, variations of cubical type theories, etc.</p> <p>See more details in the documentation of the project at https://github.com/fizruk/sHoTT.</p>"},{"location":"related/simple-topes/","title":"simple-topes","text":"<p>simple-topes is a playground theorem prover project for type theory with shapes that allows user-defined cubes and topes. Once stable, the project will be merged into <code>rzk</code>, extending it to a proof assistant for type theory with (user-defined) cubes, topes, and shapes.</p> <p>See more details in the documentation of the project at https://github.com/fizruk/simple-topes.</p>"},{"location":"related/yoneda/","title":"Yoneda lemma for \u221e-categories","text":"<p>This is a formalization library for simplicial Homotopy Type Theory (sHoTT) with the aim of proving the Yoneda lemma for \u221e-categories following the paper \"A type theory for synthetic \u221e-categories\" <sup>1</sup>. This formalization project could be regarded as a companion to the article \"Could \u221e-category theory be taught to undergraduates?\" <sup>2</sup>.</p> <p>Formalizations were contributed by Fredrik Bakke, Nikolai Kudasov, Emily Riehl, and Jonathan Weinberger.</p> <p>See more about the project at https://github.com/emilyriehl/yoneda.</p> <ol> <li> <p>Emily Riehl &amp; Michael Shulman. A type theory for synthetic \u221e-categories.    Higher Structures 1(1), 147-224. 2017. https://arxiv.org/abs/1705.07442 \u21a9</p> </li> <li> <p>Emily Riehl. Could \u221e-category theory be taught to undergraduates? Notices of    the AMS. May 2023.    https://www.ams.org/journals/notices/202305/noti2692/noti2692.html \u21a9</p> </li> </ol>"},{"location":"tools/continuous/","title":"Continuous Verification with <code>rzk</code>","text":""},{"location":"tools/continuous/#github-action","title":"GitHub Action","text":"<p>See https://github.com/rzk-lang/rzk-action. See also https://github.com/emilyriehl/yoneda for an example usage of the action.</p>"},{"location":"tools/highlight/","title":"Syntax Highlighting","text":"<p>Currently basic syntax highlighting is supported for several environments:</p> <ol> <li><code>vscode-rzk</code> VS Code extension provides syntax highlighting for both <code>*.rzk</code> files and <code>rzk</code> code blocks in Markdown files.</li> <li>HighlightJS syntax highlighting (used by MkDocs) is available at https://github.com/rzk-lang/rzk/blob/develop/docs/custom_theme/js/rzk.js</li> <li>Pygments syntax highlighting is available a Python package at https://github.com/rzk-lang/rzk/tree/develop/rzk/RzkLexer. This syntax highlighter is suitable for using with LaTeX (e.g. with <code>minted</code> package).</li> <li>There is also an obsolete syntax highlighting mode for CodeMirror 5.</li> </ol>"},{"location":"tools/ide/","title":"IDE support for <code>rzk</code>","text":""},{"location":"tools/ide/#vs-code","title":"VS Code","text":"<p>There exists a VS Code extension for <code>rzk</code> (on VS Marketplace, on GitHub).</p> <p>Please, refer to the documentation of the extension for more details.</p>"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"rzk \u2014 an experimental proof assistant for synthetic \u221e-categories rzk is an early prototype of a proof assistant for a family of type systems, including Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ).","title":"About"},{"location":"#rzk-an-experimental-proof-assistant-for-synthetic-categories","text":"rzk is an early prototype of a proof assistant for a family of type systems, including Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ).","title":"rzk \u2014 an experimental proof assistant for synthetic \u221e-categories"},{"location":"examples/hom/","text":"Hom-type hom : (A : U) -> (x : A) -> (y : A) -> U := \\A -> \\x -> \\y -> <{t : 2 | TOP} -> A [ t === 0_2 \\/ t === 1_2 |-> recOR(t === 0_2, t === 1_2, x, y) ]> RS17:Prop:3.5a : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A [BOT |-> recBOT]> := \\(A : U) -> \\(f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> \\{ts : 2 * 2 | TOP} -> recOR ((first ts) <= (second ts), (second ts) <= (first ts), f (second ts), f (first ts)) RS17:Prop:3.5b : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A [BOT |-> recBOT]> := \\(A : U) -> \\(f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> \\{ts : 2 * 2 | TOP} -> recOR ((first ts) <= (second ts), (second ts) <= (first ts), f (first ts), f (second ts)) isShapeRetraction : (I : CUBE) -> (A : U) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>) -> U := \\(I : CUBE) -> \\(A : U) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> \\(f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>) -> \u2211 (g : (k : <{t : I | phi t} -> A [BOT |-> recBOT]>) -> <{t : I | psi t} -> A [BOT |-> recBOT]>), (k : <{t : I | phi t} -> A [BOT |-> recBOT]>) -> f (g k) =_{<{t : I | phi t} -> A [BOT |-> recBOT]>} k shapeRetract : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> U := \\(I : CUBE) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> (A : U) -> \u2211 (f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>), isShapeRetraction I A phi psi f \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 \u0394\u00b2\u00d7\u0394\u00b9 : (t : 2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9 \u0394\u00b2-is-retract-of-\u0394\u00b9\u00d7\u0394\u00b9 : shapeRetract (2 * 2) \u0394\u00b2 \u0394\u00b9\u00d7\u0394\u00b9 := \\A -> (\\k -> \\ts -> k ts, (\\k -> \\(t, s) -> recOR(t <= s, s <= t, k (t, s), k (t, s)), \\k -> refl_{k})) \u0394\u00b3-is-retract-of-\u0394\u00b2\u00d7\u0394\u00b9 : shapeRetract (2 * 2 * 2) \u0394\u00b3 \u0394\u00b2\u00d7\u0394\u00b9 := \\A -> (\\k -> \\ts -> k ((first (first ts), second ts), second (first ts)), (\\k -> \\ts -> recOR((second ts) <= (second (first ts)), (second (first ts)) <= (second ts) /\\ (second ts) <= (first (first ts)) \\/ (first (first ts)) <= second ts, k ((first (first ts), second ts), second (first ts)), recOR((second (first ts)) <= (second ts) /\\ (second ts) <= (first (first ts)), (first (first ts)) <= second ts, k ((first (first ts), second ts), second (first ts)), k ((first (first ts), first (first ts)), second (first ts)))), \\k -> refl_{k}))","title":"Hom-type"},{"location":"examples/hom/#hom-type","text":"hom : (A : U) -> (x : A) -> (y : A) -> U := \\A -> \\x -> \\y -> <{t : 2 | TOP} -> A [ t === 0_2 \\/ t === 1_2 |-> recOR(t === 0_2, t === 1_2, x, y) ]> RS17:Prop:3.5a : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A [BOT |-> recBOT]> := \\(A : U) -> \\(f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> \\{ts : 2 * 2 | TOP} -> recOR ((first ts) <= (second ts), (second ts) <= (first ts), f (second ts), f (first ts)) RS17:Prop:3.5b : (A : U) -> (f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> <{ts : 2 * 2 | TOP} -> A [BOT |-> recBOT]> := \\(A : U) -> \\(f : <{t : 2 | TOP} -> A[BOT |-> recBOT]>) -> \\{ts : 2 * 2 | TOP} -> recOR ((first ts) <= (second ts), (second ts) <= (first ts), f (first ts), f (second ts)) isShapeRetraction : (I : CUBE) -> (A : U) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>) -> U := \\(I : CUBE) -> \\(A : U) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> \\(f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>) -> \u2211 (g : (k : <{t : I | phi t} -> A [BOT |-> recBOT]>) -> <{t : I | psi t} -> A [BOT |-> recBOT]>), (k : <{t : I | phi t} -> A [BOT |-> recBOT]>) -> f (g k) =_{<{t : I | phi t} -> A [BOT |-> recBOT]>} k shapeRetract : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> U := \\(I : CUBE) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> (A : U) -> \u2211 (f : (k : <{t : I | psi t} -> A [BOT |-> recBOT]>) -> <{t : I | phi t} -> A [BOT |-> recBOT]>), isShapeRetraction I A phi psi f \u0394\u00b9 : (t : 2) -> TOPE := \\(t : 2) -> TOP \u0394\u00b2 : (t : 2 * 2) -> TOPE := \\(t, s) -> s <= t \u0394\u00b3 : (t : 2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 shapeProd : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (chi : (s : J) -> TOPE) -> (ts : I * J) -> TOPE := \\I -> \\J -> \\psi -> \\chi -> \\(t, s) -> psi t /\\ chi s \u0394\u00b9\u00d7\u0394\u00b9 : (t : 2 * 2) -> TOPE := shapeProd 2 2 \u0394\u00b9 \u0394\u00b9 \u0394\u00b2\u00d7\u0394\u00b9 : (t : 2 * 2 * 2) -> TOPE := shapeProd (2 * 2) 2 \u0394\u00b2 \u0394\u00b9 \u0394\u00b2-is-retract-of-\u0394\u00b9\u00d7\u0394\u00b9 : shapeRetract (2 * 2) \u0394\u00b2 \u0394\u00b9\u00d7\u0394\u00b9 := \\A -> (\\k -> \\ts -> k ts, (\\k -> \\(t, s) -> recOR(t <= s, s <= t, k (t, s), k (t, s)), \\k -> refl_{k})) \u0394\u00b3-is-retract-of-\u0394\u00b2\u00d7\u0394\u00b9 : shapeRetract (2 * 2 * 2) \u0394\u00b3 \u0394\u00b2\u00d7\u0394\u00b9 := \\A -> (\\k -> \\ts -> k ((first (first ts), second ts), second (first ts)), (\\k -> \\ts -> recOR((second ts) <= (second (first ts)), (second (first ts)) <= (second ts) /\\ (second ts) <= (first (first ts)) \\/ (first (first ts)) <= second ts, k ((first (first ts), second ts), second (first ts)), recOR((second (first ts)) <= (second ts) /\\ (second ts) <= (first (first ts)), (first (first ts)) <= second ts, k ((first (first ts), second ts), second (first ts)), k ((first (first ts), first (first ts)), second (first ts)))), \\k -> refl_{k}))","title":"Hom-type"},{"location":"examples/section4/","text":"RS17, Section 4 prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f Theorem 4.1 RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>})))","title":"RS17, Section 4"},{"location":"examples/section4/#rs17-section-4","text":"prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f","title":"RS17, Section 4"},{"location":"examples/section4/#theorem-41","text":"RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>})))","title":"Theorem 4.1"},{"location":"examples/short/","text":"Short test (RS17, Theorem 4.1) prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <(t : I | psi t) -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <(t : I | phi t) -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <(t : I | psi t) -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <(t : I | phi t) -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>})))","title":"Short test (RS17, Theorem 4.1)"},{"location":"examples/short/#short-test-rs17-theorem-41","text":"prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <(t : I | psi t) -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <(t : I | phi t) -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <(t : I | psi t) -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <(t : I | phi t) -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <(t : I | psi t) -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <(t : I | psi t) -> Y t x [phi t |-> f t x]>})))","title":"Short test (RS17, Theorem 4.1)"},{"location":"examples/test/","text":"Examples Here are some super basic examples of declarations embedded in Markdown file. Identity function: id : (A : U) -> (_ : A) -> A := \\(B : U) -> \\(x : B) -> x Church-encoded booleans with id used to make type look more complicated: false : (id U) ((A : U) -> (_x : A) -> (_y : A) -> A) := \\(F : U) -> \\(x : F) -> \\(_ : F) -> x true : (A : U) -> (_ : A) -> (_ : A) -> A := \\(C : U) -> \\(_ : C) -> \\(y : C) -> y Dependent sums: prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B pair : (A : U) -> U := \\(A : U) -> (prod A) A ex1 : pair ((A : U) -> U) := ( id U, (id ((B : U) -> U)) (id U) ) ex2 : (A : U) -> U := first ex1 ex3 : (A : U) -> U := second ex1 ex4 : U := \u2211 (A : U), pair A ex5 : ex4 := (U, (U, U)) ex6 : ex4 := ((B : U) -> (x : B) -> B, (id, id)) Identity types: iscontr : (A : U) -> U := \\(A : U) -> \u2211 (x : A), (y : A) -> x =_{A} y isaprop : (A : U) -> U := \\(A : U) -> (x : A) -> (y : A) -> x =_{A} y invpath : (A : U) -> (x : A) -> (y : A) -> (p : x =_{A} y) -> y =_{A} x := \\(A : U) -> \\(x : A) -> \\(y : A) -> \\(p : x =_{A} y) -> idJ(A, x, \\(z : A) -> \\(_ : x =_{A} z) -> z =_{A} x, refl_{x : A}, y, p) ex7 : (A : U) -> (x : A) -> refl_{x : A} =_{x =_{A} x} ((((invpath A) x) x) refl_{x : A}) := \\(A : U) -> \\(x : A) -> refl_{refl_{x : A} : x =_{A} x} Equivalence: isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f idweq : (A : U) -> (weq A) A := \\(A : U) -> ( id A , ( id A, ( \\(x : A) -> refl_{x : A}, \\(x : A) -> refl_{x : A} ) ) ) Cubes and topes: ex8 : CUBE := 1 ex9 : CUBE := 1 * 1 ex10 : (I : CUBE) -> (t : I * I) -> I * I := \\(I : CUBE) -> \\(t : I * I) -> (second t, first t) ex11 : (t : 1 * 1) -> TOPE := \\(t : 1 * 1) -> (second t) === (first t) Constraints: ex12 : (I : CUBE) -> <{t : I | BOT} -> U[BOT |-> recBOT]> := \\(I : CUBE) -> \\{t : I | BOT} -> recBOT ex13 : (I : CUBE) -> (A : U) -> <{t : I | BOT} -> A[BOT |-> recBOT]> := \\(I : CUBE) -> \\(A : U) -> \\{t : I | BOT} -> recBOT ex14 : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (A : U) -> (a : <{t : I | phi t \\/ psi t} -> A[BOT |-> recBOT]>) -> <{t : I | psi t \\/ phi t} -> A[BOT |-> recBOT]> := \\(I : CUBE) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> \\(A : U) -> \\(a : <{t : I | phi t \\/ psi t} -> A[BOT |-> recBOT]>) -> \\{t : I | phi t \\/ psi t} -> a t RS17, Section 4 Theorem 4.1 RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>}))) Here's a version that's a bit nicer to read, but is not supported at the moment: RS17:Thm:4_1 : (I : CUBE) -> (psi : I -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (Y : <{t : I | psi t} -> (x : X) -> U>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\ I psi phi Y f -> (g, (h, (\\_ -> refl, \\_ -> refl))) where g = \\k x t -> k t x h = \\k t x -> k x t Theorem 4.2 RS17:Thm:4_2a : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (chi : {s : J | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> (f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> weq (x : X) -> {t : I | psi t} -> phi : {t : I | psi t} -> TOPE t : I | psi |- phi <{t : I | psi t} -> A t [ phi t |-> a t ] > <{t : 2 | TOP} -> A [ t === 0 \\/ t === 1 |-> recOR (t === 0) (t === 1) a b ]> <{u : I | psi u} -> <{s : J | zeta s} -> X u s [chi s |-> f (u, s)]> [phi u |-> \\{s : J | zeta s} -> f (u, s)]> <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts) [ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts]> (f, (g, (fg, gf))) := \\(I : CUBE) -> \\(J : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(zeta : (s : J) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(chi : {s : J | zeta s} -> TOPE) -> \\(X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> \\(f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> ( \\(k : <{t : I | psi t} -> <{s : J | zeta s} -> (X t) s[ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) -> \\{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> k (first ts) (second ts) , (\\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> \\{t : I | psi t} -> \\{s : J | zeta s} -> k (t, s), (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>) -> refl_{k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>}, \\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> refl_{k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>}))) RS17:Thm:4_2a : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (chi : {s : J | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> (f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> weq <{t : I | psi t} -> <{s : J | zeta s} -> X t s [chi s |-> f (t, s)]> [phi t |-> \\{s : J | zeta s} -> f (t, s)]> <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts) [ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts]> := \\(I : CUBE) -> \\(J : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(zeta : (s : J) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(chi : {s : J | zeta s} -> TOPE) -> \\(X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> \\(f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> (X t) s[ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) -> \\{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> k (first ts) (second ts), (\\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> \\{t : I | psi t} -> \\{s : J | zeta s} -> k (t, s), (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>) -> refl_{k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>}, \\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> refl_{k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>}))) Theorem 4.3 RS17:Thm:4_3 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : <{t : I | psi t} -> U [BOT |-> recBOT]>) -> (Y : <{t : I | psi t} -> (x : X t) -> U [BOT |-> recBOT]>) -> (a : <{t : I | phi t} -> X t [BOT |-> recBOT]>) -> (b : <{t : I | phi t} -> Y t (a t) [BOT |-> recBOT]>) -> weq <{t : I | psi t} -> \u2211 (x : X t), Y t x [phi t |-> (a t, b t)]> (\u2211 (f : <{t : I | psi t} -> X t [phi t |-> a t]>), <{t : I | psi t} -> Y t (f t) [phi t |-> b t]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : <{t : I | psi t} -> U [BOT |-> recBOT]>) -> \\(Y : <{t : I | psi t} -> (x : X t) -> U [BOT |-> recBOT]>) -> \\(a : <{t : I | phi t} -> X t [BOT |-> recBOT]>) -> \\(b : <{t : I | phi t} -> Y t (a t) [BOT |-> recBOT]>) -> (\\(k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>) -> (\\{t : I | psi t} -> first (k t), \\{t : I | psi t} -> second (k t)), (\\(k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>) -> \\{t : I | psi t} -> ((first k) t, (second k) t), (\\(k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>) -> refl_{k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>}, \\(k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>) -> refl_{k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>}))) Theorem 4.4 Typechecking Markdown files You can typecheck this file directly: rzk typecheck examples/test.md The result should look something like this Everything is ok! Free variables and their known types: true : ( A : \ud835\udcb0 ) \u2192 ( _ : A ) \u2192 ( _\u2081 : A ) \u2192 A false : ( A : \ud835\udcb0 ) \u2192 ( _x : A ) \u2192 ( _y : A ) \u2192 A id : ( A : \ud835\udcb0 ) \u2192 ( _ : A ) \u2192 A Type holes and their instantiations: ?A\u2082 := _ ?(H)\u2083 := \ud835\udcb0 ?A\u2081 := _ ?(H)\u2082 := \ud835\udcb0 ?U\u2081 := \ud835\udcb0 ?(H)\u2081 := \ud835\udcb0","title":"Examples"},{"location":"examples/test/#examples","text":"Here are some super basic examples of declarations embedded in Markdown file. Identity function: id : (A : U) -> (_ : A) -> A := \\(B : U) -> \\(x : B) -> x Church-encoded booleans with id used to make type look more complicated: false : (id U) ((A : U) -> (_x : A) -> (_y : A) -> A) := \\(F : U) -> \\(x : F) -> \\(_ : F) -> x true : (A : U) -> (_ : A) -> (_ : A) -> A := \\(C : U) -> \\(_ : C) -> \\(y : C) -> y Dependent sums: prod : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (x : A), B pair : (A : U) -> U := \\(A : U) -> (prod A) A ex1 : pair ((A : U) -> U) := ( id U, (id ((B : U) -> U)) (id U) ) ex2 : (A : U) -> U := first ex1 ex3 : (A : U) -> U := second ex1 ex4 : U := \u2211 (A : U), pair A ex5 : ex4 := (U, (U, U)) ex6 : ex4 := ((B : U) -> (x : B) -> B, (id, id)) Identity types: iscontr : (A : U) -> U := \\(A : U) -> \u2211 (x : A), (y : A) -> x =_{A} y isaprop : (A : U) -> U := \\(A : U) -> (x : A) -> (y : A) -> x =_{A} y invpath : (A : U) -> (x : A) -> (y : A) -> (p : x =_{A} y) -> y =_{A} x := \\(A : U) -> \\(x : A) -> \\(y : A) -> \\(p : x =_{A} y) -> idJ(A, x, \\(z : A) -> \\(_ : x =_{A} z) -> z =_{A} x, refl_{x : A}, y, p) ex7 : (A : U) -> (x : A) -> refl_{x : A} =_{x =_{A} x} ((((invpath A) x) x) refl_{x : A}) := \\(A : U) -> \\(x : A) -> refl_{refl_{x : A} : x =_{A} x} Equivalence: isweq : (A : U) -> (B : U) -> (f : (_ : A) -> B) -> U := \\(A : U) -> \\(B : U) -> \\(f : (_ : A) -> B) -> \u2211 (g : (_ : B) -> A), (prod ((x : A) -> (g (f x)) =_{A} x)) ((y : B) -> (f (g y)) =_{B} y) weq : (A : U) -> (B : U) -> U := \\(A : U) -> \\(B : U) -> \u2211 (f : (_ : A) -> B), ((isweq A) B) f idweq : (A : U) -> (weq A) A := \\(A : U) -> ( id A , ( id A, ( \\(x : A) -> refl_{x : A}, \\(x : A) -> refl_{x : A} ) ) ) Cubes and topes: ex8 : CUBE := 1 ex9 : CUBE := 1 * 1 ex10 : (I : CUBE) -> (t : I * I) -> I * I := \\(I : CUBE) -> \\(t : I * I) -> (second t, first t) ex11 : (t : 1 * 1) -> TOPE := \\(t : 1 * 1) -> (second t) === (first t) Constraints: ex12 : (I : CUBE) -> <{t : I | BOT} -> U[BOT |-> recBOT]> := \\(I : CUBE) -> \\{t : I | BOT} -> recBOT ex13 : (I : CUBE) -> (A : U) -> <{t : I | BOT} -> A[BOT |-> recBOT]> := \\(I : CUBE) -> \\(A : U) -> \\{t : I | BOT} -> recBOT ex14 : (I : CUBE) -> (phi : (t : I) -> TOPE) -> (psi : (t : I) -> TOPE) -> (A : U) -> (a : <{t : I | phi t \\/ psi t} -> A[BOT |-> recBOT]>) -> <{t : I | psi t \\/ phi t} -> A[BOT |-> recBOT]> := \\(I : CUBE) -> \\(phi : (t : I) -> TOPE) -> \\(psi : (t : I) -> TOPE) -> \\(A : U) -> \\(a : <{t : I | phi t \\/ psi t} -> A[BOT |-> recBOT]>) -> \\{t : I | phi t \\/ psi t} -> a t","title":"Examples"},{"location":"examples/test/#rs17-section-4","text":"","title":"RS17, Section 4"},{"location":"examples/test/#theorem-41","text":"RS17:Thm:4_1 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : U) -> (Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : U) -> \\(Y : <{t : I | psi t} -> (x : X) -> U [BOT |-> recBOT]>) -> \\(f : <{t : I | phi t} -> (x : X) -> Y t x [BOT |-> recBOT]>) -> (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> \\(x : X) -> \\{t : I | psi t} -> g t x, (\\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> \\{t : I | psi t} -> \\(x : X) -> g x t, (\\(g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) -> refl_{g : <{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>}, \\(g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) -> refl_{g : (x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>}))) Here's a version that's a bit nicer to read, but is not supported at the moment: RS17:Thm:4_1 : (I : CUBE) -> (psi : I -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (Y : <{t : I | psi t} -> (x : X) -> U>) -> (f : <{t : I | phi t} -> (x : X) -> Y t x>) -> weq (<{t : I | psi t} -> (x : X) -> Y t x [phi t |-> f t]>) ((x : X) -> <{t : I | psi t} -> Y t x [phi t |-> f t x]>) := \\ I psi phi Y f -> (g, (h, (\\_ -> refl, \\_ -> refl))) where g = \\k x t -> k t x h = \\k t x -> k x t","title":"Theorem 4.1"},{"location":"examples/test/#theorem-42","text":"RS17:Thm:4_2a : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (chi : {s : J | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> (f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> weq (x : X) -> {t : I | psi t} -> phi : {t : I | psi t} -> TOPE t : I | psi |- phi <{t : I | psi t} -> A t [ phi t |-> a t ] > <{t : 2 | TOP} -> A [ t === 0 \\/ t === 1 |-> recOR (t === 0) (t === 1) a b ]> <{u : I | psi u} -> <{s : J | zeta s} -> X u s [chi s |-> f (u, s)]> [phi u |-> \\{s : J | zeta s} -> f (u, s)]> <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts) [ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts]> (f, (g, (fg, gf))) := \\(I : CUBE) -> \\(J : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(zeta : (s : J) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(chi : {s : J | zeta s} -> TOPE) -> \\(X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> \\(f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> ( \\(k : <{t : I | psi t} -> <{s : J | zeta s} -> (X t) s[ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) -> \\{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> k (first ts) (second ts) , (\\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> \\{t : I | psi t} -> \\{s : J | zeta s} -> k (t, s), (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>) -> refl_{k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>}, \\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> refl_{k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>}))) RS17:Thm:4_2a : (I : CUBE) -> (J : CUBE) -> (psi : (t : I) -> TOPE) -> (zeta : (s : J) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (chi : {s : J | zeta s} -> TOPE) -> (X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> (f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> weq <{t : I | psi t} -> <{s : J | zeta s} -> X t s [chi s |-> f (t, s)]> [phi t |-> \\{s : J | zeta s} -> f (t, s)]> <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts) [ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts]> := \\(I : CUBE) -> \\(J : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(zeta : (s : J) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(chi : {s : J | zeta s} -> TOPE) -> \\(X : <{t : I | psi t} -> <{s : J | zeta s} -> U[BOT |-> recBOT]> [BOT |-> recBOT]>) -> \\(f : <{ts : I * J | (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts))} -> X (first ts) (second ts) [BOT |-> recBOT]>) -> (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> (X t) s[ chi s |-> f (t, s) ]> [ phi t |-> \\{s : J | zeta s} -> f (t, s) ]>) -> \\{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> k (first ts) (second ts), (\\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> X (first ts) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> \\{t : I | psi t} -> \\{s : J | zeta s} -> k (t, s), (\\(k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>) -> refl_{k : <{t : I | psi t} -> <{s : J | zeta s} -> X t s[ chi s |-> f (t, s) ]>[ phi t |-> \\{s : J | zeta s} \u2192 f (t, s) ]>}, \\(k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>) -> refl_{k : <{ts : I * J | psi (first ts) /\\ zeta (second ts)} -> (X (first ts)) (second ts)[ (phi (first ts) /\\ zeta (second ts)) \\/ (psi (first ts) /\\ chi (second ts)) |-> f ts ]>})))","title":"Theorem 4.2"},{"location":"examples/test/#theorem-43","text":"RS17:Thm:4_3 : (I : CUBE) -> (psi : (t : I) -> TOPE) -> (phi : {t : I | psi t} -> TOPE) -> (X : <{t : I | psi t} -> U [BOT |-> recBOT]>) -> (Y : <{t : I | psi t} -> (x : X t) -> U [BOT |-> recBOT]>) -> (a : <{t : I | phi t} -> X t [BOT |-> recBOT]>) -> (b : <{t : I | phi t} -> Y t (a t) [BOT |-> recBOT]>) -> weq <{t : I | psi t} -> \u2211 (x : X t), Y t x [phi t |-> (a t, b t)]> (\u2211 (f : <{t : I | psi t} -> X t [phi t |-> a t]>), <{t : I | psi t} -> Y t (f t) [phi t |-> b t]>) := \\(I : CUBE) -> \\(psi : (t : I) -> TOPE) -> \\(phi : {t : I | psi t} -> TOPE) -> \\(X : <{t : I | psi t} -> U [BOT |-> recBOT]>) -> \\(Y : <{t : I | psi t} -> (x : X t) -> U [BOT |-> recBOT]>) -> \\(a : <{t : I | phi t} -> X t [BOT |-> recBOT]>) -> \\(b : <{t : I | phi t} -> Y t (a t) [BOT |-> recBOT]>) -> (\\(k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>) -> (\\{t : I | psi t} -> first (k t), \\{t : I | psi t} -> second (k t)), (\\(k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>) -> \\{t : I | psi t} -> ((first k) t, (second k) t), (\\(k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>) -> refl_{k : <{t : I | psi t} -> \u2211 (x : X t), Y t x[ phi t |-> (a t, b t) ]>}, \\(k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>) -> refl_{k : \u2211 (f : <{t : I | psi t} -> X t[ phi t |-> a t ]>), <{t : I | psi t} -> Y t (f t)[ phi t |-> b t ]>})))","title":"Theorem 4.3"},{"location":"examples/test/#theorem-44","text":"","title":"Theorem 4.4"},{"location":"examples/test/#typechecking-markdown-files","text":"You can typecheck this file directly: rzk typecheck examples/test.md The result should look something like this Everything is ok! Free variables and their known types: true : ( A : \ud835\udcb0 ) \u2192 ( _ : A ) \u2192 ( _\u2081 : A ) \u2192 A false : ( A : \ud835\udcb0 ) \u2192 ( _x : A ) \u2192 ( _y : A ) \u2192 A id : ( A : \ud835\udcb0 ) \u2192 ( _ : A ) \u2192 A Type holes and their instantiations: ?A\u2082 := _ ?(H)\u2083 := \ud835\udcb0 ?A\u2081 := _ ?(H)\u2082 := \ud835\udcb0 ?U\u2081 := \ud835\udcb0 ?(H)\u2081 := \ud835\udcb0","title":"Typechecking Markdown files"},{"location":"related/sHoTT/","text":"sHoTT sHoTT is a formalisation project for simplicial HoTT and \u221e-categories. The project is a fork of https://github.com/emilyriehl/yoneda , with a goal to grow and eventually include various formalisations for HoTT (e.g. HoTT book), synthetic fibered \u221e-categories from the work of Ulrik Buchholtz and Jonathan Weinberger, variations of cubical type theories, etc. See more details in the documentation of the project at https://github.com/fizruk/sHoTT .","title":"sHoTT"},{"location":"related/sHoTT/#shott","text":"sHoTT is a formalisation project for simplicial HoTT and \u221e-categories. The project is a fork of https://github.com/emilyriehl/yoneda , with a goal to grow and eventually include various formalisations for HoTT (e.g. HoTT book), synthetic fibered \u221e-categories from the work of Ulrik Buchholtz and Jonathan Weinberger, variations of cubical type theories, etc. See more details in the documentation of the project at https://github.com/fizruk/sHoTT .","title":"sHoTT"},{"location":"related/simple-topes/","text":"simple-topes simple-topes is a playground theorem prover project for type theory with shapes that allows user-defined cubes and topes. Once stable, the project will be merged into rzk , extending it to a proof assistant for type theory with (user-defined) cubes, topes, and shapes. See more details in the documentation of the project at https://github.com/fizruk/simple-topes .","title":"simple-topes"},{"location":"related/simple-topes/#simple-topes","text":"simple-topes is a playground theorem prover project for type theory with shapes that allows user-defined cubes and topes. Once stable, the project will be merged into rzk , extending it to a proof assistant for type theory with (user-defined) cubes, topes, and shapes. See more details in the documentation of the project at https://github.com/fizruk/simple-topes .","title":"simple-topes"},{"location":"rzk-1/introduction/","text":"Introduction to rzk-1 Work-in-progress The documentation is not yet up-to-date with all the changes introduced in rzk-0.2.0 . See rzk changelog for more details. rzk is an experimental proof assistant for synthetic \u221e-categories. rzk-1 is an early version of the language supported by rzk . The language is based on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ). We will refer to Riehl and Shulman's Type Theory as RSTT. In this section, we introduce syntax, discuss features and some of the current limitations of the proof assistant. Overall, a program in rzk-1 consists of a language pragma (specifying that we use rzk-1 and not one of the other languages) followed by a sequence of commands. For now, we will only use #def command. Here is a small formalisation in an MLTT subset of rzk-1 : #lang rzk-1 -- Flipping the arguments of a function. #def flip (A B : U) -- For any types A and B (C : (x : A) -> (y : B) -> U) -- and a type family C (f : (x : A) -> (y : B) -> C x y) -- given a function f : A -> B -> C : (y : B) -> (x : A) -> C x y -- we construct a function of type B -> A -> C := \\y x -> f x y -- by swapping the arguments -- Flipping a function twice is the same as not doing anything #def flip-flip-is-id (A B : U) -- For any types A and B (C : (x : A) -> (y : B) -> U) -- and a type family C (f : (x : A) -> (y : B) -> C x y) -- given a function f : A -> B -> C : f = flip B A (\\y x -> C x y) (flip A B C f) -- flipping f twice is the same as f := refl -- proof by reflexivity Let us explain parts of this code: #lang rzk-1 specifies that we are in using rzk-1 language; -- starts a comment line (until the end of the line); #def <name> : <type> := <term> defines a name <name> to be equal to <term> ; the proof assistant will typecheck <term> against type <type> ; We define two terms here \u2014 flip and flip-flip-is-id ; flip is a function that takes 4 arguments and returns a function of two arguments. flip-flip-is-id is a function that takes two types, a type family, and a function f and returns a value of an identity type flip ... (flip ... f) = f , indicating that flipping a function f twice gets us back to f . Syntax Similarly to the three layers in RSTT, rzk-1 has 3 universes: CUBE is the universe of cubes, corresponding to the cube layer; TOPE is the universe of topes, corresponding to the tope layer; U is the universe of types, corresponding to the types and terms layer. Cube layer All cubes live in CUBE universe. There are two built-in cubes: 1 cube is a unit cube with a single point *_1 2 cube is a directed interval cube with points 0_2 and 1_2 It is also possible to have CUBE variables and make products of cubes: I * J is a product of cubes I and J (t, s) is a point in I * J if t : I and s : J if ts : I * J , then first ts : I and second ts : J You can usually use (t, s) both as a pattern, and a construction of a pair of points: -- Swap point components of a point in a cube I \u00d7 I #def swap (I : CUBE) : (I * I) -> I * I := \\(t, s) -> (s, t) Tope layer All topes live in TOPE universe. Here are all the ways to build a tope: Introduce a variable, e.g. (psi : TOPE) -> ... ; Usually, topes depend on point variables from some cube(s). To indicate that, we usually introduce topes as \"functions\" from some cube to TOPE . For example, (psi : I -> TOPE) -> ... . Use a constant: top tope \\top is written TOP ; bottom tope \\bot is written BOT ; tope conjunction \\psi \\land \\phi is written psi /\\ phi ; tope disjunction \\psi \\lor \\phi is written psi \\/ phi ; equality tope t \\equiv s is written t === s , whenever t and s are points of the same cube; inequality tope t \\leq s is written t <= s whenever t : 2 and s : 2 . Types and terms Function (dependent product) types \\prod_{x : A} B are written (x : A) -> B x values of function types are \\lambda -abstractions written in one of the following ways: \\x -> <body> \u2014 this is usually fine; \\(x : A) -> <body> \u2014 this sometimes helps the typechecker. Dependent sum type \\sum_{x : A} B is written \u2211 (x : A), B or Sigma (x : A), B values of dependent sum types are pairs written as (x, y) ; to access components of a dependent pair p , use first p and second p ; first and second are not valid syntax without an argument! Identity (path) type x =_A y is written x =_{A} y specifying the type A is optional: x = y is valid syntax! the only value of an identity type is refl_{x : A} whose type is x =_{A} x whenever x : A specifying term and type is optional: refl_{x} and refl are both valid syntax; path induction is done using J path eliminator; for any type A and a : A , type family C : \\prod_{x : A} ((a =_A x) \\to \\mathcal{U}) and d : C(a,\\mathsf{refl}_a) and x : A and p : a =_A x we have \\mathcal{J}(A, a, C, d, x, p) : C(x, p) ; in rzk-1 we write idJ(A, a, C, d, x, p) ; idJ is not valid syntax without exactly 6-tuple provided as an argument! Extension types \\left\\langle \\prod_{t : I \\mid \\psi} A \\vert ^{\\phi} _{a} \\right\\rangle are written as {t : I | psi t} -> A [ phi |-> a ] specifying [ phi |-> a ] is optional, semantically defaults to [ BOT |-> recBOT ] (like in RSTT); specifying psi in {t : I | psi} is mandatory; values of function types are \\lambda -abstractions written in one of the following ways: \\t -> <body> or \u03bbt \u2192 <body> \u2014 this is usually fine; \\{t : I | psi} -> <body> or \u03bb{t : I | psi} -> <body> \u2014 this sometimes helps the typechecker; Types of functions from a shape \\prod_{t : I \\mid \\psi} A are a specialised variant of extension types and are written {t : I | psi} -> A specifying the name of the argument is mandatory; i.e. {I | psi} -> A is invalid syntax! values of function types are \\lambda -abstractions written in one of the following ways: \\t -> <body> or \u03bbt \u2192 <body> \u2014 this is usually fine; \\{t : I | psi} -> <body> or \u03bb{t : I | psi} -> <body> \u2014 this sometimes helps the typechecker; Tope disjuction elimination Following RSTT, rzk-1 introduces two primitive terms for disjunction elimination: recBOT (also written rec\u22a5 ) corresponds to \\mathsf{rec}_\\bot , has any type, and is valid whenever tope context is included in BOT ; recOR(psi, phi, a_psi, a_phi) (also written rec\u2228(psi, phi, a_psi, a_phi) ) corresponds to \\mathsf{rec}_\\lor^{\\psi, \\phi}(a_\\psi, a_\\phi) , is well-typed when a_psi is definitionally equal to a_phi under psi /\\ phi . Soundness First of all, in rzk-1 we have \"type-in-type\", that is U has type U . This is known to make the type system unsound, however, it is usually considered acceptable in proof assistants. And, since it simplifies implementation, rzk-1 follows this convention. Additionally, unlike RSTT, rzk-1 does not prevent cubes or topes to depend on types and terms. For example, the following definition typechecks: #def weird (A : U) (I : A -> CUBE) (x y : A) : CUBE := I x * I y This likely leads to another inconsistency, but it will hardly lead to bugs in actual proofs of interest, so current version embraces this treatment of universes.","title":"Introduction"},{"location":"rzk-1/introduction/#introduction-to-rzk-1","text":"Work-in-progress The documentation is not yet up-to-date with all the changes introduced in rzk-0.2.0 . See rzk changelog for more details. rzk is an experimental proof assistant for synthetic \u221e-categories. rzk-1 is an early version of the language supported by rzk . The language is based on Riehl and Shulman's \u00abType Theory for Synthetic \u221e-categories\u00bb ( https://arxiv.org/abs/1705.07442 ). We will refer to Riehl and Shulman's Type Theory as RSTT. In this section, we introduce syntax, discuss features and some of the current limitations of the proof assistant. Overall, a program in rzk-1 consists of a language pragma (specifying that we use rzk-1 and not one of the other languages) followed by a sequence of commands. For now, we will only use #def command. Here is a small formalisation in an MLTT subset of rzk-1 : #lang rzk-1 -- Flipping the arguments of a function. #def flip (A B : U) -- For any types A and B (C : (x : A) -> (y : B) -> U) -- and a type family C (f : (x : A) -> (y : B) -> C x y) -- given a function f : A -> B -> C : (y : B) -> (x : A) -> C x y -- we construct a function of type B -> A -> C := \\y x -> f x y -- by swapping the arguments -- Flipping a function twice is the same as not doing anything #def flip-flip-is-id (A B : U) -- For any types A and B (C : (x : A) -> (y : B) -> U) -- and a type family C (f : (x : A) -> (y : B) -> C x y) -- given a function f : A -> B -> C : f = flip B A (\\y x -> C x y) (flip A B C f) -- flipping f twice is the same as f := refl -- proof by reflexivity Let us explain parts of this code: #lang rzk-1 specifies that we are in using rzk-1 language; -- starts a comment line (until the end of the line); #def <name> : <type> := <term> defines a name <name> to be equal to <term> ; the proof assistant will typecheck <term> against type <type> ; We define two terms here \u2014 flip and flip-flip-is-id ; flip is a function that takes 4 arguments and returns a function of two arguments. flip-flip-is-id is a function that takes two types, a type family, and a function f and returns a value of an identity type flip ... (flip ... f) = f , indicating that flipping a function f twice gets us back to f .","title":"Introduction to rzk-1"},{"location":"rzk-1/introduction/#syntax","text":"Similarly to the three layers in RSTT, rzk-1 has 3 universes: CUBE is the universe of cubes, corresponding to the cube layer; TOPE is the universe of topes, corresponding to the tope layer; U is the universe of types, corresponding to the types and terms layer.","title":"Syntax"},{"location":"rzk-1/introduction/#cube-layer","text":"All cubes live in CUBE universe. There are two built-in cubes: 1 cube is a unit cube with a single point *_1 2 cube is a directed interval cube with points 0_2 and 1_2 It is also possible to have CUBE variables and make products of cubes: I * J is a product of cubes I and J (t, s) is a point in I * J if t : I and s : J if ts : I * J , then first ts : I and second ts : J You can usually use (t, s) both as a pattern, and a construction of a pair of points: -- Swap point components of a point in a cube I \u00d7 I #def swap (I : CUBE) : (I * I) -> I * I := \\(t, s) -> (s, t)","title":"Cube layer"},{"location":"rzk-1/introduction/#tope-layer","text":"All topes live in TOPE universe. Here are all the ways to build a tope: Introduce a variable, e.g. (psi : TOPE) -> ... ; Usually, topes depend on point variables from some cube(s). To indicate that, we usually introduce topes as \"functions\" from some cube to TOPE . For example, (psi : I -> TOPE) -> ... . Use a constant: top tope \\top is written TOP ; bottom tope \\bot is written BOT ; tope conjunction \\psi \\land \\phi is written psi /\\ phi ; tope disjunction \\psi \\lor \\phi is written psi \\/ phi ; equality tope t \\equiv s is written t === s , whenever t and s are points of the same cube; inequality tope t \\leq s is written t <= s whenever t : 2 and s : 2 .","title":"Tope layer"},{"location":"rzk-1/introduction/#types-and-terms","text":"Function (dependent product) types \\prod_{x : A} B are written (x : A) -> B x values of function types are \\lambda -abstractions written in one of the following ways: \\x -> <body> \u2014 this is usually fine; \\(x : A) -> <body> \u2014 this sometimes helps the typechecker. Dependent sum type \\sum_{x : A} B is written \u2211 (x : A), B or Sigma (x : A), B values of dependent sum types are pairs written as (x, y) ; to access components of a dependent pair p , use first p and second p ; first and second are not valid syntax without an argument! Identity (path) type x =_A y is written x =_{A} y specifying the type A is optional: x = y is valid syntax! the only value of an identity type is refl_{x : A} whose type is x =_{A} x whenever x : A specifying term and type is optional: refl_{x} and refl are both valid syntax; path induction is done using J path eliminator; for any type A and a : A , type family C : \\prod_{x : A} ((a =_A x) \\to \\mathcal{U}) and d : C(a,\\mathsf{refl}_a) and x : A and p : a =_A x we have \\mathcal{J}(A, a, C, d, x, p) : C(x, p) ; in rzk-1 we write idJ(A, a, C, d, x, p) ; idJ is not valid syntax without exactly 6-tuple provided as an argument! Extension types \\left\\langle \\prod_{t : I \\mid \\psi} A \\vert ^{\\phi} _{a} \\right\\rangle are written as {t : I | psi t} -> A [ phi |-> a ] specifying [ phi |-> a ] is optional, semantically defaults to [ BOT |-> recBOT ] (like in RSTT); specifying psi in {t : I | psi} is mandatory; values of function types are \\lambda -abstractions written in one of the following ways: \\t -> <body> or \u03bbt \u2192 <body> \u2014 this is usually fine; \\{t : I | psi} -> <body> or \u03bb{t : I | psi} -> <body> \u2014 this sometimes helps the typechecker; Types of functions from a shape \\prod_{t : I \\mid \\psi} A are a specialised variant of extension types and are written {t : I | psi} -> A specifying the name of the argument is mandatory; i.e. {I | psi} -> A is invalid syntax! values of function types are \\lambda -abstractions written in one of the following ways: \\t -> <body> or \u03bbt \u2192 <body> \u2014 this is usually fine; \\{t : I | psi} -> <body> or \u03bb{t : I | psi} -> <body> \u2014 this sometimes helps the typechecker;","title":"Types and terms"},{"location":"rzk-1/introduction/#tope-disjuction-elimination","text":"Following RSTT, rzk-1 introduces two primitive terms for disjunction elimination: recBOT (also written rec\u22a5 ) corresponds to \\mathsf{rec}_\\bot , has any type, and is valid whenever tope context is included in BOT ; recOR(psi, phi, a_psi, a_phi) (also written rec\u2228(psi, phi, a_psi, a_phi) ) corresponds to \\mathsf{rec}_\\lor^{\\psi, \\phi}(a_\\psi, a_\\phi) , is well-typed when a_psi is definitionally equal to a_phi under psi /\\ phi .","title":"Tope disjuction elimination"},{"location":"rzk-1/introduction/#soundness","text":"First of all, in rzk-1 we have \"type-in-type\", that is U has type U . This is known to make the type system unsound, however, it is usually considered acceptable in proof assistants. And, since it simplifies implementation, rzk-1 follows this convention. Additionally, unlike RSTT, rzk-1 does not prevent cubes or topes to depend on types and terms. For example, the following definition typechecks: #def weird (A : U) (I : A -> CUBE) (x y : A) : CUBE := I x * I y This likely leads to another inconsistency, but it will hardly lead to bugs in actual proofs of interest, so current version embraces this treatment of universes.","title":"Soundness"},{"location":"rzk-1/recId/","text":"Tope disjuction elimination along identity paths \\mathsf{rec}_{\\lor}^{\\psi,\\phi}(a_\\psi, a_\\phi) (written recOR(psi, phi, a_psi, a_phi) in the code) is well-typed when a_\\psi and a_\\phi are definitionally equal on \\psi \\land \\phi . Sometimes this is too strong since many terms are not definitionally equal, but only equal up to a path. Luckily, assuming relative function extensionality, we can define a weaker version of rec_{\\lor} ( recOR ), which we call recId , that can work in presence of a witness of type \\prod_{t : I \\mid \\psi \\land \\phi} a_\\psi = a_\\phi . Prerequisites We begin by introducing common HoTT definitions: #lang rzk-1 -- A is contractible there exists x : A such that for any y : A we have x = y. #def iscontr (A : U) : U := \u2211 (a : A), (x : A) -> a =_{A} x -- A is a proposition if for any x, y : A we have x = y #def isaprop (A : U) : U := (x : A) -> (y : A) -> x =_{A} y -- A is a set if for any x, y : A the type x =_{A} y is a proposition #def isaset (A : U) : U := (x : A) -> (y : A) -> isaprop (x =_{A} y) -- Non-dependent product of A and B #def prod (A : U) (B : U) : U := \u2211 (x : A), B -- A function f : A -> B is an equivalence -- if there exists g : B -> A -- such that for all x : A we have g (f x) = x -- and for all y : B we have f (g y) = y #def isweq (A : U) (B : U) (f : A -> B) : U := \u2211 (g : B -> A), prod ((x : A) -> g (f x) =_{A} x) ((y : B) -> f (g y) =_{B} y) -- Equivalence of types A and B #def weq (A : U) (B : U) : U := \u2211 (f : A -> B), isweq A B f -- Transport along a path #def transport (A : U) (C : A -> U) (x y : A) (p : x =_{A} y) : C x -> C y := \\cx -> idJ(A, x, (\\z q -> C z), cx, y, p) Relative function extensionality We can now define relative function extensionality. There are several formulations, we provide two, following Riehl and Shulman: -- [RS17, Axiom 4.6] Relative function extensionality. #def relfunext : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> ((t : psi) -> iscontr (A t)) -> (a : (t : phi) -> A t) -> (t : psi) -> A t [ phi t |-> a t] -- [RS17, Proposition 4.8] A (weaker) formulation of function extensionality. #def relfunext2 : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> (a : (t : phi) -> A t) -> (f : (t : psi) -> A t [ phi t |-> a t ]) -> (g : (t : psi) -> A t [ phi t |-> a t ]) -> weq (f = g) ((t : psi) -> (f t =_{A t} g t) [ phi t |-> refl ]) Construction of recId The idea is straightforward. We ask for a proof that a = b for all points in psi /\\ phi . Then, by relative function extensionality ( relfunext2 ), we can show that restrictions of a and b to psi /\\ phi are equal. If we reformulate a as extension of its restriction, then we can transport such reformulation along the path connecting two restrictions and apply recOR . First, we define how to restrict an extension type to a subshape: -- Restrict extension type to a subshape. #def restrict (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a : {t : I | psi t} -> A t) : {t : I | psi t /\\ phi t} -> A t := \\t -> a t Then, how to reformulate an a (or b ) as an extension of its restriction: -- Reformulate extension type as an extension of a restriction. #def ext-of-restrict (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a : {t : I | psi t} -> A t) : (t : psi) -> A t [ psi t /\\ phi t |-> restrict I psi phi A a t ] := a -- type is coerced automatically here Now, assuming relative function extensionality, we construct a path between restrictions: -- Transform extension of an identity into an identity of restrictions. #def restricts-path (r : relfunext2) (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a_psi : (t : psi) -> A t) (a_phi : (t : phi) -> A t) (e : {t : I | psi t /\\ phi t} -> a_psi t = a_phi t) : restrict I psi phi A a_psi = restrict I phi psi A a_phi := (first (second (r I (\\t -> psi t /\\ phi t) (\\t -> BOT) (\\t -> A t) (\\t -> recBOT) (\\t -> a_psi t) (\\t -> a_phi t)))) e Finally, we bring everything together into recId : -- A weaker version of recOR, demanding only a path between a and b: -- recOR(psi, phi, a, b) demands that for psi /\\ phi we have a == b (definitionally) -- (recId psi phi a b e) demands that e is the proof that a = b (intensionally) for psi /\\ phi #def recId (r : relfunext2) (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a_psi : (t : psi) -> A t) (a_phi : (t : phi) -> A t) (e : {t : I | psi t /\\ phi t} -> a_psi t = a_phi t) : {t : I | psi t \\/ phi t} -> A t := \\t -> recOR( psi t |-> transport ({s : I | psi s /\\ phi s} -> A s) (\\ra -> (s : psi) -> A s [ psi s /\\ phi s |-> ra s ]) (restrict I psi phi A a_psi) (restrict I phi psi A a_phi) (restricts-path r I psi phi A a_psi a_phi e) (ext-of-restrict I psi phi A a_psi) t, phi t |-> ext-of-restrict I phi psi A a_phi t ) Gluing extension types An application of of recId is gluing together extension types, whenever we can show that they are equal on the intersection of shapes: -- If two extension types are equal along two subshapes, -- then they are also equal along their union. #def id-along-border (r : relfunext2) (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a b : {t : I | psi t \\/ phi t} -> A t) (e_psi : (t : psi) -> a t = b t) (e_phi : (t : phi) -> a t = b t) (border-is-a-set : {t : I | psi t /\\ phi t} -> isaset (A t)) : {t : I | psi t \\/ phi t} -> a t = b t := recId r I psi phi (\\t -> a t = b t) e_psi e_phi (\\t -> border-is-a-set t (a t) (b t) (e_psi t) (e_phi t))","title":"Weak tope disjunction elimination"},{"location":"rzk-1/recId/#tope-disjuction-elimination-along-identity-paths","text":"\\mathsf{rec}_{\\lor}^{\\psi,\\phi}(a_\\psi, a_\\phi) (written recOR(psi, phi, a_psi, a_phi) in the code) is well-typed when a_\\psi and a_\\phi are definitionally equal on \\psi \\land \\phi . Sometimes this is too strong since many terms are not definitionally equal, but only equal up to a path. Luckily, assuming relative function extensionality, we can define a weaker version of rec_{\\lor} ( recOR ), which we call recId , that can work in presence of a witness of type \\prod_{t : I \\mid \\psi \\land \\phi} a_\\psi = a_\\phi .","title":"Tope disjuction elimination along identity paths"},{"location":"rzk-1/recId/#prerequisites","text":"We begin by introducing common HoTT definitions: #lang rzk-1 -- A is contractible there exists x : A such that for any y : A we have x = y. #def iscontr (A : U) : U := \u2211 (a : A), (x : A) -> a =_{A} x -- A is a proposition if for any x, y : A we have x = y #def isaprop (A : U) : U := (x : A) -> (y : A) -> x =_{A} y -- A is a set if for any x, y : A the type x =_{A} y is a proposition #def isaset (A : U) : U := (x : A) -> (y : A) -> isaprop (x =_{A} y) -- Non-dependent product of A and B #def prod (A : U) (B : U) : U := \u2211 (x : A), B -- A function f : A -> B is an equivalence -- if there exists g : B -> A -- such that for all x : A we have g (f x) = x -- and for all y : B we have f (g y) = y #def isweq (A : U) (B : U) (f : A -> B) : U := \u2211 (g : B -> A), prod ((x : A) -> g (f x) =_{A} x) ((y : B) -> f (g y) =_{B} y) -- Equivalence of types A and B #def weq (A : U) (B : U) : U := \u2211 (f : A -> B), isweq A B f -- Transport along a path #def transport (A : U) (C : A -> U) (x y : A) (p : x =_{A} y) : C x -> C y := \\cx -> idJ(A, x, (\\z q -> C z), cx, y, p)","title":"Prerequisites"},{"location":"rzk-1/recId/#relative-function-extensionality","text":"We can now define relative function extensionality. There are several formulations, we provide two, following Riehl and Shulman: -- [RS17, Axiom 4.6] Relative function extensionality. #def relfunext : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> ((t : psi) -> iscontr (A t)) -> (a : (t : phi) -> A t) -> (t : psi) -> A t [ phi t |-> a t] -- [RS17, Proposition 4.8] A (weaker) formulation of function extensionality. #def relfunext2 : U := (I : CUBE) -> (psi : I -> TOPE) -> (phi : psi -> TOPE) -> (A : psi -> U) -> (a : (t : phi) -> A t) -> (f : (t : psi) -> A t [ phi t |-> a t ]) -> (g : (t : psi) -> A t [ phi t |-> a t ]) -> weq (f = g) ((t : psi) -> (f t =_{A t} g t) [ phi t |-> refl ])","title":"Relative function extensionality"},{"location":"rzk-1/recId/#construction-of-recid","text":"The idea is straightforward. We ask for a proof that a = b for all points in psi /\\ phi . Then, by relative function extensionality ( relfunext2 ), we can show that restrictions of a and b to psi /\\ phi are equal. If we reformulate a as extension of its restriction, then we can transport such reformulation along the path connecting two restrictions and apply recOR . First, we define how to restrict an extension type to a subshape: -- Restrict extension type to a subshape. #def restrict (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a : {t : I | psi t} -> A t) : {t : I | psi t /\\ phi t} -> A t := \\t -> a t Then, how to reformulate an a (or b ) as an extension of its restriction: -- Reformulate extension type as an extension of a restriction. #def ext-of-restrict (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a : {t : I | psi t} -> A t) : (t : psi) -> A t [ psi t /\\ phi t |-> restrict I psi phi A a t ] := a -- type is coerced automatically here Now, assuming relative function extensionality, we construct a path between restrictions: -- Transform extension of an identity into an identity of restrictions. #def restricts-path (r : relfunext2) (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a_psi : (t : psi) -> A t) (a_phi : (t : phi) -> A t) (e : {t : I | psi t /\\ phi t} -> a_psi t = a_phi t) : restrict I psi phi A a_psi = restrict I phi psi A a_phi := (first (second (r I (\\t -> psi t /\\ phi t) (\\t -> BOT) (\\t -> A t) (\\t -> recBOT) (\\t -> a_psi t) (\\t -> a_phi t)))) e Finally, we bring everything together into recId : -- A weaker version of recOR, demanding only a path between a and b: -- recOR(psi, phi, a, b) demands that for psi /\\ phi we have a == b (definitionally) -- (recId psi phi a b e) demands that e is the proof that a = b (intensionally) for psi /\\ phi #def recId (r : relfunext2) (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a_psi : (t : psi) -> A t) (a_phi : (t : phi) -> A t) (e : {t : I | psi t /\\ phi t} -> a_psi t = a_phi t) : {t : I | psi t \\/ phi t} -> A t := \\t -> recOR( psi t |-> transport ({s : I | psi s /\\ phi s} -> A s) (\\ra -> (s : psi) -> A s [ psi s /\\ phi s |-> ra s ]) (restrict I psi phi A a_psi) (restrict I phi psi A a_phi) (restricts-path r I psi phi A a_psi a_phi e) (ext-of-restrict I psi phi A a_psi) t, phi t |-> ext-of-restrict I phi psi A a_phi t )","title":"Construction of recId"},{"location":"rzk-1/recId/#gluing-extension-types","text":"An application of of recId is gluing together extension types, whenever we can show that they are equal on the intersection of shapes: -- If two extension types are equal along two subshapes, -- then they are also equal along their union. #def id-along-border (r : relfunext2) (I : CUBE) (psi : I -> TOPE) (phi : I -> TOPE) (A : {t : I | psi t \\/ phi t} -> U) (a b : {t : I | psi t \\/ phi t} -> A t) (e_psi : (t : psi) -> a t = b t) (e_phi : (t : phi) -> a t = b t) (border-is-a-set : {t : I | psi t /\\ phi t} -> isaset (A t)) : {t : I | psi t \\/ phi t} -> a t = b t := recId r I psi phi (\\t -> a t = b t) e_psi e_phi (\\t -> border-is-a-set t (a t) (b t) (e_psi t) (e_phi t))","title":"Gluing extension types"},{"location":"rzk-1/render/","text":"Rendering Diagrams Starting from version 0.3.0 , rzk supports rendering of topes, types, and terms as diagrams. This is a literate rzk file: #lang rzk-1 To enable rendering, enable option \"render\" = \"svg\" (to disable, \"render\" = \"none\" ): #set-option \"render\" = \"svg\" -- enable rendering in SVG Rendering is completely automatic, and works in the following situations: Mapping from a shape (including curried mappings), up to 3 dimensions, only in products of 2 cubes; Type of mapping from a shape (including curried mappings), up to 3 dimensions, only in products of 2 cubes. Mappings from a shape that is a section of an existing shape. The rendering assigns the following colors: purple is assigned for parameters (context) variables; blue is used for fillings for types (e.g. for hom and hom2 ); red is used for terms (e.g. Segal-comp-witness ); orange is used for shapes in the tope layer; grey is used for discarded parts of a (larger) mapping (e.g. when extracting a diagonal/face from a larger shape). The SVG pictures can be inserted directly into .md files before a corresponding rzk code block. At the bottom of a markdown file, you might want to add stylization, e.g.: <style> .zoom { transition: transform .2s; /* Animation */ } .zoom:hover { transform: scale(1.5); /* (150% zoom - Note: if the zoom is too large, it will go outside of the viewport) */ } </style> <!-- Definitions for the SVG images above --> <svg width=\"0\" height=\"0\"> <defs> <style data-bx-fonts=\"Noto Serif\">@import url(https://fonts.googleapis.com/css2?family=Noto+Serif&display=swap);</style> <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"5\" refY=\"5\" markerWidth=\"5\" markerHeight=\"5\" orient=\"auto-start-reverse\"> <path d=\"M 0 2 L 5 5 L 0 8 z\" stroke=\"purple\" fill=\"purple\" /> </marker> </defs> <style> text, textPath { font-family: Noto Serif; font-size: 28px; dominant-baseline: middle; text-anchor: middle; } </style> </svg> Examples Visualising Simplicial Topes Topes are visualised with orange color: \u2022 \u2022 \u2022 -- 2-simplex #def \u0394\u00b2 : (2 * 2) -> TOPE := \\(t, s) -> s <= t Boundary of a tope: \u2022 \u2022 \u2022 -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 -> TOPE := \\(t, s) -> s === 0_2 \\/ t === 1_2 \\/ s === t The busiest tope diagram involves the entire 3D cube: \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 -- 3-dim cube #def 2\u00b3 : (2 * 2 * 2) -> TOPE := \\_ -> TOP \u2022 \u2022 \u2022 \u2022 -- 3-simplex #def \u0394\u00b3 : (2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1 Visualising Simplicial Types Types are visualised with blue color. Recognised parameter part (e.g. fixed endpoints, edges, faces with clear labels) are visualised with purple color. When a type is constructed by taking a part of another shape, the rest of the larger shape is colored using gray color. x y -- [RS17, Definition 5.1] -- The type of arrows in A from x to y. #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U -- (hom A x y) is a 1-simplex (an arrow) := (t : 2) -> A [ -- in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] f f h h g g x y z -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U -- (hom2 A x y z f g h) is a 2-simplex (triangle) := { (t1, t2) : \u0394\u00b2 } -> A [ -- in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ] Visualising Terms of Simplicial Types Terms (with non-trivial labels) are visualised with red color (you can see a detailed label on hover). Recognised parameter part (e.g. fixed endpoints, edges, faces with clear labels) are visualised with purple color. When a term is constructed by taking a part of another shape, the rest of the larger shape is colored using gray color. We can visualise terms that fill a shape: second a (second x\u2082, first x\u2082) second a (first x\u2082, second x\u2082) f f f f first a (second (first x\u2082, second x\u2082)) g g g g x y y z #def square (A : U) (x y z : A) (f : hom A x y) (g : hom A y z) (h : hom A x z) (a : Sigma (h' : hom A x z), hom2 A x y z f g h') : (2 * 2) -> A := \\(t, s) -> recOR( s <= t |-> second a (t, s) , t <= s |-> second a (s, t)) If a term is extracted as a part of a larger shape, generally, the whole shape will be shown (in gray): second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 first a (second x\u2082) first a (second x\u2082) f f second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 first a (second x\u2082) y y first a (second x\u2082) z z first a (second x\u2082) x y y z y z #def face (A : U) (x y z : A) (f : hom A x y) (a : Sigma (g : hom A y z), {((t1, t2), t3) : 2 * 2 * 2 | t3 <= t1 \\/ t2 <= t1} -> A [ t1 === 0_2 |-> f t2, t1 === 1_2 |-> g t3 ]) : \u0394\u00b2 -> A := \\(t, s) -> second a ((t, t), s) .zoom { transition: transform .2s; /* Animation */ } .zoom:hover { transform: scale(1.5); /* (150% zoom - Note: if the zoom is too large, it will go outside of the viewport) */ } @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 28px; dominant-baseline: middle; text-anchor: middle; }","title":"Rendering Diagrams"},{"location":"rzk-1/render/#rendering-diagrams","text":"Starting from version 0.3.0 , rzk supports rendering of topes, types, and terms as diagrams. This is a literate rzk file: #lang rzk-1 To enable rendering, enable option \"render\" = \"svg\" (to disable, \"render\" = \"none\" ): #set-option \"render\" = \"svg\" -- enable rendering in SVG Rendering is completely automatic, and works in the following situations: Mapping from a shape (including curried mappings), up to 3 dimensions, only in products of 2 cubes; Type of mapping from a shape (including curried mappings), up to 3 dimensions, only in products of 2 cubes. Mappings from a shape that is a section of an existing shape. The rendering assigns the following colors: purple is assigned for parameters (context) variables; blue is used for fillings for types (e.g. for hom and hom2 ); red is used for terms (e.g. Segal-comp-witness ); orange is used for shapes in the tope layer; grey is used for discarded parts of a (larger) mapping (e.g. when extracting a diagonal/face from a larger shape). The SVG pictures can be inserted directly into .md files before a corresponding rzk code block. At the bottom of a markdown file, you might want to add stylization, e.g.: <style> .zoom { transition: transform .2s; /* Animation */ } .zoom:hover { transform: scale(1.5); /* (150% zoom - Note: if the zoom is too large, it will go outside of the viewport) */ } </style> <!-- Definitions for the SVG images above --> <svg width=\"0\" height=\"0\"> <defs> <style data-bx-fonts=\"Noto Serif\">@import url(https://fonts.googleapis.com/css2?family=Noto+Serif&display=swap);</style> <marker id=\"arrow\" viewBox=\"0 0 10 10\" refX=\"5\" refY=\"5\" markerWidth=\"5\" markerHeight=\"5\" orient=\"auto-start-reverse\"> <path d=\"M 0 2 L 5 5 L 0 8 z\" stroke=\"purple\" fill=\"purple\" /> </marker> </defs> <style> text, textPath { font-family: Noto Serif; font-size: 28px; dominant-baseline: middle; text-anchor: middle; } </style> </svg>","title":"Rendering Diagrams"},{"location":"rzk-1/render/#examples","text":"","title":"Examples"},{"location":"rzk-1/render/#visualising-simplicial-topes","text":"Topes are visualised with orange color: \u2022 \u2022 \u2022 -- 2-simplex #def \u0394\u00b2 : (2 * 2) -> TOPE := \\(t, s) -> s <= t Boundary of a tope: \u2022 \u2022 \u2022 -- boundary of a 2-simplex #def \u2202\u0394\u00b2 : \u0394\u00b2 -> TOPE := \\(t, s) -> s === 0_2 \\/ t === 1_2 \\/ s === t The busiest tope diagram involves the entire 3D cube: \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 -- 3-dim cube #def 2\u00b3 : (2 * 2 * 2) -> TOPE := \\_ -> TOP \u2022 \u2022 \u2022 \u2022 -- 3-simplex #def \u0394\u00b3 : (2 * 2 * 2) -> TOPE := \\((t1, t2), t3) -> t3 <= t2 /\\ t2 <= t1","title":"Visualising Simplicial Topes"},{"location":"rzk-1/render/#visualising-simplicial-types","text":"Types are visualised with blue color. Recognised parameter part (e.g. fixed endpoints, edges, faces with clear labels) are visualised with purple color. When a type is constructed by taking a part of another shape, the rest of the larger shape is colored using gray color. x y -- [RS17, Definition 5.1] -- The type of arrows in A from x to y. #def hom (A : U) -- A type. (x y : A) -- Two points in A. : U -- (hom A x y) is a 1-simplex (an arrow) := (t : 2) -> A [ -- in A where t === 0_2 |-> x, -- * the left endpoint is exactly x t === 1_2 |-> y -- * the right endpoint is exactly y ] f f h h g g x y z -- [RS17, Definition 5.2] -- the type of commutative triangles in A #def hom2 (A : U) -- A type. (x y z : A) -- Three points in A. (f : hom A x y) -- An arrow in A from x to y. (g : hom A y z) -- An arrow in A from y to z. (h : hom A x z) -- An arrow in A from x to z. : U -- (hom2 A x y z f g h) is a 2-simplex (triangle) := { (t1, t2) : \u0394\u00b2 } -> A [ -- in A where t2 === 0_2 |-> f t1, -- * the top edge is exactly f, t1 === 1_2 |-> g t2, -- * the right edge is exactly g, and t2 === t1 |-> h t2 -- * the diagonal is exactly h ]","title":"Visualising Simplicial Types"},{"location":"rzk-1/render/#visualising-terms-of-simplicial-types","text":"Terms (with non-trivial labels) are visualised with red color (you can see a detailed label on hover). Recognised parameter part (e.g. fixed endpoints, edges, faces with clear labels) are visualised with purple color. When a term is constructed by taking a part of another shape, the rest of the larger shape is colored using gray color. We can visualise terms that fill a shape: second a (second x\u2082, first x\u2082) second a (first x\u2082, second x\u2082) f f f f first a (second (first x\u2082, second x\u2082)) g g g g x y y z #def square (A : U) (x y z : A) (f : hom A x y) (g : hom A y z) (h : hom A x z) (a : Sigma (h' : hom A x z), hom2 A x y z f g h') : (2 * 2) -> A := \\(t, s) -> recOR( s <= t |-> second a (t, s) , t <= s |-> second a (s, t)) If a term is extracted as a part of a larger shape, generally, the whole shape will be shown (in gray): second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 first a (second x\u2082) first a (second x\u2082) f f second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 second a x\u2082 first a (second x\u2082) y y first a (second x\u2082) z z first a (second x\u2082) x y y z y z #def face (A : U) (x y z : A) (f : hom A x y) (a : Sigma (g : hom A y z), {((t1, t2), t3) : 2 * 2 * 2 | t3 <= t1 \\/ t2 <= t1} -> A [ t1 === 0_2 |-> f t2, t1 === 1_2 |-> g t3 ]) : \u0394\u00b2 -> A := \\(t, s) -> second a ((t, t), s) .zoom { transition: transform .2s; /* Animation */ } .zoom:hover { transform: scale(1.5); /* (150% zoom - Note: if the zoom is too large, it will go outside of the viewport) */ } @import url(https://fonts.googleapis.com/css2?family=Noto+Serif&amp;display=swap); text, textPath { font-family: Noto Serif; font-size: 28px; dominant-baseline: middle; text-anchor: middle; }","title":"Visualising Terms of Simplicial Types"},{"location":"tools/continuous/","text":"Continuous Verification with rzk GitHub Actions Work-in-progress GitHub Actions for rzk is in under development and will be released soon.","title":"Continuous Verification"},{"location":"tools/continuous/#continuous-verification-with-rzk","text":"","title":"Continuous Verification with rzk"},{"location":"tools/continuous/#github-actions","text":"Work-in-progress GitHub Actions for rzk is in under development and will be released soon.","title":"GitHub Actions"},{"location":"tools/ide/","text":"IDE support for rzk VS Code There exists a VS Code extension for rzk ( on VS Marketplace , on GitHub ). Please, refer to the documentation of the extension for more details.","title":"IDE support"},{"location":"tools/ide/#ide-support-for-rzk","text":"","title":"IDE support for rzk"},{"location":"tools/ide/#vs-code","text":"There exists a VS Code extension for rzk ( on VS Marketplace , on GitHub ). Please, refer to the documentation of the extension for more details.","title":"VS Code"}]}